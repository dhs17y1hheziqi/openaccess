
/*
 * Copyright (c) 1998 - 2005 Versant Corporation
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 * Versant Corporation - initial API and implementation
 */
package com.versant.core.common;

import com.versant.core.jdo.PCStateMan;
import com.versant.core.metadata.*;
import com.versant.core.jdo.DetachStateContainer;
import com.versant.core.jdo.VersantPersistenceManagerImp;
import com.versant.core.jdo.*;
import com.versant.core.server.OIDGraph;
import com.versant.core.server.PersistGraph;
import com.versant.core.util.IntArray;
import com.versant.core.util.OIDObjectOutput;
import com.versant.core.util.OIDObjectInput;

import javax.jdo.spi.PersistenceCapable;
import java.util.*;
import java.io.IOException;



/**
 * This is an abstract base class for State classes. Each State class is
 * a container for the persistent fields of a PC class and all of its
 * superclasses. These fields may include fake fields generated by the
 * store to hold extra store specific information (e.g. row version column
 * values).<p>
 * <p/>
 * Methods always use field numbers relative to the topmost class in the
 * hierarchy. This range of numbers includes fake fields present in each
 * class.<p>
 * <p/>
 * Example of the State fieldNo range for C extends B extends A:<br>
 * A.superFieldCount[A fields] (A.superFieldCount + A.realFieldCount)[A fakes]<br>
 * B.superFieldCount[B fields] (B.superFieldCount + B.realFieldCount)[B fakes]<br>
 * C.superFieldCount[C fields] (C.superFieldCount + C.realFieldCount)[C fakes]<p>
 * <p/>
 * Each PC class has its own implementation generated for it at runtime.
 * These classes have fast implementations of various methods in the
 * base class designed for different data stores. The JDO meta data for each
 * PC class is a factory for its State instances.<p>
 *
 *
 * Lifecycle:
 *
 *
 * State is create in datastore on a request for data. This state is offered to
 * the l2cache and returned to the requesting client. There the state is eiter used to
 * update the state of a PCStateMan or added directly to the LocalPMCache.
 *
 * Any mutable data in that is contained in a state should be considered immutable. This
 * is because if can share the same data that was returned by a state and changing it would result
 * in weird behaviour.
 *
 * TODO: Go through all data struct that is returned by state and check if
 * immutablility can be enforced.
 *
 * @see ClassMetaData#fields
 * @see ClassMetaData#realFieldCount
 * @see ClassMetaData#superFieldCount
 */
public abstract class State
 {

    /**
     * To check if the state is hollow.
     * This is for debug/testing only.
     */
    public abstract boolean isHollow();

    /**
     * Return a new State instance
     *
     * @return new State instance
     */
    public abstract State newInstance();

    /**
     * Return the index of our PC class in the meta data. Do not use this
     * to get the meta data for our class. Call getClassMetaData instead.
     *
     * @see ModelMetaData#classes
     * @see #getClassMetaData
     */
    public abstract int getClassIndex();

    /**
     * Get the meta data for our class.
     *
     * @param jmd The meta data we belong to
     */
    public abstract ClassMetaData getClassMetaData(ModelMetaData jmd);

    /**
     * Return true if any field is dirty.
     */
    public abstract boolean isDirty();

    /**
     * Check if a specific field is dirty.
     *
     * @param fieldNo
     */
    public abstract boolean isDirty(int fieldNo);

    /**
     * This is just for testing and will not be called in (real)runtime.
     */
    public void validateForCache() {

    }

    /**
     * Mark the specified field as dirty.
     *
     * @param fieldNo
     */
    public abstract void makeDirtyAbs(int fieldNo);

    public abstract void makeDirty(int stateFieldNo);

    /**
     * Mark all dirty fields as clean and not filled and not resolved.
     */
    public abstract void clearDirtyFields();

    /**
     * Update this state from the supplied state. All fields will be updated even
     * if it is filled in on this state.
     *
     * @param state
     */
    public abstract void updateFrom(State state);

    /**
     * Update this state from the supplied state. Only the fields not filled in
     * on the current state and filled in on the supplied state will be updated.
     *
     * @param state
     */
    public abstract void updateNonFilled(State state);

    /**
     * Clear all the non autoSet fields.
     */
    public abstract void clearNonAutoSetFields();

    public abstract void retrieve(VersantPersistenceManagerImp sm);

    /**
     * Clear the fields in this state that is not filled in on the supplied state.
     *
     * @param state
     */
    public abstract void clearNonFilled(State state);

    /**
     * Clear all fields of type mem.
     */
    public abstract void clearCollectionFields();

    /**
     * This cleares all the sco fields of the state of their values and sets it
     * to non filled.
     */
    public abstract void clearSCOFields();

    /**
     * Clear all the transaction but non persistent fields.
     */
    public abstract void clearTransactionNonPersistentFields();

    /**
     * <p>This return a deep clone of this state instance with only fields that
     * must be sent to the server to persist changes to this instance filled
     * in. For JdbcDataStore this will include only the dirty fields. For
     * VdsDataStore this includes all fields so the whole DataStoreObject
     * can be written.</p>
     * <p/>
     * <p>All 'First Class Objects' will be resolved to an OID and
     * 'Second Class Objects' will be resolved to some serializable/storable
     * format that represents the state of the field.</p>
     *
     * @return True if some fields were written to stateToStore and false if
     *         not (i.e. we have no dirty fields)
     */
    public abstract boolean fillToStoreState(State stateToStore,
            PersistenceContext sm,
            VersantStateManager pcStateMan);

    /**
     * Fill dest with all of the fake and ref fields of this State. This is used
     * for stores that require the current values of fake fields to be sent when
     * fetching certain fields (e.g. fetching a Collection stored as an SCO
     * in VDS). The ref fields are converted into OIDs if they are pc.
     */
    public abstract void fillForRead(State dest,
            VersantPersistenceManagerImp sm);

    /**
     * Make a shallow copy of the state.
     */
    public abstract State getCopy();

    /**
     * This must copy the fields from the supplied to the current state. The copied
     * fields is used for to compare against to detect concurrent updates.
     *
     * @param state
     * @param sm
     */
    public abstract void copyFieldsForOptimisticLocking(State state,
            VersantPersistenceManagerImp sm);

    /**
     * This copies the optimistic locking field if not already set.
     * @param state
     */
    public abstract void copyOptimisticLockingField(State state);

    /**
     * This will replace all fields that should be a SCO field with it's SCO implementation.
     * This is used for retain values where the client has set a field that must be a sco field and
     * this must be converted after commit.
     */
    public abstract int replaceSCOFields(PersistenceCapable owner,
            VersantPMProxy sm, int[] absFieldNos);




    /**
     * Called when the pc instance is made transient to unset the sco instance of
     * the pc owner.
     */
    public abstract void unmanageSCOFields();

    /**
     */
    public abstract void addRefs(VersantPersistenceManagerImp sm, PCStateMan pcStateMan);

    /**
     * Clear the state of all its fields and reset it to notFilled.
     */
    public abstract void clear();

    /**
     * Reset the filled flag for each field.
     */
    public abstract void clearFilledFlags();

    /**
     * Reset the dirty status of the state and its fields.
     */
    public abstract void makeClean();

    /**
     * Set the meta data for this State. If this is stored in a field it
     * must be transient. This will be called again when saving so there
     * is no need to trundle it back and forth.
     */
    public abstract void setClassMetaData(ClassMetaData cmd);

    /**
     * Return the ClassMetaData.
     */
    public abstract ClassMetaData getClassMetaData();

    /**
     * Return true if the value for this stateFieldNo is valid i.e. it has been
     * read from the data store or set by a client etc etc.
     */
    public abstract boolean containsField(int stateFieldNo);

    /**
     * Return true if the value for this absFieldNo is valid i.e. it has been
     * read from the data store or set by a client etc etc.
     */
    public abstract boolean containsFieldAbs(int absFieldNo);

    /**
     * Check if the state contains the specified stateFieldNos.
     */
    public abstract boolean containFields(int[] stateFieldNos);

    /**
     * Check if the state contains the specified absFieldNos.
     */
    public abstract boolean containFieldsAbs(int[] absFieldNos);

    /**
     * Check if the state holds any values.
     */
    public abstract boolean isEmpty();

    /**
     * Return true if all the fields defined in the specified fetch group
     * are filled in.
     */
    public abstract boolean containsFetchGroup(FetchGroup fetchGroup);

    /**
     * Put the numbers of all fields we have into buf. The number of field
     * numbers stored is returned.
     */
    public abstract int getFieldNos(int[] buf);

    /**
     * Put the numbers of all pass 1 fields we have into buf. The number of
     * field numbers stored is returned.
     *
     * @see FieldMetaData#secondaryField
     * @see ClassMetaData#pass2Fields
     */
    public abstract int getPass1FieldNos(int[] buf);

    /**
     * Fill the array with the stateFieldNo of reference fields that contain
     * NewOid's.
     */
    public abstract int getPass1FieldRefFieldNosWithNewOids(
            int[] stateFieldNoBuf);

    /**
     * Put the numbers of all pass 2 fields we have into buf. The number of
     * field numbers stored is returned.
     *
     * @see FieldMetaData#secondaryField
     * @see ClassMetaData#pass2Fields
     */
    public abstract int getPass2FieldNos(int[] buf);

    /**
     * Do we contain any pass 1 fields?
     *
     * @see FieldMetaData#secondaryField
     * @see ClassMetaData#pass2Fields
     */
    public abstract boolean containsPass1Fields();

    /**
     * Do we contain any pass 2 fields?
     *
     * @see FieldMetaData#secondaryField
     * @see ClassMetaData#pass2Fields
     */
    public abstract boolean containsPass2Fields();

    /**
     * Return 0 if state has the same field numbers as us, less than 0 we are
     * less than it or greater than 0 if we are greater than it. The definition
     * of less than and greater than is up to the state implementation but
     * must be detirministic. For fields that are stored using Oracle style
     * LOBs then the nullness of the value must also be considered in the
     * comparison i.e. states with field x null and not null respectively
     * are different.
     *
     * @param state State to compare to (will be for same class)
     */
    public abstract int compareToPass1(State state);

    /**
     * Does this State contain exactly the same fields as the supplied State?
     *
     * @param state State to compare to (will be for same class)
     */
    public abstract boolean hasSameFields(State state);

    /**
     * Is the supplied stateFieldNo null?
     */
    public abstract boolean isNull(int stateFieldNo);

    /**
     * Does this State contain all of the application identity fields for
     * its class? This returns false if the class does not use application
     * identity.
     */
    public abstract boolean containsApplicationIdentityFields();

    /**
     * Does this State contain all of the application identity fields for
     * its class with values different to a default instance of the application
     * identity class? This returns false if the class does not use application
     * identity.
     */
    public abstract boolean containsValidAppIdFields();

    /**
     * Clear any application identity fields from this State. This is a NOP
     * if the class does not use application identity.
     */
    public abstract void clearApplicationIdentityFields();

    /**
     * Populate the primary key fields from the OID. This is only called
     * for PC classes that are using application identity.
     */
    public abstract void copyFields(OID oid);

    /**
     * Replace any NewObjectOID's in fields in fieldNos in this state with
     * their realOID's. Entries in fieldNos that are less than 0 should be
     * skipped. Note that skipped entries will never be for fields that could
     * hold OIDs.
     */
    public abstract boolean replaceNewObjectOIDs(int[] fieldNos,
            int fieldNosLength);

    /**
     * Add the graph indexes of all OIDs that we have direct references to
     * (e.g. foreign keys) to edges. This is called as part of the graph
     * sorting process.
     *
     * @see PersistGraph#sort
     */
    public abstract void findDirectEdges(OIDGraph graph,
            IntArray edges);

    /**
     * Update all autoset fields that must be set on commit of a new JDO
     * instance.
     *
     * @see FieldMetaData#autoSet
     */
    public abstract void updateAutoSetFieldsCreated(Date now);

    /**
     * Update all autoset fields that must be set on commit of modifications
     * to an existing JDO instance.
     *
     * @param oldState The pre-modification state of the instance.
     * @see FieldMetaData#autoSet
     */
    public abstract void updateAutoSetFieldsModified(Date now, State oldState);

    /**
     * Populate the OID from this state. This is called for classes
     * using application identity when a new object is persisted. It will
     * not be called otherwise.
     */
    public abstract void copyKeyFields(OID oid);

    /**
     * Check to see if the state contains the same id field as the oid. The oid
     * that is passed in is filled correctly.
     */
    public abstract boolean checkKeyFields(OID oid);

    /**
     * Populate the OID from this state. This is called for classes
     * using application identity when a primary key field of an existing
     * object is updated. It will not be called otherwise. Note that if the
     * primary key consists of multiple fields then those that have not
     * changed may not be in state.
     */
    public abstract void copyKeyFieldsUpdate(OID oid);

    /**
     * Return the value for the field.
     */
    public abstract boolean getBooleanField(int stateFieldNo);

    public abstract boolean getBooleanFieldAbs(int absFieldNo);

    /**
     * Return the value for the field.
     */
    public abstract char getCharField(int stateFieldNo);

    public abstract char getCharFieldAbs(int absFieldNo);

    /**
     * Return the value for the field.
     */
    public abstract byte getByteField(int stateFieldNo);

    public abstract byte getByteFieldAbs(int absFieldNo);

    /**
     * Return the value for the field.
     */
    public abstract short getShortField(int stateFieldNo);

    public abstract short getShortFieldAbs(int absFieldNo);

    /**
     * Return the value for the field.
     */
    public abstract int getIntField(int stateFieldNo);

    public abstract int getIntFieldAbs(int absFieldNo);

    /**
     * Return the value for the field.
     */
    public abstract long getLongField(int stateFieldNo);

    public abstract long getLongFieldAbs(int absFieldNo);

    /**
     * Return the value for the field or 0L if it is not filled.
     */
    public abstract long getLongFieldInternal(int stateFieldNo);

    /**
     * Return the value for the field.
     */
    public abstract float getFloatField(int stateFieldNo);

    public abstract float getFloatFieldAbs(int absFieldNo);

    /**
     * Return the value for the field.
     */
    public abstract double getDoubleField(int stateFieldNo);

    public abstract double getDoubleFieldAbs(int absFieldNo);

    /**
     * Return the value for the field.
     */
    public abstract String getStringField(int stateFieldNo);

    public abstract String getStringFieldAbs(int absFieldNo);

    /**
     * Return the value for the field.
     */
    public abstract Object getObjectField(int stateFieldNo,
            PersistenceCapable owningPC, VersantPMProxy pm,
            OID oid);

    public abstract Object getObjectFieldAbs(int absFieldNo,
            PersistenceCapable owningPC, VersantPMProxy pm,
            OID oid);

    /**
     * Set the value of the field.
     */
    public abstract void setBooleanField(int stateFieldNo, boolean newValue);

    public abstract void setBooleanFieldAbs(int absFieldNo, boolean newValue);

    /**
     * Set the value of the field.
     */
    public abstract void setCharField(int stateFieldNo, char newValue);

    public abstract void setCharFieldAbs(int absFieldNo, char newValue);

    /**
     * Set the value of the field.
     */
    public abstract void setByteField(int stateFieldNo, byte newValue);

    public abstract void setByteFieldAbs(int absFieldNo, byte newValue);

    /**
     * Set the value of the field.
     */
    public abstract void setShortField(int stateFieldNo, short newValue);

    public abstract void setShortFieldAbs(int absFieldNo, short newValue);

    /**
     * Set the value of the field.
     */
    public abstract void setIntField(int stateFieldNo, int newValue);

    public abstract void setIntFieldAbs(int absFieldNo, int newValue);

    /**
     * Set the value of the field.
     */
    public abstract void setLongField(int stateFieldNo, long newValue);

    public abstract void setLongFieldAbs(int absFieldNo, long newValue);

    /**
     * Set the value of the field.
     */
    public abstract void setFloatField(int stateFieldNo, float newValue);

    public abstract void setFloatFieldAbs(int absFieldNo, float newValue);

    /**
     * Set the value of the field.
     */
    public abstract void setDoubleField(int stateFieldNo, double newValue);

    public abstract void setDoubleFieldAbs(int absFieldNo, double newValue);

    /**
     * Set the value of the field.
     */
    public abstract void setStringField(int stateFieldNo, String newValue);

    public abstract void setStringFieldAbs(int absFieldNo, String newValue);

    /**
     * Set the value of the field.
     */
    public abstract void setObjectField(int stateFieldNo, Object newValue);

    public abstract void setObjectFieldAbs(int absFieldNo, Object newValue);

    public abstract void setObjectFieldUnresolved(int field, Object newValue);

    public abstract void setObjectFieldUnresolvedAbs(int field,
            Object newValue);

//==============================internal usage==================================

    /**
     * Return the internal value for the field.
     */
    public abstract Object getInternalObjectField(int field);

    public abstract Object getInternalObjectFieldAbs(int field);

    /**
     * Set the value of the field internally.
     */
    public abstract void setInternalBooleanField(int field, boolean newValue);

    public abstract void setInternalBooleanFieldAbs(int field,
            boolean newValue);

    /**
     * Set the value of the field internally.
     */
    public abstract void setInternalCharField(int field, char newValue);

    public abstract void setInternalCharFieldAbs(int field, char newValue);

    /**
     * Set the value of the field internally.
     */
    public abstract void setInternalByteField(int field, byte newValue);

    public abstract void setInternalByteFieldAbs(int field, byte newValue);

    /**
     * Set the value of the field internally.
     */
    public abstract void setInternalShortField(int field, short newValue);

    public abstract void setInternalShortFieldAbs(int field, short newValue);

    /**
     * Set the value of the field internally.
     */
    public abstract void setInternalIntField(int field, int newValue);

    public abstract void setInternalIntFieldAbs(int field, int newValue);

    /**
     * Set the value of the field internally.
     */
    public abstract void setInternalLongField(int field, long newValue);

    public abstract void setInternalLongFieldAbs(int field, long newValue);

    /**
     * Set the value of the field internally.
     */
    public abstract void setInternalFloatField(int field, float newValue);

    public abstract void setInternalFloatFieldAbs(int field, float newValue);

    /**
     * Set the value of the field internally.
     */
    public abstract void setInternalDoubleField(int field, double newValue);

    public abstract void setInternalDoubleFieldAbs(int field, double newValue);

    /**
     * Set the value of the field internally.
     */
    public abstract void setInternalStringField(int field, String newValue);

    public abstract void setInternalStringFieldAbs(int field, String newValue);

    /**
     * Set the value of the field internally.
     */
    public abstract void setInternalObjectField(int field, Object newValue);

    public abstract void setInternalObjectFieldAbs(int field, Object newValue);

//    public void readExternal(ObjectInput in, JDOMetaData jmd,
//            IntObjectHashMap map) throws IOException, ClassNotFoundException {
//    }

    public abstract String getVersion();

    /**
     * Add all states referenced by fields in fg to the dcs.
     */
    public void addFetchGroupStatesToDCS(FetchGroup fg, DetachStateContainer dcs,
            VersantPersistenceManagerImp pm, OID oid, ClassMetaData cmd) {
        // we need to check all fields that may reference other states and
        // add those states to the dcs with the "nextFetchGroups" so they
        // are checked in turn
        FetchGroupField[] fields = fg.fields;
        boolean defaultFG = fg == cmd.fetchGroups[0];
        int length = fields.length;
        for (int fieldNo = 0; fieldNo < length; fieldNo++) {
            FetchGroupField field = fields[fieldNo];
            FieldMetaData fmd = field.fmd;
            if (fmd.fake) continue;
            if (defaultFG && !fmd.isJDODefaultFetchGroup()) continue;
            FetchGroup nextFetchGroup = field.nextFetchGroup;
            FetchGroup nextKeyFetchGroup = field.nextKeyFetchGroup;
            if (nextFetchGroup == null && nextKeyFetchGroup == null) continue;
            int category = fmd.category;
            int stateFieldNo;
            Object o;
            switch (category) {
                case MDStatics.CATEGORY_COLLECTION:
                    o = getInternalObjectField(stateFieldNo = fmd.stateFieldNo);
                    if (o != null) {
                        if (isResolvedForClient(stateFieldNo)) {
                            // TODO add method to SCOs to get data w/o iterator
                            for (Iterator i = ((Collection)o).iterator();
                                 i.hasNext();) {
                                addPCToDCS(dcs, (PersistenceCapable)i.next(),
                                        nextFetchGroup, pm);
                            }
                        } else {
                            Object[] a = (Object[])o;
                            int c = a.length;
                            for (int i = 0; i < c; i++) {
                                Object object = a[i];
                                if (object == null) break;
                                addOIDToDCS(dcs, (OID)object, nextFetchGroup,
                                        pm);
                            }
                        }
                    }
                    break;
                case MDStatics.CATEGORY_ARRAY:
                    if (fmd.elementTypeMetaData != null) {
                        o = getInternalObjectField(
                                stateFieldNo = fmd.stateFieldNo);
                        if (o != null) {
                            if (isResolvedForClient(stateFieldNo)) {
                                Object[] a = (Object[])o;
                                int c = a.length;
                                for (int i = 0; i < c; i++) {
                                    Object object = a[i];
                                    if (object != null) {
                                        addPCToDCS(dcs, (PersistenceCapable)object,
                                                nextFetchGroup, pm);
                                    }
                                }
                            } else {
                                Object[] a = (Object[])o;
                                int c = a.length;
                                for (int i = 0; i < c; i++) {
                                    Object object = a[i];
                                    if (object != null) {
                                        addOIDToDCS(dcs, (OID)object, nextFetchGroup,
                                                pm);
                                    }
                                }
                            }
                        }
                    }
                    break;
                case MDStatics.CATEGORY_MAP:
                    o = getInternalObjectField(stateFieldNo = fmd.stateFieldNo);
                    if (o != null) {
                        if (isResolvedForClient(stateFieldNo)) {
                            // TODO add method to SCOs to get data w/o iterator
                            for (Iterator i = ((Map)o).entrySet().iterator();
                                 i.hasNext();) {
                                Map.Entry e = (Map.Entry)i.next();
                                if (nextKeyFetchGroup != null) {
                                    addPCToDCS(dcs, (PersistenceCapable)e.getKey(),
                                            nextKeyFetchGroup, pm);
                                }
                                if (nextFetchGroup != null) {
                                    addPCToDCS(dcs, (PersistenceCapable)e.getValue(),
                                            nextFetchGroup, pm);
                                }
                            }
                        } else {
                            MapEntries e = (MapEntries)o;
                            if (nextKeyFetchGroup != null) {
                                Object[] a = e.keys;
                                int c = a.length;
                                for (int i = 0; i < c; i++) {
                                    OID nextOid = (OID)a[i];
                                    if (nextOid == null) break;
                                    addOIDToDCS(dcs, nextOid,
                                            nextKeyFetchGroup, pm);
                                }
                            }
                            if (nextFetchGroup != null) {
                                Object[] a = e.values;
                                int c = a.length;
                                for (int i = 0; i < c; i++) {
                                    OID nextOid = (OID)a[i];
                                    if (nextOid == null) break;
                                    addOIDToDCS(dcs, nextOid, nextFetchGroup,
                                            pm);
                                }
                            }
                        }
                    }
                    break;
                case MDStatics.CATEGORY_REF:
                case MDStatics.CATEGORY_POLYREF:
                    o = getInternalObjectField(stateFieldNo = fmd.stateFieldNo);
                    if (o != null) {
                        if (isResolvedForClient(stateFieldNo)) {
                            addPCToDCS(dcs, (PersistenceCapable)o,
                                    nextFetchGroup, pm);
                        } else {
                            OID nextOid = (OID)o;
                            if (nextOid != null) {
                                addOIDToDCS(dcs, nextOid, nextFetchGroup, pm);
                            }
                        }
                    }
                    break;
            }
        }
    }

    /**
     * Get the state for the oid from the local cache (if any). Add the oid
     * and state to the dcs. This does not check if it is already present.
     */
    private void addOIDToDCS(DetachStateContainer dcs, OID oid,
            FetchGroup nextFetchGroup, VersantPersistenceManagerImp pm) {
        State ns = pm.getCache().getStateByOID(oid);
        dcs.add(oid, ns, nextFetchGroup);
        // it is ok if ns is null as it will be fetched later
    }

    /**
     * Add the state for the pc and its oid to dcs. This is a NOP if the oid
     * is already present.
     */
    private void addPCToDCS(DetachStateContainer dcs, PersistenceCapable pc,
            FetchGroup nextFetchGroup, VersantPersistenceManagerImp pm) {
        PCStateMan internalSM = pm.getInternalSM(pc);
        dcs.add(internalSM.oid, internalSM.state, nextFetchGroup);
        // dcs.add will do nothing if the oid is already present
    }

    public Object resolveArrayOIDs(Object[] oids,
            PersistenceContext sm, Class type) {
        Object[] vals = (Object[])java.lang.reflect.Array.newInstance(type, oids.length);
        for (int i = 0; i < vals.length; i++) {
            if (oids[i] != null) {
                vals[i] = sm.getObjectById(oids[i], false);
            }
        }
        return vals;
    }

    public Object resolveArrayValues(Object vals[],
            PersistenceContext pm) {
        OID oids[] = new OID[vals.length];
        for (int i = 0; i < oids.length; i++) {
            if (vals[i] != null) {
                oids[i] = pm.getInternalOID((PersistenceCapable)vals[i]);
            }
        }

        return oids;
    }

    /**
     * Is this state field nummber resolved for the Client
     */
    public abstract boolean isResolvedForClient(int stateFieldNo);

    /**
     * The value of the version field on the pc.
     * This will return null if there are no version fields.
     */
    public abstract Object getOptimisticLockingValue();

    /**
     * Mark field as filled.
     */
    public abstract void setFilled(int stateFieldNo);

    /**
     * Add the values of any non-null reference fields used as back or inverse
     * fields for unmanaged one-to-many collections for eviction from the L2
     * cache on commit. Note that the filled status of the field is not
     * checked. This method is called only for newly managed instances so
     * all fields will be filled.
     */
    public abstract void addOneToManyInverseFieldsForL2Evict(
            VersantPersistenceManagerImp pm);



    /**
     * If the data of this state may be used to update the cache.
     */
    public boolean isCacheble() {
        return true;
    }
    
    /**
     * Find the graph indexes of all the OIDs directly referenced by fieldNo
     * and add them to edges. Any referenced OIDs that are not in the graph
     * should be ignored.
     */
    protected void findDirectEdges(OIDGraph graph, ClassMetaData cmd,
            int fieldNo, State state, IntArray edges) {
        OID oid = (OID)state.getInternalObjectField(fieldNo);
        if (oid == null) return;
        int index = graph.indexOf(oid);
        if (index >= 0) edges.add(index);
    }

    /**
     * Is the field null or zero?
     */
    public abstract boolean isFieldNullorZero(int stateFieldNo);

    /**
     * Our version of writeExternal for serialization.
     */
    public abstract void writeExternal(OIDObjectOutput os) throws IOException;

    /**
     * Our version of readExternal for serialization.
     */
    public abstract void readExternal(OIDObjectInput is)
            throws IOException, ClassNotFoundException;

}
