
/*
 * Copyright (c) 1998 - 2005 Versant Corporation
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 * Versant Corporation - initial API and implementation
 */
package com.versant.core.jdbc.conn;

import com.versant.core.logging.LogEventStore;
import com.versant.core.jdbc.logging.JdbcConnectionEvent;
import com.versant.core.jdbc.logging.JdbcPsPoolEvent;
import com.versant.core.common.Debug;

import javax.jdo.datastore.JDOConnection;
import java.sql.*;

/**
 * A JDBC connection wrapped for event logging with a PreparedStatement cache.
 * These concerns should really be separated but we have not had time to do
 * that yet.
 */
public class LoggingConnection implements Connection {

    private final Connection con;
    private final LogEventStore pes;
    private final PreparedStatementPool psPool;
    private final boolean clearBatch;
    private boolean needsValidation; // set for Exception's on us

    public LoggingConnection(Connection con, LogEventStore pes, boolean usePsPool,
            int psCacheMax, boolean clearBatch) {
        this.clearBatch = clearBatch;
        this.con = con;
        this.pes = pes;
        if (usePsPool) {
            psPool = new PreparedStatementPool(this, psCacheMax);
        } else {
            psPool = null;
        }
    }

    public PreparedStatementPool getPsPool() {
        return psPool;
    }

    public void setNeedsValidation(boolean needsValidation) {
        this.needsValidation = needsValidation;
    }

    public boolean isNeedsValidation() {
        return needsValidation;
    }

    public java.sql.Connection getCon() {
        return con;
    }

    /**
     * Return ps to the pool.
     *
     * @see PooledPreparedStatement#close
     */
    public void returnPreparedStatement(PooledPreparedStatement ps)
            throws SQLException {
        try {
            if (clearBatch) ps.clearBatch();
            psPool.returnPS(ps);
            if (pes.isFiner()) {
                logPsPoolEvent(ps.getKey(), JdbcConnectionEvent.PSPOOL_RELEASE, ps);
            }
        } catch (Exception e) {
            throw convertException(e);
        }
    }

    /**
     * This is just going to return the connection to the pool.
     */
    public void close() throws SQLException {
        closeRealConnection();
    }

    public void setHoldability(int holdability) throws SQLException {
        con.setHoldability(holdability);
    }

    public int getHoldability() throws SQLException {
        return con.getHoldability();
    }

    public Savepoint setSavepoint() throws SQLException {
        return con.setSavepoint();
    }

    public Savepoint setSavepoint(String name) throws SQLException {
        return con.setSavepoint(name);
    }

    public void rollback(Savepoint savepoint) throws SQLException {
        con.rollback(savepoint);
    }

    public void releaseSavepoint(Savepoint savepoint) throws SQLException {
        con.releaseSavepoint(savepoint);
    }

    public Statement createStatement(int resultSetType, int resultSetConcurrency,
                                     int resultSetHoldability) throws SQLException {
        return con.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability);
    }

    public PreparedStatement prepareStatement(String sql, int resultSetType,
                                              int resultSetConcurrency, int resultSetHoldability)
            throws SQLException {
        return con.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
    }

    public CallableStatement prepareCall(String sql, int resultSetType,
                                         int resultSetConcurrency,
                                         int resultSetHoldability) throws SQLException {
        return con.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
    }

    public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys)
            throws SQLException {
        return con.prepareStatement(sql, autoGeneratedKeys);
    }

    public PreparedStatement prepareStatement(String sql, int columnIndexes[])
            throws SQLException {
        return con.prepareStatement(sql, columnIndexes);
    }

    public PreparedStatement prepareStatement(String sql, String columnNames[])
            throws SQLException {
        return con.prepareStatement(sql, columnNames);
    }

    public String nativeSQL(String sql) throws SQLException {
        return con.nativeSQL(sql);
    }

    public boolean getAutoCommit() throws SQLException {
        return con.getAutoCommit();
    }

    public boolean isClosed() throws SQLException {
        return con.isClosed();
    }

    public DatabaseMetaData getMetaData() throws SQLException {
        return con.getMetaData();
    }

    public void setReadOnly(boolean readOnly) throws SQLException {
        con.setReadOnly(readOnly);
    }

    public boolean isReadOnly() throws SQLException {
        return con.isReadOnly();
    }

    public void setCatalog(String catalog) throws SQLException {
        con.setCatalog(catalog);
    }

    public String getCatalog() throws SQLException {
        return con.getCatalog();
    }

    public void setTransactionIsolation(int level) throws SQLException {
        JdbcConnectionEvent ev = null;
        if (pes.isFiner()) {
            ev = new JdbcConnectionEvent(0, this,
                    toIsolationStr(level),
                    JdbcConnectionEvent.CON_ISOLATION);
            pes.log(ev);
        }
        try {
            con.setTransactionIsolation(level);
        } catch (SQLException e) {
            needsValidation = true;
            if (ev != null) ev.setErrorMsg(e);
            throw e;
        } catch (RuntimeException e) {
            needsValidation = true;
            if (ev != null) ev.setErrorMsg(e);
            throw e;
        } finally {
            if (ev != null) ev.updateTotalMs();
        }
    }

    private static String toIsolationStr(int lvl) {
        switch (lvl) {
            case TRANSACTION_NONE:
                return "NONE(0)";
            case TRANSACTION_READ_UNCOMMITTED:
                return "READ_UNCOMMITTED(1)";
            case TRANSACTION_READ_COMMITTED:
                return "READ_COMMITTED(2)";
            case TRANSACTION_REPEATABLE_READ:
                return "REPEATABLE_READ(4)";
            case TRANSACTION_SERIALIZABLE:
                return "SERIALIZABLE(8)";
        }
        return "UNKNOWN(" + lvl + ")";
    }

    public int getTransactionIsolation() throws SQLException {
        return con.getTransactionIsolation();
    }


    public SQLWarning getWarnings() throws SQLException {
        return con.getWarnings();
    }

    public void clearWarnings() throws SQLException {
        con.clearWarnings();
    }

    public Statement createStatement(int resultSetType, int resultSetConcurrency)
            throws SQLException {
        return con.createStatement(resultSetType, resultSetConcurrency);
    }

    public CallableStatement prepareCall(String sql, int resultSetType,
                                         int resultSetConcurrency) throws SQLException {
        return con.prepareCall(sql, resultSetType, resultSetConcurrency);
    }

    public java.util.Map getTypeMap() throws SQLException {
        return con.getTypeMap();
    }

    public void setTypeMap(java.util.Map map) throws SQLException {
        con.setTypeMap(map);
    }

    public Statement createStatement() throws SQLException {
        if (!pes.isFine()) return con.createStatement();
        JdbcConnectionEvent ev = null;
        if (pes.isFiner()) {
            ev = new JdbcConnectionEvent(0, this,
                    null, JdbcConnectionEvent.CON_CREATE_STATEMENT);
            pes.log(ev);
        }
        try {
            Statement stat = new LoggingStatement(this, con.createStatement(), pes);
            if (ev != null) ev.updateStatementID(stat);
            return stat;
        } catch (SQLException e) {
            needsValidation = true;
            if (ev != null) ev.setErrorMsg(e);
            throw e;
        } catch (RuntimeException e) {
            needsValidation = true;
            if (ev != null) ev.setErrorMsg(e);
            throw e;
        } finally {
            if (ev != null) ev.updateTotalMs();
        }
    }

    public PreparedStatement prepareStatement(String sql)
            throws SQLException {
        if (psPool == null) {
            return prepareStatementImp(sql, 0, 0, null);
        } else {
            try {
                PreparedStatementPool.Key key = new PreparedStatementPool.Key(sql);
                PooledPreparedStatement ps = psPool.borrowPS(key);
                if (pes.isFiner()) {
                    logPsPoolEvent(key, JdbcConnectionEvent.PSPOOL_ALLOC, ps);
                }
                return ps;
            } catch (Exception e) {
                throw convertException(e);
            }
        }
    }

    private void logPsPoolEvent(PreparedStatementPool.Key key, int type, PreparedStatement ps) {
        JdbcPsPoolEvent ev = new JdbcPsPoolEvent(0, this,
                key.getSql(), type, psPool.getNumActive(), psPool.getNumIdle());
        ev.zeroTotalMs();
        ev.setResultSetType(key.getResultSetType());
        ev.setResultSetConcurrency(key.getResultSetConcurrency());
        ev.setStatementID(System.identityHashCode(ps));
        pes.log(ev);
    }

    private SQLException convertException(Exception x) {
        if (x instanceof SQLException) return (SQLException) x;
        if (Debug.DEBUG) x.printStackTrace(System.out);
        return new SQLException(x.getClass().getName() + ": " + x.getMessage());
    }

    public PreparedStatement prepareStatement(String sql, int resultSetType,
            int resultSetConcurrency) throws SQLException {
        if (psPool == null) {
            return prepareStatementImp(sql, resultSetType, resultSetConcurrency, null);
        } else {
            try {
                PreparedStatementPool.Key key = new PreparedStatementPool.Key(sql, resultSetType, resultSetConcurrency);
                PooledPreparedStatement ps = psPool.borrowPS(key);
                if (pes.isFiner()) {
                    logPsPoolEvent(key, JdbcConnectionEvent.PSPOOL_ALLOC, ps);
                }
                return ps;
            } catch (Exception e) {
                throw convertException(e);
            }
        }
    }

    /**
     * Create a new ps. This will not use the PS pool.
     */
    public PooledPreparedStatement prepareStatementImp(String sql, int resultSetType,
            int resultSetConcurrency, PreparedStatementPool.Key key) throws SQLException {
        JdbcConnectionEvent ev = null;
        if (pes.isFiner()) {
            ev = new JdbcConnectionEvent(0, this,
                    sql, JdbcConnectionEvent.CON_PREPARE_STATEMENT);
            ev.setResultSetType(resultSetType);
            ev.setResultSetConcurrency(resultSetConcurrency);
            pes.log(ev);
        }
        try {
            PreparedStatement stat;
            if (resultSetType != 0) {
                stat = con.prepareStatement(sql, resultSetType, resultSetConcurrency);
            } else {
                stat = con.prepareStatement(sql);
            }
            PooledPreparedStatement ps;
            if (pes.isFiner()) {
                ps = new PooledPSWithParamLogging(this, stat, pes, sql, key);
            } else {
                ps = new PooledPreparedStatement(this, stat, pes, sql, key);
            }
            if (ev != null) ev.updateStatementID(ps);
            return ps;
        } catch (SQLException e) {
            needsValidation = true;
            if (ev != null) ev.setErrorMsg(e);
            throw e;
        } catch (RuntimeException e) {
            needsValidation = true;
            if (ev != null) ev.setErrorMsg(e);
            throw e;
        } finally {
            if (ev != null) ev.updateTotalMs();
        }
    }

    public CallableStatement prepareCall(String sql) throws SQLException {
        if (!pes.isFine()) return con.prepareCall(sql);
        JdbcConnectionEvent ev = null;
        if (pes.isFiner()) {
            ev = new JdbcConnectionEvent(0, this,
                    sql, JdbcConnectionEvent.CON_PREPARE_CALL);
            pes.log(ev);
        }
        try {
            CallableStatement stat =
                    new LoggingCallableStatement(this, con.prepareCall(sql), pes);
            if (ev != null) ev.updateStatementID(stat);
            return stat;
        } catch (SQLException e) {
            needsValidation = true;
            if (ev != null) ev.setErrorMsg(e);
            throw e;
        } catch (RuntimeException e) {
            needsValidation = true;
            if (ev != null) ev.setErrorMsg(e);
            throw e;
        } finally {
            if (ev != null) ev.updateTotalMs();
        }
    }

    public void setAutoCommit(boolean autoCommit) throws SQLException {
        JdbcConnectionEvent ev = null;
        if (pes.isFiner()) {
            ev = new JdbcConnectionEvent(0, this,
                    autoCommit ? "true" : "false",
                    JdbcConnectionEvent.CON_AUTOCOMMIT);
            pes.log(ev);
        }
        try {
            con.setAutoCommit(autoCommit);
        } catch (SQLException e) {
            needsValidation = true;
            if (ev != null) ev.setErrorMsg(e);
            throw e;
        } catch (RuntimeException e) {
            needsValidation = true;
            if (ev != null) ev.setErrorMsg(e);
            throw e;
        } finally {
            if (ev != null) ev.updateTotalMs();
        }
    }

    public void commit() throws SQLException {
        JdbcConnectionEvent ev = null;
        if (pes.isFine()) {
            ev = new JdbcConnectionEvent(0, this, null,
                    JdbcConnectionEvent.CON_COMMIT);
            pes.log(ev);
        }
        try {
            con.commit();
        } catch (SQLException e) {
            needsValidation = true;
            if (ev != null) ev.setErrorMsg(e);
            throw e;
        } catch (RuntimeException e) {
            needsValidation = true;
            if (ev != null) ev.setErrorMsg(e);
            throw e;
        } finally {
            if (ev != null) ev.updateTotalMs();
        }
    }

    public void rollback() throws SQLException {
        JdbcConnectionEvent ev = null;
        if (pes.isFine()) {
            ev = new JdbcConnectionEvent(0, this, null,
                    JdbcConnectionEvent.CON_ROLLBACK);
            pes.log(ev);
        }
        try {
            con.rollback();
        } catch (SQLException e) {
            needsValidation = true;
            if (ev != null) ev.setErrorMsg(e);
            throw e;
        } catch (RuntimeException e) {
            needsValidation = true;
            if (ev != null) ev.setErrorMsg(e);
            throw e;
        } finally {
            if (ev != null) ev.updateTotalMs();
        }
    }

    /**
     * Realy close this connection i.e. do not return it to the pool.
     */
    public void closeRealConnection() throws SQLException {
        if (!pes.isFine()) {
            con.close();
            return;
        }
        JdbcConnectionEvent ev = new JdbcConnectionEvent(0, this, null,
                JdbcConnectionEvent.CON_CLOSE);
        pes.log(ev);
        try {
            con.close();
        } catch (SQLException e) {
            ev.setErrorMsg(e);
            throw e;
        } catch (RuntimeException e) {
            ev.setErrorMsg(e);
            throw e;
        } finally {
            ev.updateTotalMs();
        }
    }

}

