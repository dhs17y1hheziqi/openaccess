
/*
 * Copyright (c) 1998 - 2005 Versant Corporation
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 * Versant Corporation - initial API and implementation
 */
/* The following code was generated by JFlex 1.3.5 on 04/02/24 05:29 */

package com.versant.core.jdo.tools.workbench.jdoql.ordering;

import java.io.*;

import com.versant.core.jdo.tools.workbench.model.MdClass;
import com.versant.core.jdo.tools.workbench.model.MdField;
import com.versant.core.jdo.tools.workbench.jdoql.insight.*;
import com.versant.core.jdo.tools.workbench.jdoql.lexer.Lexer;
import com.versant.core.jdo.tools.workbench.jdoql.lexer.Token;
import com.versant.core.metadata.MDStatics;
import za.co.hemtech.gui.model.ObservableList;

import java.util.*;

/**
 * @keep-all OrderingLexer is a java lexer.  Created with JFlex.
 * The tokens returned should comply with the JDOQL Language Specification
 * @see OrderingToken
 *      <p/>
 *      /**
 *      This class is a scanner generated by
 *      <a href="http://www.jflex.de/">JFlex</a> 1.3.5
 *      on 04/02/24 05:29 from the specification file
 *      <tt>file:/home/carl/work/hemtech/jdo2/lib/../src/za/co/hemtech/jdo/tools/workbench/jdoql/ordering/OrderingLexer.flex</tt>
 */
public class OrderingLexer implements Lexer {

    /**
     * This character denotes the end of file
     */
    final public static int YYEOF = -1;

    /**
     * initial size of the lookahead buffer
     */
    final private static int YY_BUFFERSIZE = 16384;

    /**
     * lexical states
     */
    final public static int YYINITIAL = 0;

    /**
     * Translates characters to character classes
     */
    final private static char[] yycmap = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 9, 0, 7, 9, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        7, 10, 18, 0, 6, 44, 44, 17, 38, 39, 20, 21, 31, 22, 30, 19,
        4, 5, 5, 5, 3, 3, 3, 3, 2, 2, 41, 38, 43, 40, 42, 41,
        0, 1, 1, 1, 29, 26, 27, 6, 6, 6, 6, 6, 23, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 24, 6, 6, 10, 8, 10, 46, 6,
        0, 32, 14, 34, 28, 25, 15, 36, 37, 35, 6, 6, 23, 6, 13, 6,
        6, 6, 12, 33, 16, 11, 6, 6, 24, 6, 6, 38, 45, 39, 10, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    };

    /**
     * Translates a state to a row index in the transition table
     */
    final private static int yy_rowMap [] = {
        0, 47, 94, 141, 188, 235, 282, 329, 376, 423,
        470, 517, 564, 611, 658, 705, 752, 799, 752, 752,
        752, 846, 893, 517, 517, 940, 940, 940, 987, 940,
        1034, 1081, 1128, 1175, 940, 1222, 1269, 940, 1316, 1363,
        1410, 1457, 1504, 752, 1551, 752, 1598, 1645, 752, 1692,
        1739, 1786, 1833, 1880, 1927, 1974, 2021, 940, 2068, 2115,
        2162, 2209, 2256, 2303, 2350, 752, 2397, 2444, 2491, 2538,
        2585, 2632, 2679, 2726, 752, 2773, 752, 752, 2820, 752,
        2867, 752, 2914, 2961, 940, 3008, 3055, 94, 3102, 752,
        3149, 3196, 752, 3243, 3290, 752, 3337, 3384, 3431, 3478,
        3525, 3572, 3619, 3666, 3713, 3760, 3807, 3854, 3901, 3948,
        3995, 4042, 4089, 4136, 94, 94
    };

    /**
     * The packed transition table of the DFA (part 0)
     */
    final private static String yy_packed0 =
            "\1\2\1\3\2\4\1\5\1\4\1\3\1\6\1\7" +
            "\1\6\1\0\5\3\1\10\1\11\1\12\1\13\1\14" +
            "\1\15\1\16\5\3\1\17\1\3\1\20\1\21\1\22" +
            "\5\3\1\23\1\24\2\25\1\26\1\27\1\14\1\30" +
            "\1\31\7\2\1\0\1\2\2\0\6\2\6\0\7\2" +
            "\2\0\6\2\11\0\1\2\6\3\1\0\1\7\2\0" +
            "\6\3\6\0\7\3\2\0\6\3\11\0\2\32\4\4" +
            "\1\32\1\0\1\32\2\0\4\32\1\33\1\32\6\0" +
            "\1\34\1\32\2\35\1\33\2\36\1\37\1\0\6\32" +
            "\11\0\2\32\1\40\1\41\1\42\1\41\1\32\1\0" +
            "\1\32\2\0\4\32\1\43\1\32\6\0\1\34\1\44" +
            "\2\45\1\43\2\46\1\47\1\0\6\32\20\0\1\6" +
            "\1\0\1\6\45\0\7\2\1\0\1\2\2\0\1\50" +
            "\5\2\6\0\7\2\2\0\6\2\11\0\1\2\6\3" +
            "\1\0\1\7\2\0\6\3\6\0\7\3\2\0\5\3" +
            "\1\51\11\0\10\52\1\53\1\0\7\52\1\54\35\52" +
            "\10\12\1\55\1\0\10\12\1\56\34\12\23\0\1\57" +
            "\1\60\23\0\1\61\56\0\1\61\33\0\1\61\22\0" +
            "\1\61\34\0\1\61\21\0\1\61\6\0\1\2\6\3" +
            "\1\0\1\7\2\0\6\3\6\0\2\3\1\62\4\3" +
            "\2\0\6\3\13\0\2\63\1\64\1\63\130\0\1\2" +
            "\6\3\1\0\1\7\2\0\6\3\6\0\7\3\2\0" +
            "\1\3\1\65\4\3\63\0\1\66\57\0\1\67\3\0" +
            "\7\32\1\0\1\32\2\0\6\32\6\0\10\32\1\0" +
            "\6\32\11\0\2\32\4\70\1\32\1\0\1\32\2\0" +
            "\6\32\4\0\2\71\10\32\1\0\6\32\11\0\2\32" +
            "\4\37\1\32\1\0\1\32\2\0\4\32\1\33\1\32" +
            "\6\0\2\32\2\35\1\33\2\36\1\32\1\0\6\32" +
            "\11\0\2\32\4\40\1\32\1\0\1\32\2\0\4\32" +
            "\1\33\1\32\6\0\2\32\2\35\1\33\2\36\1\37" +
            "\1\0\6\32\11\0\2\32\1\40\3\41\1\32\1\0" +
            "\1\32\2\0\4\32\1\33\1\32\6\0\1\72\1\32" +
            "\2\35\1\33\2\36\1\37\1\0\6\32\11\0\2\32" +
            "\1\40\1\41\1\42\1\41\1\32\1\0\1\32\2\0" +
            "\4\32\1\43\1\32\6\0\1\72\1\32\2\45\1\43" +
            "\2\46\1\47\1\0\6\32\11\0\1\32\5\73\1\32" +
            "\1\0\1\32\2\0\3\32\2\73\1\32\6\0\2\32" +
            "\5\73\1\32\1\0\1\73\1\32\1\73\3\32\11\0" +
            "\2\32\4\74\1\32\1\0\1\32\2\0\6\32\4\0" +
            "\2\75\10\32\1\0\6\32\11\0\2\32\2\37\1\47" +
            "\1\37\1\32\1\0\1\32\2\0\4\32\1\43\1\32" +
            "\6\0\2\32\2\45\1\43\2\46\1\32\1\0\6\32" +
            "\11\0\1\2\5\76\1\2\1\0\1\2\2\0\3\2" +
            "\2\76\1\2\6\0\2\2\5\76\2\0\1\76\1\2" +
            "\1\76\3\2\11\0\1\2\6\3\1\0\1\7\2\0" +
            "\6\3\6\0\7\3\2\0\3\3\1\77\2\3\11\0" +
            "\10\100\1\101\1\0\7\100\1\102\40\100\1\103\2\104" +
            "\2\100\1\52\1\0\1\100\1\105\7\52\34\100\3\106" +
            "\3\12\2\106\1\12\1\0\1\106\1\107\6\12\1\110" +
            "\34\106\11\57\1\0\45\57\24\60\1\111\32\60\1\2" +
            "\6\3\1\0\1\7\2\0\6\3\6\0\7\3\2\0" +
            "\1\3\1\112\4\3\13\0\4\63\11\0\1\113\11\0" +
            "\2\114\1\113\2\115\23\0\2\63\1\64\1\63\11\0" +
            "\1\116\11\0\2\117\1\116\2\120\21\0\1\2\6\3" +
            "\1\0\1\7\2\0\6\3\6\0\7\3\2\0\2\3" +
            "\1\121\3\3\61\0\1\122\1\0\1\123\54\0\1\122" +
            "\6\0\2\32\4\70\1\32\1\0\1\32\2\0\4\32" +
            "\1\33\1\32\6\0\4\32\1\33\2\36\1\32\1\0" +
            "\6\32\13\0\4\124\51\0\1\32\5\73\1\32\1\0" +
            "\1\32\2\0\3\32\2\73\1\32\6\0\1\125\1\32" +
            "\5\73\1\32\1\0\1\73\1\32\1\73\3\32\11\0" +
            "\2\32\4\74\1\32\1\0\1\32\2\0\4\32\1\43" +
            "\1\32\6\0\4\32\1\43\2\46\1\32\1\0\6\32" +
            "\13\0\4\126\51\0\1\2\5\127\1\2\1\0\1\2" +
            "\2\0\3\2\2\127\1\2\6\0\2\2\5\127\2\0" +
            "\1\127\1\2\1\127\3\2\11\0\1\2\6\3\1\0" +
            "\1\7\2\0\6\3\6\0\7\3\2\0\1\3\1\130" +
            "\4\3\11\0\10\100\1\101\1\0\7\100\1\54\46\100" +
            "\1\0\50\100\3\52\2\100\1\101\1\0\7\100\1\102" +
            "\40\100\3\103\2\100\1\101\1\0\7\100\1\102\36\100" +
            "\5\131\2\100\1\101\1\0\4\100\2\131\1\100\1\54" +
            "\7\100\5\131\2\100\1\131\1\100\1\131\14\100\11\106" +
            "\1\0\10\106\1\132\35\106\5\133\3\106\1\0\4\106" +
            "\2\133\2\106\1\132\6\106\5\133\2\106\1\133\1\106" +
            "\1\133\14\106\10\110\1\134\1\0\10\110\1\56\34\110" +
            "\23\60\1\135\1\111\32\60\1\2\6\3\1\0\1\7" +
            "\2\0\6\3\6\0\7\3\2\0\2\3\1\136\3\3" +
            "\13\0\4\124\17\0\2\71\32\0\4\126\17\0\2\75" +
            "\30\0\1\2\6\3\1\0\1\7\2\0\6\3\6\0" +
            "\2\3\1\137\4\3\2\0\6\3\61\0\1\140\10\0" +
            "\4\124\11\0\1\113\13\0\1\113\2\115\23\0\4\126" +
            "\11\0\1\116\13\0\1\116\2\120\21\0\1\2\5\141" +
            "\1\2\1\0\1\2\2\0\3\2\2\141\1\2\6\0" +
            "\2\2\5\141\2\0\1\141\1\2\1\141\3\2\11\0" +
            "\1\100\5\142\2\100\1\101\1\0\4\100\2\142\1\100" +
            "\1\54\7\100\5\142\2\100\1\142\1\100\1\142\14\100" +
            "\1\106\5\143\3\106\1\0\4\106\2\143\2\106\1\132" +
            "\6\106\5\143\2\106\1\143\1\106\1\143\14\106\3\0" +
            "\3\110\2\0\1\110\2\0\1\144\7\110\34\0\1\2" +
            "\6\3\1\0\1\7\2\0\6\3\6\0\2\3\1\145" +
            "\4\3\2\0\6\3\11\0\1\2\6\3\1\0\1\7" +
            "\2\0\2\3\1\146\3\3\6\0\7\3\2\0\6\3" +
            "\11\0\1\2\5\3\1\2\1\0\1\2\2\0\3\2" +
            "\2\3\1\2\6\0\2\2\5\3\2\0\1\3\1\2" +
            "\1\3\3\2\11\0\1\100\5\147\2\100\1\101\1\0" +
            "\4\100\2\147\1\100\1\54\7\100\5\147\2\100\1\147" +
            "\1\100\1\147\14\100\1\106\5\150\3\106\1\0\4\106" +
            "\2\150\2\106\1\132\6\106\5\150\2\106\1\150\1\106" +
            "\1\150\14\106\1\0\5\151\10\0\2\151\11\0\5\151" +
            "\2\0\1\151\1\0\1\151\14\0\1\2\6\3\1\0" +
            "\1\7\2\0\2\3\1\152\3\3\6\0\7\3\2\0" +
            "\6\3\11\0\1\2\6\3\1\0\1\7\2\0\6\3" +
            "\6\0\5\3\1\153\1\3\2\0\6\3\11\0\1\100" +
            "\5\52\2\100\1\101\1\0\4\100\2\52\1\100\1\54" +
            "\7\100\5\52\2\100\1\52\1\100\1\52\14\100\1\106" +
            "\5\12\3\106\1\0\4\106\2\12\2\106\1\132\6\106" +
            "\5\12\2\106\1\12\1\106\1\12\14\106\1\0\5\154" +
            "\10\0\2\154\11\0\5\154\2\0\1\154\1\0\1\154" +
            "\14\0\1\2\6\3\1\0\1\7\2\0\6\3\6\0" +
            "\5\3\1\155\1\3\2\0\6\3\11\0\1\2\6\3" +
            "\1\0\1\7\2\0\6\3\6\0\7\3\2\0\3\3" +
            "\1\156\2\3\12\0\5\157\10\0\2\157\11\0\5\157" +
            "\2\0\1\157\1\0\1\157\14\0\1\2\6\3\1\0" +
            "\1\7\2\0\6\3\6\0\7\3\2\0\3\3\1\160" +
            "\2\3\11\0\1\2\6\3\1\0\1\7\2\0\2\3" +
            "\1\161\3\3\6\0\7\3\2\0\6\3\12\0\5\110" +
            "\10\0\2\110\11\0\5\110\2\0\1\110\1\0\1\110" +
            "\14\0\1\2\6\3\1\0\1\7\2\0\2\3\1\162" +
            "\3\3\6\0\7\3\2\0\6\3\11\0\1\2\6\3" +
            "\1\0\1\7\2\0\6\3\6\0\7\3\2\0\4\3" +
            "\1\163\1\3\11\0\1\2\6\3\1\0\1\7\2\0" +
            "\6\3\6\0\7\3\2\0\4\3\1\164\1\3\11\0";

    /**
     * The transition table of the DFA
     */
    final private static int yytrans [] = yy_unpack();

    /* error codes */
    final private static int YY_UNKNOWN_ERROR = 0;
    final private static int YY_ILLEGAL_STATE = 1;
    final private static int YY_NO_MATCH = 2;
    final private static int YY_PUSHBACK_2BIG = 3;

    /* error messages for the codes above */
    final private static String YY_ERROR_MSG[] = {
        "Unkown internal scanner error",
        "Internal error: unknown state",
        "Error: could not match input",
        "Error: pushback value was too large"
    };

    /**
     * YY_ATTRIBUTE[aState] contains the attributes of state <code>aState</code>
     */
    private final static byte YY_ATTRIBUTE[] = {
        0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        9, 1, 9, 9, 9, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 9, 1, 9, 1, 1,
        9, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1,
        0, 9, 1, 1, 1, 1, 1, 1, 1, 1, 9, 0, 9, 9, 0, 9,
        1, 9, 1, 1, 1, 1, 1, 1, 1, 9, 1, 0, 9, 1, 1, 9,
        1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1,
        1, 1, 1, 1
    };

    /**
     * the input device
     */
    private java.io.Reader yy_reader;

    /**
     * the current state of the DFA
     */
    private int yy_state;

    /**
     * the current lexical state
     */
    private int yy_lexical_state = YYINITIAL;

    /**
     * this buffer contains the current text to be matched and is
     * the source of the yytext() string
     */
    private char yy_buffer[] = new char[YY_BUFFERSIZE];

    /**
     * the textposition at the last accepting state
     */
    private int yy_markedPos;

    /**
     * the textposition at the last state to be included in yytext
     */
    private int yy_pushbackPos;

    /**
     * the current text position in the buffer
     */
    private int yy_currentPos;

    /**
     * startRead marks the beginning of the yytext() string in the buffer
     */
    private int yy_startRead;

    /**
     * endRead marks the last character in the buffer, that has been read
     * from input
     */
    private int yy_endRead;

    /**
     * number of newlines encountered up to the start of the matched text
     */
    private int yyline;

    /**
     * the number of characters up to the start of the matched text
     */
    private int yychar;

    /**
     * the number of characters from the last newline up to the start of the
     * matched text
     */
    private int yycolumn;

    /**
     * yy_atBOL == true <=> the scanner is currently at the beginning of a line
     */
    private boolean yy_atBOL = true;

    /**
     * yy_atEOF == true <=> the scanner is at the EOF
     */
    private boolean yy_atEOF;

    /* user code: */
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private StringBuffer commentText = new StringBuffer();
    private OrderingToken lastToken;
    private String lastTokenImage;
    private String classType;
    private MdClass mdClass;
    private MdClass currentMdClass;

    /**
     * next Token method that allows you to control if whitespace and comments are
     * returned as tokens.
     */
    public Token getNextToken(boolean returnComments, boolean returnWhiteSpace)
            throws IOException {
        Token t = getNextToken();
        while (t != null && ((!returnWhiteSpace && t.isWhiteSpace()) || (!returnComments && t.isComment()))) {
            t = getNextToken();
        }
        return (t);
    }

    //
    private int getType(MdField field) {
        Class clazz = field.getField().getType();

        if (clazz.isArray()) {
            return OrderingToken.TYPE_ARRAY;
        } else if (clazz.isPrimitive()) {
            if (clazz.getName().equals("boolean")) {
                return OrderingToken.TYPE_BOOLEAN;
            } else {
                return OrderingToken.TYPE_NUMBER;
            }
        } else {
            if (field.getCategory() == MDStatics.CATEGORY_REF) {
                return OrderingToken.TYPE_PC;
            } else if (field.getCategory() == MDStatics.CATEGORY_COLLECTION) {
                return OrderingToken.TYPE_COLLECTION;
            } else if (field.getCategory() == MDStatics.CATEGORY_MAP) {
                return OrderingToken.TYPE_MAP;
            } else if (clazz.equals(String.class)) {
                return OrderingToken.TYPE_STRING;
            } else {
                if (clazz.equals(Boolean.class)) {
                    return OrderingToken.TYPE_BOOLEAN;
                } else if (clazz.equals(Byte.class) ||
                        clazz.equals(Integer.class) ||
                        clazz.equals(Short.class) ||
                        clazz.equals(Character.class) ||
                        clazz.equals(Double.class) ||
                        clazz.equals(Float.class) ||
                        clazz.equals(Long.class) ||
                        clazz.equals(java.util.Date.class) ||
                        clazz.equals(java.math.BigDecimal.class) ||
                        clazz.equals(java.math.BigInteger.class)) {
                    return OrderingToken.TYPE_NUMBER;

                } else {
                    return OrderingToken.TYPE_OBJECT;
                }
            }
        }
    }

    /**
     * Prints out tokens from a file or System.in.
     * If no arguments are given, System.in will be used for input.
     * If more arguments are given, the first argument will be used as
     * the name of the file to use as input
     *
     * @param args program arguments, of which the first is a filename
     */
    public static void main(String[] args) {
        InputStream in;
        try {
            if (args.length > 0) {
                File f = new File(args[0]);
                if (f.exists()) {
                    if (f.canRead()) {
                        in = new FileInputStream(f);
                    } else {
                        throw new IOException("Could not open " + args[0]);
                    }
                } else {
                    throw new IOException("Could not find " + args[0]);
                }
            } else {
                in = System.in;
            }
            OrderingLexer shredder = new OrderingLexer(in);
            Token t;
            while ((t = shredder.getNextToken()) != null) {
                if (t.getID() != OrderingToken.WHITE_SPACE) {
                    System.out.println(t);
                }
            }
        } catch (IOException e) {
            System.out.println(e.getMessage());
        }
    }

    /**
     * Closes the current input stream, and resets the scanner to read from a new input stream.
     * All internal variables are reset, the old input stream  cannot be reused
     * (content of the internal buffer is discarded and lost).
     * The lexical state is set to the initial state.
     * Subsequent tokens read from the lexer will start with the line, char, and column
     * values given here.
     *
     * @param reader   The new input.
     * @param yyline   The line number of the first token.
     * @param yychar   The position (relative to the start of the stream) of the first token.
     * @param yycolumn The position (relative to the line) of the first token.
     * @throws IOException if an IOExecption occurs while switching readers.
     */
    public void reset(java.io.Reader reader, int yyline, int yychar,
            int yycolumn) throws IOException {
        yyreset(reader);
        this.yyline = yyline;
        this.yychar = yychar;
        this.yycolumn = yycolumn;
        currentMdClass = mdClass;
    }

    public OrderingLexer() {}

    public OrderingLexer(String s) {
        this(new StringReader(s));
    }

    public MdClass getMdClass() {
        return mdClass;
    }

    public MdClass getCurrentMdClass() {
        if (currentMdClass == null) {
            return mdClass;
        }
        return currentMdClass;
    }

    public void setMdClass(MdClass mdClass) {
        this.mdClass = mdClass;
        this.currentMdClass = mdClass;
    }

    public void setClassType(String classType) {
        this.classType = classType;
    }

    public void setReader(java.io.Reader in) {
        this.yy_reader = in;
    }

    private boolean isNow(OrderingToken t, int currentPosition) {
        if (((t.getCharBegin()) <= currentPosition
                && (t.getCharEnd()) >= currentPosition)) {
            return true;
        } else {
            return false;
        }
    }

    public BodyDataWrapper getClassData(MdClass mdClassCurrent) {
        FieldDisplay.BIGGEST_LENGHT = 0;
        HashSet dataSet = new HashSet();

        if (mdClassCurrent == null) return null;
        List list = mdClassCurrent.getFieldList();
        for (Iterator iter = list.iterator(); iter.hasNext();) {
            MdField f = (MdField)iter.next();
            if (f.getField() != null &&
                    f.getPersistenceModifierInt() == MDStatics.PERSISTENCE_MODIFIER_PERSISTENT &&
                    f.getCategory() != MDStatics.CATEGORY_COLLECTION &&
                    f.getCategory() != MDStatics.CATEGORY_MAP &&
                    f.getCategory() != MDStatics.CATEGORY_ARRAY) {
                DisplayField disp = new DisplayField(f.getField().getName(),
                        getShortName(f.getField().getType().getName()), null);
                disp.setLenght();
                dataSet.add(disp);
            }
        }

        HashSet setToFill = new HashSet();
        fillInheritedFields(mdClassCurrent, setToFill);
        dataSet.addAll(setToFill);

        ArrayList returnList = new ArrayList(dataSet);
        if (returnList.isEmpty()) {
            return new BodyDataWrapper("No ordering fields found",
                    new Object[0]);
        }

        Collections.sort(returnList);
        return new BodyDataWrapper(getShortName(mdClassCurrent.getName()),
                returnList.toArray());
    }

    private String getShortName(String longName) {
        if (longName.lastIndexOf('.') > 0) {
            return longName.substring(longName.lastIndexOf('.') + 1,
                    longName.length());
        } else {
            return longName;
        }
    }

    private void fillInheritedFields(MdClass mdClassCurrent,
            HashSet listToFill) {
        String superClassString = mdClassCurrent.getPcSuperclassStr();
        if (superClassString == null) return;
        MdClass mdClass = mdClassCurrent.getMdPackage().findClass(
                superClassString);
        if (mdClass == null) return;
        ObservableList list = (ObservableList)mdClass.getFieldList();
        for (Iterator iter = list.iterator(); iter.hasNext();) {
            MdField f = (MdField)iter.next();
            if (f.getField() != null &&
                    f.getPersistenceModifierInt() == MDStatics.PERSISTENCE_MODIFIER_PERSISTENT &&
                    f.getCategory() != MDStatics.CATEGORY_COLLECTION &&
                    f.getCategory() != MDStatics.CATEGORY_MAP &&
                    f.getCategory() != MDStatics.CATEGORY_ARRAY) {
                DisplayInheritedField disp = new DisplayInheritedField(
                        f.getField().getName(),
                        getShortName(f.getField().getType().getName()), null);
                disp.setLenght();
                listToFill.add(disp);
            }
        }
        fillInheritedFields(mdClass, listToFill);
    }

    public class BodyDataWrapper {

        public Object[] data;
        public String className;

        public BodyDataWrapper(String className, Object[] data) {
            this.className = className;
            this.data = data;
        }
    }

    private MdField findField(MdClass mdClass, String fieldName) {
        if (mdClass == null) return null;
        MdField field = mdClass.findField(fieldName);
        if (field == null) {
            String superClassString = mdClass.getPcSuperclassStr();
            if (superClassString == null) {
                return null;
            } else {
                MdClass mdClassCurrent = mdClass.getMdPackage().findClass(
                        superClassString);
                if (mdClass == null) return null;
                MdField newfield = mdClassCurrent.findField(fieldName);
                if (newfield != null &&
                        newfield.getPersistenceModifierInt() == MDStatics.PERSISTENCE_MODIFIER_PERSISTENT &&
                        newfield.getCategory() != MDStatics.CATEGORY_COLLECTION &&
                        newfield.getCategory() != MDStatics.CATEGORY_MAP &&
                        newfield.getCategory() != MDStatics.CATEGORY_ARRAY) {
                    return newfield;
                } else {
                    return findField(mdClassCurrent, fieldName);
                }
            }

        } else {
            return field;
        }

    }

    /**
     * Before this gets called we must first reset the reader.
     *
     * @param currentPosition position of our Caret
     * @return
     */
    public BodyDataWrapper getBodyDataWrapper(int currentPosition) {
        OrderingToken t = null;
        boolean isWhiteSpace = false;
        try {
            while ((t = (OrderingToken)getNextToken(false, true)) != null) {

                if (isNow(t, currentPosition)) {     // we have to return something
                    isWhiteSpace = false;

                    if (getCurrentMdClass() == null && classType != null) {
                        System.out.println("1 " + t);

                        if (t.getID() == OrderingToken.RESERVED_WORD_THIS) {
                            return new BodyDataWrapper(classType, getThis());
                        }

                        if (t.isWhiteSpace()) {
                            t = t.getPrevToken();
                            System.out.println("2 " + t);
                            if (t.getID() == OrderingToken.RESERVED_WORD_THIS) {
                                return new BodyDataWrapper("Ordering",
                                        getReserved());
                            }
                        }
                    }

                    if (t.isWhiteSpace()) {
                        t = t.getPrevToken();
                        isWhiteSpace = true;
                        if (t == null) {
                            return getClassData(getCurrentMdClass());
                        } else if (t.isWhiteSpace()) {
                            return getClassData(getCurrentMdClass());
                        }
                    }

                    if (t.isIdentifier()) {
                        if (t.getID() == OrderingToken.IDENTIFIER &&
                                t.type == OrderingToken.TYPE_PC &&
                                !isWhiteSpace) {
                            return getClassData(getCurrentMdClass());
                        } else if (t.getID() == OrderingToken.IDENTIFIER &&
                                t.type != OrderingToken.TYPE_PC
                                && isWhiteSpace) {
                            return new BodyDataWrapper("Ordering",
                                    getReserved());
                        } else if (t.getID() == OrderingToken.IDENTIFIER &&
                                !isWhiteSpace) {
                            return getClassData(getCurrentMdClass());
                        } else {
                            return null;
                        }

                    } else if (t.getID() == OrderingToken.SEPARATOR_PERIOD) {
                        if (t.specialID == OrderingToken.SPECIAL_ID_IDENTIFIER) {
                            return getClassData(getCurrentMdClass());
                        } else {
                            return null;
                        }
                    } else if (t.getID() == OrderingToken.SEPARATOR_COMMA) {
                        return getClassData(mdClass);
                    } else if (t.isReservedWord()) {
                        if (!isWhiteSpace) {
                            return new BodyDataWrapper("Ordering",
                                    getReserved());
                        } else {
                            return null;
                        }
                    } else if (t.isError()) {
                        OrderingToken prev = t.getPrevToken();

                        if (prev != null) {

                            if (prev.getID() == OrderingToken.SEPARATOR_PERIOD) {
                                if (prev.specialID == OrderingToken.SPECIAL_ID_IDENTIFIER) {
                                    return getClassData(getCurrentMdClass());
                                } else {
                                    return null;
                                }
                            } else if (prev.isComment()) {
                                return getClassData(getCurrentMdClass());
                            } else if (prev.isSeparator()) {
                                return getClassData(getCurrentMdClass());
                            } else if (prev.isOperator()) {
                                return getClassData(getCurrentMdClass());
                            } else if (t.getID() == 3907) {
                                return getClassData(getCurrentMdClass());
                            } else {

                                return null;
                            }
                        } else {

                            return getClassData(getCurrentMdClass());
                        }
                    } else {
                        if (t.getID() == 1024) {
                            return getClassData(getCurrentMdClass());
                        } else {
                            return null;
                        }
                    }

                }
            }
            if (getCurrentMdClass() == null && classType != null) {
                return new BodyDataWrapper(classType, getThis());
            } else {
                return getClassData(getCurrentMdClass());
            }
        } catch (IOException e) {
            return getClassData(getCurrentMdClass());
        }
    }

    private Object[] getReserved() {
        FieldDisplay.BIGGEST_LENGHT = 0;
        Object[] string = new Object[2];
        DisplayReserved end = new DisplayReserved("ascending", "", "");
        end.setLenght();
        string[0] = end;
        DisplayReserved start = new DisplayReserved("descending", "", "");
        start.setLenght();
        string[1] = start;

        return string;
    }

    private Object[] getThis() {
        FieldDisplay.BIGGEST_LENGHT = 0;
        Object[] string = new Object[1];
        DisplayReserved end = new DisplayReserved("this", "", "");
        end.setLenght();
        string[0] = end;
        return string;
    }
    //////////////////////////////////////////////////////////////////////////////////////////////////////////







    /**
     * Creates a new scanner
     * There is also a java.io.InputStream version of this constructor.
     *
     * @param in the java.io.Reader to read input from.
     */
    public OrderingLexer(java.io.Reader in) {
        this.yy_reader = in;
    }

    /**
     * Creates a new scanner.
     * There is also java.io.Reader version of this constructor.
     *
     * @param in the java.io.Inputstream to read input from.
     */
    public OrderingLexer(java.io.InputStream in) {
        this(new java.io.InputStreamReader(in));
    }

    /**
     * Unpacks the split, compressed DFA transition table.
     *
     * @return the unpacked transition table
     */
    private static int[] yy_unpack() {
        int[] trans = new int[4183];
        int offset = 0;
        offset = yy_unpack(yy_packed0, offset, trans);
        return trans;
    }

    /**
     * Unpacks the compressed DFA transition table.
     *
     * @param packed the packed transition table
     * @return the index of the last entry
     */
    private static int yy_unpack(String packed, int offset, int[] trans) {
        int i = 0;       /* index in packed string  */
        int j = offset;  /* index in unpacked array */
        int l = packed.length();
        while (i < l) {
            int count = packed.charAt(i++);
            int value = packed.charAt(i++);
            value--;
            do trans[j++] = value; while (--count > 0);
        }
        return j;
    }

    /**
     * Refills the input buffer.
     *
     * @return <code>false</code>, iff there was new input.
     * @throws IOException if any I/O-Error occurs
     */
    private boolean yy_refill() throws java.io.IOException {

        /* first: make room (if you can) */
        if (yy_startRead > 0) {
            System.arraycopy(yy_buffer, yy_startRead,
                    yy_buffer, 0,
                    yy_endRead - yy_startRead);

            /* translate stored positions */
            yy_endRead -= yy_startRead;
            yy_currentPos -= yy_startRead;
            yy_markedPos -= yy_startRead;
            yy_pushbackPos -= yy_startRead;
            yy_startRead = 0;
        }

        /* is the buffer big enough? */
        if (yy_currentPos >= yy_buffer.length) {
            /* if not: blow it up */
            char newBuffer[] = new char[yy_currentPos * 2];
            System.arraycopy(yy_buffer, 0, newBuffer, 0, yy_buffer.length);
            yy_buffer = newBuffer;
        }

        /* finally: fill the buffer with new input */
        int numRead = yy_reader.read(yy_buffer, yy_endRead,
                yy_buffer.length - yy_endRead);

        if (numRead < 0) {
            return true;
        } else {
            yy_endRead += numRead;
            return false;
        }
    }

    /**
     * Closes the input stream.
     */
    final public void yyclose() throws java.io.IOException {
        yy_atEOF = true;            /* indicate end of file */
        yy_endRead = yy_startRead;  /* invalidate buffer    */

        if (yy_reader != null) {
            yy_reader.close();
        }
    }

    /**
     * Closes the current stream, and resets the
     * scanner to read from a new input stream.
     * <p/>
     * All internal variables are reset, the old input stream
     * <b>cannot</b> be reused (internal buffer is discarded and lost).
     * Lexical state is set to <tt>YY_INITIAL</tt>.
     *
     * @param reader the new input stream
     */
    final public void yyreset(java.io.Reader reader)
            throws java.io.IOException {
        yyclose();
        yy_reader = reader;
        yy_atBOL = true;
        yy_atEOF = false;
        yy_endRead = yy_startRead = 0;
        yy_currentPos = yy_markedPos = yy_pushbackPos = 0;
        yyline = yychar = yycolumn = 0;
        yy_lexical_state = YYINITIAL;
    }

    /**
     * Returns the current lexical state.
     */
    final public int yystate() {
        return yy_lexical_state;
    }

    /**
     * Enters a new lexical state
     *
     * @param newState the new lexical state
     */
    final public void yybegin(int newState) {
        yy_lexical_state = newState;
    }

    /**
     * Returns the text matched by the current regular expression.
     */
    final public String yytext() {
        return new String(yy_buffer, yy_startRead, yy_markedPos - yy_startRead);
    }

    /**
     * Returns the character at position <tt>pos</tt> from the
     * matched text.
     * <p/>
     * It is equivalent to yytext().charAt(pos), but faster
     *
     * @param pos the position of the character to fetch.
     *            A value from 0 to yylength()-1.
     * @return the character at position pos
     */
    final public char yycharat(int pos) {
        return yy_buffer[yy_startRead + pos];
    }

    /**
     * Returns the length of the matched text region.
     */
    final public int yylength() {
        return yy_markedPos - yy_startRead;
    }

    /**
     * Reports an error that occured while scanning.
     * <p/>
     * In a wellformed scanner (no or only correct usage of
     * yypushback(int) and a match-all fallback rule) this method
     * will only be called with things that "Can't Possibly Happen".
     * If this method is called, something is seriously wrong
     * (e.g. a JFlex bug producing a faulty scanner etc.).
     * <p/>
     * Usual syntax/scanner level error handling should be done
     * in error fallback rules.
     *
     * @param errorCode the code of the errormessage to display
     */
    private void yy_ScanError(int errorCode) {
        String message;
        try {
            message = YY_ERROR_MSG[errorCode];
        } catch (ArrayIndexOutOfBoundsException e) {
            message = YY_ERROR_MSG[YY_UNKNOWN_ERROR];
        }

        throw new Error(message);
    }

    /**
     * Pushes the specified amount of characters back into the input stream.
     * <p/>
     * They will be read again by then next call of the scanning method
     *
     * @param number the number of characters to be read again.
     *               This number must not be greater than yylength()!
     */
    private void yypushback(int number) {
        if (number > yylength()) {
            yy_ScanError(YY_PUSHBACK_2BIG);
        }

        yy_markedPos -= number;
    }

    /**
     * Resumes scanning until the next regular expression is matched,
     * the end of input is encountered or an I/O-Error occurs.
     *
     * @return the next token
     * @throws IOException if any I/O-Error occurs
     */
    public Token getNextToken() throws java.io.IOException {
        int yy_input;
        int yy_action;

        // cached fields:
        int yy_currentPos_l;
        int yy_startRead_l;
        int yy_markedPos_l;
        int yy_endRead_l = yy_endRead;
        char[] yy_buffer_l = yy_buffer;
        char[] yycmap_l = yycmap;

        int[] yytrans_l = yytrans;
        int[] yy_rowMap_l = yy_rowMap;
        byte[] yy_attr_l = YY_ATTRIBUTE;

        while (true) {
            yy_markedPos_l = yy_markedPos;

            yychar += yy_markedPos_l - yy_startRead;

            boolean yy_r = false;
            for (yy_currentPos_l = yy_startRead; yy_currentPos_l < yy_markedPos_l;
                 yy_currentPos_l++) {
                switch (yy_buffer_l[yy_currentPos_l]) {
                    case '\u000B':
                    case '\u000C':
                    case '\u0085':
                    case '\u2028':
                    case '\u2029':
                        yyline++;
                        yy_r = false;
                        break;
                    case '\r':
                        yyline++;
                        yy_r = true;
                        break;
                    case '\n':
                        if (yy_r) {
                            yy_r = false;
                        } else {
                            yyline++;
                        }
                        break;
                    default:
                        yy_r = false;
                }
            }

            if (yy_r) {
                // peek one character ahead if it is \n (if we have counted one line too much)
                boolean yy_peek;
                if (yy_markedPos_l < yy_endRead_l) {
                    yy_peek = yy_buffer_l[yy_markedPos_l] == '\n';
                } else if (yy_atEOF) {
                    yy_peek = false;
                } else {
                    boolean eof = yy_refill();
                    yy_markedPos_l = yy_markedPos;
                    yy_buffer_l = yy_buffer;
                    if (eof) {
                        yy_peek = false;
                    } else {
                        yy_peek = yy_buffer_l[yy_markedPos_l] == '\n';
                    }
                }
                if (yy_peek) yyline--;
            }
            yy_action = -1;

            yy_startRead_l = yy_currentPos_l = yy_currentPos =
                    yy_startRead = yy_markedPos_l;

            yy_state = yy_lexical_state;

            yy_forAction: {
                while (true) {

                    if (yy_currentPos_l < yy_endRead_l) {
                        yy_input = yy_buffer_l[yy_currentPos_l++];
                    } else if (yy_atEOF) {
                        yy_input = YYEOF;
                        break yy_forAction;
                    } else {
                        // store back cached positions
                        yy_currentPos = yy_currentPos_l;
                        yy_markedPos = yy_markedPos_l;
                        boolean eof = yy_refill();
                        // get translated positions and possibly new buffer
                        yy_currentPos_l = yy_currentPos;
                        yy_markedPos_l = yy_markedPos;
                        yy_buffer_l = yy_buffer;
                        yy_endRead_l = yy_endRead;
                        if (eof) {
                            yy_input = YYEOF;
                            break yy_forAction;
                        } else {
                            yy_input = yy_buffer_l[yy_currentPos_l++];
                        }
                    }
                    int yy_next = yytrans_l[yy_rowMap_l[yy_state] + yycmap_l[yy_input]];
                    if (yy_next == -1) break yy_forAction;
                    yy_state = yy_next;

                    int yy_attributes = yy_attr_l[yy_state];
                    if ((yy_attributes & 1) == 1) {
                        yy_action = yy_state;
                        yy_markedPos_l = yy_currentPos_l;
                        if ((yy_attributes & 8) == 8) break yy_forAction;
                    }

                }
            }

            // store back cached position
            yy_markedPos = yy_markedPos_l;

            switch (yy_action) {

                case 29:
                case 30:
                case 50:
                case 55:
                case 76:
                case 83:
                    {
                        Double d;
                        OrderingToken t = null;
                        try {
                            d = Double.valueOf(yytext());
                            if (d.isInfinite() || d.compareTo(new Double(0d)) == 0) {
                                t = (new OrderingToken(
                                        OrderingToken.ERROR_DOUBLE_SIZE,
                                        yytext(), yyline, yychar,
                                        yychar + yytext().length()));
                                t.setPrevToken(lastToken);
                                lastToken = t;
                                t.type = OrderingToken.TYPE_NUMBER;
                                return (t);
                            } else {
                                t = (new OrderingToken(
                                        OrderingToken.ERROR_INVALID_SEPERATOR,
                                        yytext(), yyline, yychar,
                                        yychar + yytext().length()));
                                t.setPrevToken(lastToken);
                                lastToken = t;
                                t.type = OrderingToken.TYPE_NUMBER;
                                return (t);
                            }
                        } catch (NumberFormatException e) {

                            t = (new OrderingToken(
                                    OrderingToken.ERROR_DOUBLE_SIZE, yytext(),
                                    yyline, yychar, yychar + yytext().length()));
                            t.setPrevToken(lastToken);
                            lastToken = t;
                            t.type = OrderingToken.TYPE_NUMBER;
                            return (t);
                        }
                    }
                case 117:
                    break;
                case 19:
                    {
                        OrderingToken t = (new OrderingToken(
                                OrderingToken.ERROR_INVALID_SEPERATOR,
                                yytext(), yyline, yychar, yychar + 1));

                        return (t);
                    }
                case 118:
                    break;
                case 115:
                    {
                        OrderingToken t = (new OrderingToken(
                                OrderingToken.RESERVED_WORD, yytext(), yyline,
                                yychar, yychar + 10));
                        t.type = OrderingToken.TYPE_BOOLEAN;
                        t.setPrevToken(lastToken);
                        lastToken = t;
                        return (t);
                    }
                case 119:
                    break;
                case 1:
                case 6:
                case 39:
                case 61:
                case 86:
                case 96:
                    {
                        OrderingToken t = (new OrderingToken(
                                OrderingToken.ERROR_IDENTIFIER, yytext(),
                                yyline, yychar, yychar + yytext().length()));
                        t.setPrevToken(lastToken);
                        lastToken = t;
                        return (t);
                    }
                case 120:
                    break;
                case 16:
                    {
                        OrderingToken t = (new OrderingToken(
                                OrderingToken.SEPARATOR_COMMA, yytext(),
                                yyline, yychar, yychar + 1));
                        t.setPrevToken(lastToken);
                        lastToken = t;
                        currentMdClass = mdClass;
                        return (t);
                    }
                case 121:
                    break;
                case 89:
                    {
                        OrderingToken t = (new OrderingToken(
                                OrderingToken.ERROR_MALFORMED_STRING, yytext(),
                                yyline, yychar, yychar + yytext().length()));
                        t.setPrevToken(lastToken);
                        t.type = OrderingToken.TYPE_STRING;
                        lastToken = t;
                        return (t);
                    }
                case 122:
                    break;
                case 15:
                    {
                        if (lastToken != null) {
                            if (lastToken.getID() == OrderingToken.IDENTIFIER) {
                                MdField field = findField(currentMdClass,
                                        lastTokenImage);
                                if (field != null) {
                                    if (field.getCategory() == MDStatics.CATEGORY_REF) {
                                        //PC
                                        currentMdClass = field.getRefClass();
                                        OrderingToken t = (new OrderingToken(
                                                OrderingToken.SEPARATOR_PERIOD,
                                                yytext(), yyline, yychar,
                                                yychar + 1));
                                        t.setPrevToken(lastToken);
                                        t.type = OrderingToken.TYPE_DOT_SEPERATOR;
                                        t.specialID = OrderingToken.SPECIAL_ID_IDENTIFIER;
                                        lastToken = t;
                                        return (t);
                                    } else if (field.getCategory() == MDStatics.CATEGORY_COLLECTION) {
                                        //Collection
                                        OrderingToken t = (new OrderingToken(
                                                OrderingToken.SEPARATOR_PERIOD,
                                                yytext(), yyline, yychar,
                                                yychar + 1));
                                        t.specialID = OrderingToken.SPECIAL_ID_COLLECTION;
                                        t.setPrevToken(lastToken);
                                        t.type = OrderingToken.TYPE_DOT_SEPERATOR;
                                        lastToken = t;
                                        return (t);

                                    } else if (field.getCategory() == MDStatics.CATEGORY_MAP) {
                                        //Map
                                        OrderingToken t = (new OrderingToken(
                                                OrderingToken.SEPARATOR_PERIOD,
                                                yytext(), yyline, yychar,
                                                yychar + 1));
                                        t.specialID = OrderingToken.SPECIAL_ID_MAP;
                                        t.setPrevToken(lastToken);
                                        t.type = OrderingToken.TYPE_DOT_SEPERATOR;
                                        lastToken = t;
                                        return (t);

                                    } else if (field.getField().getType().equals(
                                            String.class)) {
                                        //String
                                        OrderingToken t = (new OrderingToken(
                                                OrderingToken.SEPARATOR_PERIOD,
                                                yytext(), yyline, yychar,
                                                yychar + 1));
                                        t.specialID = OrderingToken.SPECIAL_ID_STRING;
                                        t.setPrevToken(lastToken);
                                        t.type = OrderingToken.TYPE_DOT_SEPERATOR;
                                        lastToken = t;
                                        return (t);

                                    } else {
                                        //Object or something

                                        OrderingToken t = (new OrderingToken(
                                                OrderingToken.ERROR_INVALID_SEPERATOR,
                                                yytext(), yyline, yychar,
                                                yychar + 1));
                                        t.setPrevToken(lastToken);
                                        t.type = OrderingToken.TYPE_DOT_SEPERATOR;
                                        lastToken = t;
                                        return (t);
                                    }
                                } else {
                                    OrderingToken t = (new OrderingToken(
                                            OrderingToken.SEPARATOR_PERIOD,
                                            yytext(), yyline, yychar, yychar + 1));
                                    t.setPrevToken(lastToken);
                                    t.type = OrderingToken.TYPE_DOT_SEPERATOR;
                                    lastToken = t;
                                    return (t);
                                }
                            } else if (lastToken.getID() == OrderingToken.IDENTIFIER_VAR_PC) {
                                OrderingToken t = (new OrderingToken(
                                        OrderingToken.SEPARATOR_PERIOD,
                                        yytext(), yyline, yychar, yychar + 1));
                                t.setPrevToken(lastToken);
                                t.type = OrderingToken.TYPE_DOT_SEPERATOR;
                                t.specialID = OrderingToken.SPECIAL_ID_IDENTIFIER;
                                lastToken = t;
                                return (t);
                            } else if (lastToken.getID() == OrderingToken.IDENTIFIER_VAR) {
                                OrderingToken t = (new OrderingToken(
                                        OrderingToken.ERROR_INVALID_SEPERATOR,
                                        yytext(), yyline, yychar, yychar + 1));
                                t.setPrevToken(lastToken);
                                t.type = OrderingToken.TYPE_DOT_SEPERATOR;
                                lastToken = t;
                                return (t);
                            } else if (lastToken.getID() == OrderingToken.IDENTIFIER_STRING) {
                                //String
                                OrderingToken t = (new OrderingToken(
                                        OrderingToken.SEPARATOR_PERIOD,
                                        yytext(), yyline, yychar, yychar + 1));
                                t.specialID = OrderingToken.SPECIAL_ID_STRING;
                                t.setPrevToken(lastToken);
                                t.type = OrderingToken.TYPE_DOT_SEPERATOR;
                                lastToken = t;
                                return (t);
                            } else {
                                if (lastToken.getID() == OrderingToken.SEPARATOR_RPAREN && lastToken.getPrevToken() != null) {
                                    OrderingToken right = lastToken.getPrevToken();
                                    if (right.getID() == OrderingToken.SEPARATOR_LPAREN && right.getPrevToken() != null) {
                                        OrderingToken string = right.getPrevToken();
                                        if (string.getID() == OrderingToken.IDENTIFIER_STRING && string.type == OrderingToken.TYPE_STRING) {
                                            OrderingToken t = (new OrderingToken(
                                                    OrderingToken.SEPARATOR_PERIOD,
                                                    yytext(), yyline, yychar,
                                                    yychar + 1));
                                            t.specialID = OrderingToken.SPECIAL_ID_STRING_LOWER;
                                            t.setPrevToken(lastToken);
                                            t.type = OrderingToken.TYPE_DOT_SEPERATOR;
                                            lastToken = t;
                                            return (t);
                                        }
                                    }
                                }
                                OrderingToken t = (new OrderingToken(
                                        OrderingToken.SEPARATOR_PERIOD,
                                        yytext(), yyline, yychar, yychar + 1));
                                t.setPrevToken(lastToken);
                                t.type = OrderingToken.TYPE_DOT_SEPERATOR;
                                lastToken = t;
                                return (t);
                            }
                        } else {
                            OrderingToken t = (new OrderingToken(
                                    OrderingToken.ERROR_INVALID_SEPERATOR,
                                    yytext(), yyline, yychar, yychar + 1));
                            t.setPrevToken(lastToken);
                            lastToken = t;
                            return (t);
                        }
                    }
                case 123:
                    break;
                case 3:
                case 4:
                    {
                        /* At this point, the number we found could still be too large.
                         * If it is too large, we need to return an error.
                         * Java has methods built in that will decode from a string
                         * and throw an exception the number is too large
                         */
                        OrderingToken t = null;
                        try {
                            /* bigger negatives are allowed than positives.  Thus
                             * we have to be careful to make sure a neg sign is preserved
                             */
                            if (lastToken != null) {
                                if (lastToken.getID() == OrderingToken.OPERATOR_SUBTRACT) {
                                    Integer.decode('-' + yytext());
                                } else {
                                    Integer.decode(yytext());
                                }
                            } else {
                                Integer.decode(yytext());
                            }
                            t = (new OrderingToken(
                                    OrderingToken.ERROR_INVALID_SEPERATOR,
                                    yytext(), yyline, yychar,
                                    yychar + yytext().length()));
                        } catch (NumberFormatException e) {
                            t = (new OrderingToken(
                                    OrderingToken.ERROR_INTEGER_DECIMIAL_SIZE,
                                    yytext(), yyline, yychar,
                                    yychar + yytext().length()));
                        }
                        t.type = OrderingToken.TYPE_NUMBER;
                        lastToken = t;
                        return (t);
                    }
                case 124:
                    break;
                case 26:
                case 74:
                    {
                        /* Sun s java has a few bugs here.  Their MAX_FLOAT and MIN_FLOAT do not
                         * quite match the spec.  Its not far off, so we will deal.  If they fix
                         * then we are fixed.  So all good.
                         */
                        Float f;
                        OrderingToken t = null;
                        try {
                            f = Float.valueOf(yytext());
                            if (f.isInfinite() || f.compareTo(new Float(0f)) == 0) {
                                t = (new OrderingToken(
                                        OrderingToken.ERROR_FLOAT_SIZE,
                                        yytext(), yyline, yychar,
                                        yychar + yytext().length()));
                                t.setPrevToken(lastToken);
                                lastToken = t;
                                t.type = OrderingToken.TYPE_NUMBER;
                                return (t);
                            } else {
                                t = (new OrderingToken(
                                        OrderingToken.ERROR_INVALID_SEPERATOR,
                                        yytext(), yyline, yychar,
                                        yychar + yytext().length()));
                                t.setPrevToken(lastToken);
                                lastToken = t;
                                t.type = OrderingToken.TYPE_NUMBER;
                                return (t);
                            }
                        } catch (NumberFormatException e) {
                            t = (new OrderingToken(
                                    OrderingToken.ERROR_FLOAT_SIZE, yytext(),
                                    yyline, yychar, yychar + yytext().length()));
                            t.setPrevToken(lastToken);
                            lastToken = t;
                            t.type = OrderingToken.TYPE_NUMBER;
                            return (t);
                        }
                    }
                case 125:
                    break;
                case 27:
                    {
                        OrderingToken t = null;
                        try {
                            if (lastToken != null) {
                                if (lastToken.getID() == OrderingToken.OPERATOR_SUBTRACT) {
                                    Long.decode(
                                            '-' + yytext().substring(0,
                                                    yytext().length() - 1));
                                } else {
                                    Long.decode(
                                            yytext().substring(0,
                                                    yytext().length() - 1));
                                }
                            } else {
                                Long.decode(
                                        yytext().substring(0,
                                                yytext().length() - 1));
                            }
                        } catch (NumberFormatException e) {
                            t = (new OrderingToken(
                                    OrderingToken.ERROR_LONG_DECIMIAL_SIZE,
                                    yytext(), yyline, yychar,
                                    yychar + yytext().length()));
                            t.setPrevToken(lastToken);
                            lastToken = t;
                            t.type = OrderingToken.TYPE_NUMBER;
                            return (t);
                        }
                        t = (new OrderingToken(
                                OrderingToken.ERROR_INVALID_SEPERATOR,
                                yytext(), yyline, yychar,
                                yychar + yytext().length()));
                        t.setPrevToken(lastToken);
                        t.type = OrderingToken.TYPE_NUMBER;
                        lastToken = t;
                        return (t);
                    }
                case 126:
                    break;
                case 58:
                    {
                        /* A Hex number cannot be too big.  After removing
                         * initial zeros, It can have 8 digits
                         */
                        OrderingToken t = null;
                        int i;
                        int length = yytext().length();
                        for (i = 2; i < length - 8; i++) {
                            //check for initial zeros
                            if (yytext().charAt(i) != '0') {
                                t = (new OrderingToken(
                                        OrderingToken.ERROR_INTEGER_HEXIDECIMAL_SIZE,
                                        yytext(), yyline, yychar,
                                        yychar + yytext().length()));
                                t.setPrevToken(lastToken);
                                lastToken = t;
                                t.type = OrderingToken.TYPE_NUMBER;
                                return (t);
                            }
                        }
                        if (length - i > 8) {
                            t = (new OrderingToken(
                                    OrderingToken.ERROR_INTEGER_HEXIDECIMAL_SIZE,
                                    yytext(), yyline, yychar,
                                    yychar + yytext().length()));
                            t.setPrevToken(lastToken);
                            lastToken = t;
                            t.type = OrderingToken.TYPE_NUMBER;
                            return (t);
                        }
                        t = (new OrderingToken(
                                OrderingToken.ERROR_INVALID_SEPERATOR,
                                yytext(), yyline, yychar,
                                yychar + yytext().length()));
                        t.setPrevToken(lastToken);
                        lastToken = t;
                        t.type = OrderingToken.TYPE_NUMBER;
                        return (t);
                    }
                case 127:
                    break;
                case 18:
                    {
                        OrderingToken t = (new OrderingToken(
                                OrderingToken.ERROR_INVALID_SEPERATOR,
                                yytext(), yyline, yychar, yychar + 1));
                        t.setPrevToken(lastToken);
                        lastToken = t;
                        return (t);
                    }
                case 128:
                    break;
                case 5:
                    {
                        OrderingToken t = (new OrderingToken(
                                OrderingToken.WHITE_SPACE, yytext(), yyline,
                                yychar, yychar + yytext().length()));
                        t.setPrevToken(lastToken);
                        lastToken = t;
                        return (t);
                    }
                case 129:
                    break;
                case 8:
                case 63:
                case 68:
                case 88:
                case 97:
                case 102:
                    {
                        OrderingToken t = (new OrderingToken(
                                OrderingToken.ERROR_MALFORMED_UNCLOSED_CHARACTER,
                                yytext(), yyline, yychar,
                                yychar + yytext().length()));
                        t.setPrevToken(lastToken);
                        t.type = OrderingToken.TYPE_NUMBER;
                        lastToken = t;
                        return (t);
                    }
                case 130:
                    break;
                case 44:
                case 69:
                case 70:
                case 90:
                case 98:
                case 103:
                    {
                        OrderingToken t = (new OrderingToken(
                                OrderingToken.ERROR_MALFORMED_UNCLOSED_STRING,
                                yytext(), yyline, yychar,
                                yychar + yytext().length()));
                        t.setPrevToken(lastToken);
                        t.type = OrderingToken.TYPE_STRING;
                        lastToken = t;
                        return (t);
                    }
                case 131:
                    break;
                case 43:
                    {
                        OrderingToken t = (new OrderingToken(
                                OrderingToken.ERROR_MALFORMED_CHARACTER,
                                yytext(), yyline, yychar,
                                yychar + yytext().length()));
                        t.setPrevToken(lastToken);
                        lastToken = t;
                        t.type = OrderingToken.TYPE_NUMBER;
                        return (t);
                    }
                case 132:
                    break;
                case 32:
                case 33:
                    {
                        /* An Octal number cannot be too big.  After removing
                         * initial zeros, It can have 11 digits, the first
                         * of which must be 3 or less.
                         */
                        OrderingToken t = null;
                        int i;
                        int length = yytext().length();
                        for (i = 1; i < length - 11; i++) {
                            //check for initial zeros
                            if (yytext().charAt(i) != '0') {
                                t = (new OrderingToken(
                                        OrderingToken.ERROR_INTEGER_OCTAL_SIZE,
                                        yytext(), yyline, yychar,
                                        yychar + yytext().length()));
                                t.setPrevToken(lastToken);
                                t.type = OrderingToken.TYPE_NUMBER;
                                lastToken = t;
                                return (t);
                            }
                        }
                        if (length - i > 11) {
                            t = (new OrderingToken(
                                    OrderingToken.ERROR_INTEGER_OCTAL_SIZE,
                                    yytext(), yyline, yychar,
                                    yychar + yytext().length()));
                            t.setPrevToken(lastToken);
                            t.type = OrderingToken.TYPE_NUMBER;
                            lastToken = t;
                            return (t);
                        } else if (length - i == 11) {
                            // if the rest of the number is as big as possible
                            // the first digit can only be 3 or less
                            if (yytext().charAt(i) != '0' &&
                                    yytext().charAt(i) != '1' &&
                                    yytext().charAt(i) != '2' &&
                                    yytext().charAt(i) != '3') {

                                t = (new OrderingToken(
                                        OrderingToken.ERROR_INTEGER_OCTAL_SIZE,
                                        yytext(), yyline, yychar,
                                        yychar + yytext().length()));
                                t.setPrevToken(lastToken);
                                t.type = OrderingToken.TYPE_NUMBER;
                                lastToken = t;
                                return (t);
                            }
                        }
                        // Otherwise, it should be OK
                        t = (new OrderingToken(
                                OrderingToken.ERROR_INVALID_SEPERATOR,
                                yytext(), yyline, yychar,
                                yychar + yytext().length()));
                        t.setPrevToken(lastToken);
                        t.type = OrderingToken.TYPE_NUMBER;
                        lastToken = t;
                        return (t);
                    }
                case 133:
                    break;
                case 37:
                case 38:
                case 51:
                case 59:
                case 79:
                case 85:
                    {

                        OrderingToken t = (new OrderingToken(
                                OrderingToken.ERROR_INVALID_SEPERATOR,
                                yytext(), yyline, yychar,
                                yychar + yytext().length()));
                        t.setPrevToken(lastToken);
                        lastToken = t;
                        t.type = OrderingToken.TYPE_NUMBER;
                        return (t);
                    }
                case 134:
                    break;
                case 41:
                case 66:
                case 67:
                    {
                        OrderingToken t = (new OrderingToken(
                                OrderingToken.ERROR_UNCLOSED_CHARACTER,
                                yytext(), yyline, yychar,
                                yychar + yytext().length()));
                        t.setPrevToken(lastToken);
                        t.type = OrderingToken.TYPE_NUMBER;
                        lastToken = t;
                        return (t);
                    }
                case 135:
                    break;
                case 45:
                    {
                        OrderingToken t = (new OrderingToken(
                                OrderingToken.ERROR_INVALID_SEPERATOR,
                                yytext(), yyline, yychar,
                                yychar + yytext().length()));
                        t.setPrevToken(lastToken);
                        t.type = OrderingToken.TYPE_STRING;
                        lastToken = t;
                        return (t);
                    }
                case 136:
                    break;
                case 65:
                    {
                        OrderingToken t = (new OrderingToken(
                                OrderingToken.ERROR_INVALID_SEPERATOR,
                                yytext(), yyline, yychar,
                                yychar + yytext().length()));
                        t.setPrevToken(lastToken);
                        t.type = OrderingToken.TYPE_NUMBER;
                        lastToken = t;
                        return (t);
                    }
                case 137:
                    break;
                case 114:
                    {
                        OrderingToken t = (new OrderingToken(
                                OrderingToken.RESERVED_WORD, yytext(), yyline,
                                yychar, yychar + 9));
                        t.type = OrderingToken.TYPE_BOOLEAN;
                        t.setPrevToken(lastToken);
                        lastToken = t;
                        currentMdClass = mdClass;
                        return (t);
                    }
                case 138:
                    break;
                case 9:
                case 71:
                    {
                        /* most of these errors have to be caught down near the end of the file.
                         * This way, previous expressions of the same length have precedence.
                         * This is really useful for catching anything bad by just allowing it
                         * to slip through the cracks.
                         */
                        OrderingToken t = (new OrderingToken(
                                OrderingToken.ERROR_UNCLOSED_STRING, yytext(),
                                yyline, yychar, yychar + yytext().length()));
                        t.setPrevToken(lastToken);
                        t.type = OrderingToken.TYPE_STRING;
                        lastToken = t;
                        return (t);
                    }
                case 139:
                    break;
                case 57:
                    {
                        /* An Octal number cannot be too big.  After removing
                         * initial zeros, It can have 23 digits, the first
                         * of which must be 1 or less.  The last will be the L or l
                         * at the end.
                         */
                        OrderingToken t = null;
                        int i;
                        int length = yytext().length();
                        for (i = 1; i < length - 23; i++) {
                            //check for initial zeros
                            if (yytext().charAt(i) != '0') {
                                t = (new OrderingToken(
                                        OrderingToken.ERROR_LONG_OCTAL_SIZE,
                                        yytext(), yyline, yychar,
                                        yychar + yytext().length()));
                                t.setPrevToken(lastToken);
                                lastToken = t;
                                t.type = OrderingToken.TYPE_NUMBER;
                                return (t);
                            }
                        }
                        if (length - i > 23) {
                            t = (new OrderingToken(
                                    OrderingToken.ERROR_LONG_OCTAL_SIZE,
                                    yytext(), yyline, yychar,
                                    yychar + yytext().length()));
                            t.setPrevToken(lastToken);
                            lastToken = t;
                            t.type = OrderingToken.TYPE_NUMBER;
                            return (t);
                        } else if (length - i == 23) {
                            // if the rest of the number is as big as possible
                            // the first digit can only be 3 or less
                            if (yytext().charAt(i) != '0' && yytext().charAt(i) != '1') {
                                t = (new OrderingToken(
                                        OrderingToken.ERROR_LONG_OCTAL_SIZE,
                                        yytext(), yyline, yychar,
                                        yychar + yytext().length()));
                                t.setPrevToken(lastToken);
                                lastToken = t;
                                t.type = OrderingToken.TYPE_NUMBER;
                                return (t);
                            }
                        }
                        // Otherwise, it should be OK
                        t = (new OrderingToken(
                                OrderingToken.ERROR_INVALID_SEPERATOR,
                                yytext(), yyline, yychar,
                                yychar + yytext().length()));
                        t.setPrevToken(lastToken);
                        lastToken = t;
                        t.type = OrderingToken.TYPE_NUMBER;
                        return (t);
                    }
                case 140:
                    break;
                case 25:
                case 28:
                case 31:
                case 35:
                case 36:
                    {
                        OrderingToken t = (new OrderingToken(
                                OrderingToken.ERROR_FLOAT, yytext(), yyline,
                                yychar, yychar + yytext().length()));
                        t.setPrevToken(lastToken);
                        t.type = OrderingToken.TYPE_NUMBER;
                        lastToken = t;
                        return (t);
                    }
                case 141:
                    break;
                case 95:
                    {
                        OrderingToken t = (new OrderingToken(
                                OrderingToken.ERROR_INVALID_OPERATOR, yytext(),
                                yyline, yychar, yychar + 4));
                        t.setPrevToken(lastToken);
                        lastToken = t;
                        return (t);
                    }
                case 142:
                    break;
                case 82:
                    {
                        OrderingToken t = (new OrderingToken(
                                OrderingToken.ERROR_INVALID_OPERATOR, yytext(),
                                yyline, yychar, yychar + 3));
                        t.setPrevToken(lastToken);
                        lastToken = t;
                        return (t);
                    }
                case 143:
                    break;
                case 81:
                    {
                        OrderingToken t = (new OrderingToken(
                                OrderingToken.ERROR_INVALID_OPERATOR, yytext(),
                                yyline, yychar, yychar + 3));
                        t.setPrevToken(lastToken);
                        lastToken = t;
                        return (t);
                    }
                case 144:
                    break;
                case 24:
                    {
                        OrderingToken t = (new OrderingToken(
                                OrderingToken.ERROR_INVALID_OPERATOR, yytext(),
                                yyline, yychar, yychar + 1));
                        t.setPrevToken(lastToken);
                        lastToken = t;
                        return (t);
                    }
                case 145:
                    break;
                case 20:
                    {
                        OrderingToken t = (new OrderingToken(
                                OrderingToken.ERROR_INVALID_OPERATOR, yytext(),
                                yyline, yychar, yychar + 1));
                        t.setPrevToken(lastToken);
                        lastToken = t;
                        return (t);
                    }
                case 146:
                    break;
                case 13:
                    {
                        OrderingToken t = (new OrderingToken(
                                OrderingToken.ERROR_INVALID_OPERATOR, yytext(),
                                yyline, yychar, yychar + 1));
                        t.setPrevToken(lastToken);
                        lastToken = t;
                        return (t);
                    }
                case 147:
                    break;
                case 12:
                    {
                        OrderingToken t = (new OrderingToken(
                                OrderingToken.ERROR_INVALID_OPERATOR, yytext(),
                                yyline, yychar, yychar + 1));
                        t.setPrevToken(lastToken);
                        lastToken = t;
                        return (t);
                    }
                case 148:
                    break;
                case 48:
                    {
                        OrderingToken t = (new OrderingToken(
                                OrderingToken.ERROR_INVALID_OPERATOR, yytext(),
                                yyline, yychar, yychar + 2));
                        t.setPrevToken(lastToken);
                        lastToken = t;
                        return (t);
                    }
                case 149:
                    break;
                case 53:
                    {
                        OrderingToken t = (new OrderingToken(
                                OrderingToken.ERROR_INVALID_OPERATOR, yytext(),
                                yyline, yychar, yychar + 2));
                        t.setPrevToken(lastToken);
                        lastToken = t;
                        return (t);
                    }
                case 150:
                    break;
                case 54:
                    {
                        OrderingToken t = (new OrderingToken(
                                OrderingToken.ERROR_INVALID_OPERATOR, yytext(),
                                yyline, yychar, yychar + 2));
                        t.setPrevToken(lastToken);
                        lastToken = t;
                        return (t);
                    }
                case 151:
                    break;
                case 87:
                    {
                        OrderingToken t = (new OrderingToken(
                                OrderingToken.RESERVED_WORD_THIS, yytext(),
                                yyline, yychar, yychar + 4));
                        t.type = OrderingToken.RESERVED_WORD_THIS;
                        t.setPrevToken(lastToken);
                        lastToken = t;
                        return (t);
                    }
                case 152:
                    break;
                case 10:
                    {
                        OrderingToken t = (new OrderingToken(
                                OrderingToken.ERROR_INVALID_OPERATOR, yytext(),
                                yyline, yychar, yychar + 1));
                        currentMdClass = mdClass;
                        t.setPrevToken(lastToken);
                        lastToken = t;
                        return (t);
                    }
                case 153:
                    break;
                case 11:
                    {
                        OrderingToken t = (new OrderingToken(
                                OrderingToken.ERROR_INVALID_OPERATOR, yytext(),
                                yyline, yychar, yychar + 1));
                        currentMdClass = mdClass;
                        t.setPrevToken(lastToken);
                        lastToken = t;
                        return (t);
                    }
                case 154:
                    break;
                case 47:
                case 72:
                    {
                        OrderingToken t = (new OrderingToken(
                                OrderingToken.ERROR_UNCLOSED_COMMENT, yytext(),
                                yyline, yychar, yychar + yytext().length()));
                        t.setPrevToken(lastToken);
                        lastToken = t;
                        return (t);
                    }
                case 155:
                    break;
                case 2:
                case 7:
                case 14:
                case 17:
                case 40:
                case 49:
                case 52:
                case 62:
                case 73:
                case 80:
                case 93:
                case 94:
                case 100:
                case 101:
                case 105:
                case 106:
                case 108:
                case 109:
                case 111:
                case 112:
                case 113:
                    {
                        MdField field = findField(currentMdClass, yytext());
                        if (field != null) {
                            lastTokenImage = yytext();
                            OrderingToken t = (new OrderingToken(
                                    OrderingToken.IDENTIFIER, yytext(), yyline,
                                    yychar, yychar + yytext().length()));
                            t.type = getType(field);
                            t.setPrevToken(lastToken);
                            lastToken = t;
                            return (t);
                        } else {
                            OrderingToken t = (new OrderingToken(
                                    OrderingToken.ERROR_INVALID_IDENTIFIER,
                                    yytext(), yyline, yychar,
                                    yychar + yytext().length()));
                            t.setPrevToken(lastToken);
                            lastToken = t;
                            return (t);
                        }
                    }
                case 156:
                    break;
                case 34:
                case 77:
                    {
                        /* catch the case of a zero in parsing, so that we do not incorrectly
                         * give an error that a number was rounded to zero
                         */
                        OrderingToken t = (new OrderingToken(
                                OrderingToken.ERROR_INVALID_SEPERATOR,
                                yytext(), yyline, yychar,
                                yychar + yytext().length()));
                        t.setPrevToken(lastToken);
                        lastToken = t;
                        t.type = OrderingToken.TYPE_NUMBER;
                        return (t);
                    }
                case 157:
                    break;
                case 92:
                    {
                        OrderingToken t = (new OrderingToken(
                                OrderingToken.ERROR_INVALID_SEPERATOR,
                                yytext(), yyline, yychar,
                                yychar + yytext().length()));
                        t.setPrevToken(lastToken);
                        lastToken = t;
                        return (t);
                    }
                case 158:
                    break;
                case 46:
                    {
                        OrderingToken t = (new OrderingToken(
                                OrderingToken.ERROR_INVALID_SEPERATOR,
                                yytext(), yyline, yychar,
                                yychar + yytext().length()));
                        t.setPrevToken(lastToken);
                        lastToken = t;
                        return (t);
                    }
                case 159:
                    break;
                case 84:
                    {
                        /* A Hex long cannot be too big.  After removing
                         * initial zeros, It can have 17 digits, the last of which is
                         * the L or l
                         */
                        OrderingToken t = null;
                        int i;
                        int length = yytext().length();
                        for (i = 2; i < length - 17; i++) {
                            //check for initial zeros
                            if (yytext().charAt(i) != '0') {
                                t = (new OrderingToken(
                                        OrderingToken.ERROR_LONG_HEXIDECIMAL_SIZE,
                                        yytext(), yyline, yychar,
                                        yychar + yytext().length()));
                                t.setPrevToken(lastToken);
                                lastToken = t;
                                t.type = OrderingToken.TYPE_NUMBER;
                                return (t);
                            }
                        }
                        if (length - i > 17) {
                            t = (new OrderingToken(
                                    OrderingToken.ERROR_LONG_HEXIDECIMAL_SIZE,
                                    yytext(), yyline, yychar,
                                    yychar + yytext().length()));
                            t.setPrevToken(lastToken);
                            lastToken = t;
                            t.type = OrderingToken.TYPE_NUMBER;
                            return (t);
                        }
                        t = (new OrderingToken(
                                OrderingToken.ERROR_INVALID_SEPERATOR,
                                yytext(), yyline, yychar,
                                yychar + yytext().length()));
                        t.setPrevToken(lastToken);
                        lastToken = t;
                        t.type = OrderingToken.TYPE_NUMBER;
                        return (t);
                    }
                case 160:
                    break;
                default:
                    if (yy_input == YYEOF && yy_startRead == yy_currentPos) {
                        yy_atEOF = true;
                        return null;
                    } else {
                        yy_ScanError(YY_NO_MATCH);
                    }
            }
        }
    }

}
