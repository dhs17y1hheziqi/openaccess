<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"dtd/docbook/docbookx.dtd">
<book>
  <bookinfo>
    <title>Versant Open Access</title>

    <copyright>
      <year>2005</year>

      <holder><ulink url="http://www.versant.com">Versant Corporation</ulink></holder>
    </copyright>

    <releaseinfo>@JDO.VERSION@ (@JDO.VERSION.DATE@)</releaseinfo>
  </bookinfo>

  <chapter id="intro">
    <title>Introduction</title>

    <para>Versant Open Access for JDO (JSR243) and EJB3 persistence (JSR220)
    is a high performance persistence engine for relational databases and
    Versant Object Database. Versant Open Access is now affiliated with the
    Eclipse JSR220-ORM Project. Versant Open Access implements all the
    required features and most of the optional features of version 1.0.1 of
    the JDO specification. Versant Open Access supports managed and unmanaged
    environments and leading relational databases for storage (Sybase, Oracle,
    DB2, MySQL, Postgres, Hypersonic, Pointbase, SAP DB, Informix, Informix
    SE, Interbase, Firebird, Cache and Microsoft SQL Server are all
    supported).</para>

    <para>If you are new to JDO and need to get going quickly read <xref
    linkend="jdo_concepts" /> and then have a look at demos/tut1.</para>

    <para>Versant Open Access links:</para>

    <itemizedlist>
      <listitem>
        <para>Home page: <ulink url="http://www.jdoogenie.com">http//www.versant.com</ulink></para>
      </listitem>

      <listitem>
        <para>New versions: <ulink url="http://www.jdogenie.com/download.html">http://www.versant.com</ulink></para>
      </listitem>

      <listitem>
        <para>Discussion forums: <ulink url="http://forums.versant.com/forums">http://forums.versant.com/forums</ulink></para>
      </listitem>

      <listitem>
        <para>Online HTML manual: <ulink
        url="http://downloads.hemtech.co.za/jdo/manual/">http://downloads.hemtech.co.za/jdo/manual</ulink></para>
      </listitem>

      <listitem>
        <para>Latest PDF manual: <ulink
        url="http://downloads.hemtech.co.za/jdo/manual/manual.pdf">http://downloads.hemtech.co.za/jdo/manual/manual.pdf</ulink></para>
      </listitem>

      <listitem>
        <para>Javadoc: <ulink url="api/index.html">http://downloads.hemtech.co.za/jdo/manual/api/index.html</ulink></para>
      </listitem>
    </itemizedlist>

    <para>Versant Open Access used to be called JDO Genie. If you are
    currently using JDO Genie please read <xref
    linkend="upgrading_from_jdogenie" /> for information on how to upgrade.</para>

    <section id="background">
      <title>JDO Background</title>

      <para>The Java Data Objects (JDO) specification was developed under the
      Java Community Process as JSR-000012 with Craig Russell from Sun
      Microsystems as the specification lead. Work started in 1999 and
      <indexterm><primary>JDO specification</primary></indexterm>version 1.0
      was released in May 2002. JDO 1.0.1 (a maintenance update) was released
      in September 2003. Our product, Versant Open Access, is a high
      performance JDO implementation for relational databases. Versant Open
      Access implements all the required features and most of the optional
      features of version 1.0.1 of the specification.</para>

      <para>JDO provides for transparent persistence for Java objects with an
      API that is independent of the underlying data store. There are no
      special interfaces to implement and it is easy to persist plain old Java
      classes. The query language (JDOQL) uses a Java like syntax so
      developers only have to know Java. These features provide improved
      developer productivity and portability across data stores and JDO
      implementations.</para>

      <para>The JDO specification supports different deployment environments
      with a common API. An implementation may support managed (i.e.
      application server) deployment and unmanaged (i.e. 2 tier) deployment or
      both. Another implementation might be designed for a small footprint
      environments such as a cellular phone or PDA. The developer API remains
      the same in all cases.</para>
    </section>

    <section id="jdo_and_jdbc">
      <title>JDO and JDBC<indexterm><primary>JDBC</primary></indexterm></title>

      <para>JDBC (Java Database Connectivity) is a low level technology used
      by Java classes to communicate with relational databases. Most JDO
      implementations for relational databases will use JDBC to communicate
      with the database. Using JDBC directly from a Java application has many
      disadvantages when compared to using JDO. <itemizedlist><title>JDBC
      Disadvantages</title><listitem><para>Only JDBC compliant (relational)
      databases can be used.</para></listitem><listitem><para>The best people
      on the project spend their time writing the persistence code.</para></listitem><listitem><para>Good
      SQL skills are required.</para></listitem><listitem><para>SQL is not
      portable between database vendors.</para></listitem></itemizedlist></para>
    </section>

    <section id="directory_structure">
      <title>Distribution Directory Structure<indexterm><primary>directory
      structure</primary></indexterm></title>

      <para>The Versant Open Access directory structure is described by the
      following table. Note that you need to put your <filename>openaccess.license</filename>
      file in the <filename>license</filename> directory to activate Versant
      Open Access. If you do not have a license you can get a full featured
      free evaluation license from <ulink
      url="http://www.jdogenie.com/download.html">http://www.jdogenie.com/download.html</ulink>.</para>

      <table>
        <title>Distribution Directory Structure</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Directory</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><filename>bin</filename></entry>

              <entry>Batch file and script to launch the Workbench and
              Hypersonic database for the demos.</entry>
            </row>

            <row>
              <entry><filename>docs</filename></entry>

              <entry>Manual in HTML and PDF.</entry>
            </row>

            <row>
              <entry><filename>docs/api</filename></entry>

              <entry>Javadoc API documentation for javax.jdo packages and
              Versant Open Access extensions.</entry>
            </row>

            <row>
              <entry><filename>lib</filename></entry>

              <entry>Redistributable Versant Open Access runtime jars.</entry>
            </row>

            <row>
              <entry><filename>tools</filename></entry>

              <entry>Non-distributable tools jars.</entry>
            </row>

            <row>
              <entry><filename>src</filename></entry>

              <entry>Source code for classes used to extend Versant Open
              Access.</entry>
            </row>

            <row>
              <entry><filename>license</filename></entry>

              <entry>Put your <filename>openaccess.license</filename> file
              here.</entry>
            </row>

            <row>
              <entry><filename>ant</filename></entry>

              <entry>Stripped down Apache Ant 1.5 (minimal configuration).</entry>
            </row>

            <row>
              <entry><filename>plugins/eclipse</filename></entry>

              <entry>Plugin for Eclipse 2 and 3.</entry>
            </row>

            <row>
              <entry><filename>plugins/eclipseTools</filename></entry>

              <entry>Tools plugin for editing mapping in Eclipse 3.0 and 3.1.</entry>
            </row>

            <row>
              <entry><filename>plugins/WASD</filename></entry>

              <entry>Plugin for WASD 5.1.2.</entry>
            </row>

            <row>
              <entry><filename>jca</filename></entry>

              <entry>JCA adapter for EJB applications.</entry>
            </row>

            <row>
              <entry><filename>templates/newProject</filename></entry>

              <entry>Velocity templates for the Workbench new project wizard.</entry>
            </row>

            <row>
              <entry><filename>demos</filename></entry>

              <entry>Demonstration applications.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section id="acknowledgements">
      <title>Acknowledgements</title>

      <para>Versant Open Access would not have been possible without the work
      of the JDO expert group (JSR00012).</para>

      <para>This product uses software developed by the Apache Software
      Foundation (http://www.apache.org). See docs/LICENSE_APACHE.txt for
      details.</para>

      <para>This product uses software developed by the JDOM Project
      (http://www.jdom.org/). See LICENSE_JDOM.txt in the Versant Open Access
      distribution for details.</para>

      <para>This product uses the Alloy Look and Feel from Incors
      (http://www.incors.com).</para>

      <para>This product uses the BeanShell Java interpreter
      (http://www.beanshell.org). This is distributed under the GNU Lesser
      Public License (http://www.gnu.org/licenses/lgpl.html) and the Sun
      Public License (http://www.sun.com/developers/spl.html).</para>

      <para>This product uses the JGraph Java graph component
      (http://www.jgraph.org). This is distributed under the GNU Lesser Public
      License (http://www.gnu.org/licenses/lgpl.html).</para>

      <para>This product uses the JFreeChart Java charting component
      (http://www.jfree.org/jfreechart). This is distributed under the GNU
      Lesser Public License (http://www.gnu.org/licenses/lgpl.html).</para>

      <para>This product includes the Hypersonic SQL embedded Java database.
      Please see docs/LICENSE_HYPERSONIC.txt in the Versant Open Access
      distribution for license details.</para>

      <para>This product includes a modified version of the Pizza compiler.
      Please see docs/LICENSE_pizza.txt for license details. The full source
      code for the version of Pizza used in this product is available here:
      http://downloads.hemtech.co.za/jdo/versant-pizza.zip</para>
    </section>
  </chapter>

  <chapter id="jdo_concepts">
    <title>JDO Concepts</title>

    <para>This chapter provides an overview of all the main JDO concepts. It
    provides background information essential to making Versant Open Access
    work well. You should also read one or two of the JDO books:</para>

    <para>Core Java Data Objects by Sameer Tyagi, Michael Vorburger, Keiron
    McCammon, Heiko Bobzin Prentice Hall PTR/Sun Microsystems Press ISBN:
    0-13-140731-7 256 pages, US $49.99</para>

    <para>Java Data Objects by David Jordan and Craig Russell O&#39;Reilly
    &#38; Associates, Inc. ISBN: 0-596-00276-9 384 pages, US $39.95</para>

    <para>Java Data Objects by Robin M. Roos Addison-Wesley Professional ISBN:
    0-321-12380-8 272 pages, US $39.99</para>

    <para>Using and Understanding Java Data Objects by David Ezzio Apress
    ISBN: 1-59059-043-0 312 pages, US $44.99</para>

    <section id="the_pmf">
      <title>The PersistenceManagerFactory<indexterm><primary>PersistenceManagerFactory</primary></indexterm></title>

      <para>A <classname>javax.jdo.PersistenceManagerFactory</classname> (PMF)
      is analogous to a JDBC driver. It is a factory for
      <classname>javax.jdo.PersistenceManager</classname>&#39;s (PM&#39;s)
      which are similar to JDBC connections. Versant Open Access supports
      several runtime environments. In all cases the same
      <filename>.jdogenie</filename> properties file defines the configuration
      of the Versant Open Access engine, the PMF and the initial configuration
      of PM&#39;s created by it. All options can be configured using the
      Workbench.</para>
    </section>

    <section id="the_pm">
      <title>PersistenceManager&#39;s<indexterm><primary>PersistenceManager</primary></indexterm></title>

      <para>The <classname>javax.jdo.PersistenceManager</classname> interface
      defines most of the JDO developer API. It contains methods for
      persisting objects, deleting objects, creating queries, looking up
      objects by ID, transaction control and cache management.
      PersistenceManager&#39;s (PM&#39;s) are created from a
      PersistenceManagerFactory (PMF) just like JDBC connections are created
      from a JDBC driver. In Versant Open Access a PM is a lightweight object
      that does not consume many resources. However when a transaction is
      active the PM must maintain a reference to every JDO instance involved
      in the transaction. It is only associated with a database connection
      during commit or when pessimistic locking is used.</para>
    </section>

    <section id="persistence_capable_classes">
      <title>Persistence Capable Classes<indexterm><primary>Persistence
      Capable</primary></indexterm></title>

      <para>Any Java class whose state is entirely represented by the state of
      its Java fields may be persisted if it is enhanced or written to
      implement the <literal>javax.jdo.PersistenceCapable</literal> interface.
      This means that system classes such as <literal>Thread</literal> or
      <literal>Socket</literal> cannot be persisted but normal application
      defined classes can. It is not normally necessary to implement
      javax.jdo.PersistenceCapable as the JDO vendor is required to supply a
      bytecode enhancer to modify the class files after compilation so that
      they implement this interface. Classes without no-arg constructors
      cannot be persisted. Instances of persistence-capable classes managed by
      JDO (i.e. that have been persisted) are called <indexterm><primary>JDO
      instances</primary></indexterm>JDO instances.</para>
    </section>

    <section id="xml_meta_data">
      <title>XML Meta Data<indexterm><primary>JDO meta data</primary></indexterm></title>

      <para>XML meta data is used to provide information about persistent
      classes and their fields to the JDO implementation that is not available
      from the class files. The only meta data that is required by the
      specification is the name of each persistent class. The meta data is
      stored in <filename>.jdo</filename> files that must be available on the
      classpath at enhancement time (compile) and runtime. Implementations for
      relational databases will normally require additional information for
      some fields to help generate the database schema (e.g. the type of
      object stored in a list). Versant Open Access includes a
      <indexterm><primary>Workbench</primary></indexterm>unique GUI tool
      called the Versant Open Access Workbench. The workbench makes it very
      easy to edit meta data, run JDO queries, regenerate and migrate database
      schema&#39;s and perform many other tasks. You do not have to edit XML
      meta data by hand with Versant Open Access.</para>
    </section>

    <section id="supported_field_types">
      <title>Supported Field Types<indexterm><primary>supported field types</primary></indexterm></title>

      <para>A compliant JDO implementation is required to support all the
      field types commonly used in Java classes. How these types are mapped to
      the underlying data store is not defined in the specification and is
      controlled by vendor specific extensions in the meta data. For example
      Versant Open Access maps String fields to VARCHAR(255) columns by
      default. If you need to store more than 255 characters you can specify a
      CLOB column using the Versant Open Access Workbench. This will be mapped
      to an SQL type appropriate to the database server in use.</para>

      <table>
        <title>Versant Open Access Supported Field Types</title>

        <tgroup cols="3">
          <thead>
            <row>
              <entry>Java type</entry>

              <entry>Req. by spec</entry>

              <entry>Versant Open Access notes</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>Primitives (boolean, byte, short, int, long, char, float,
              double)</entry>

              <entry>Yes</entry>

              <entry>Float and double may lose precision.</entry>
            </row>

            <row>
              <entry>Wrappers (Boolean, Byte, Short, Integer, Long, Character,
              Float, Double)</entry>

              <entry>Yes</entry>

              <entry>Float and Double may lose precision.</entry>
            </row>

            <row>
              <entry>java.lang.String</entry>

              <entry>Yes</entry>

              <entry>Limited to 255 characters by default.</entry>
            </row>

            <row>
              <entry>java.util.Locale</entry>

              <entry>Yes</entry>

              <entry></entry>
            </row>

            <row>
              <entry>java.math.BigDecimal and BigInteger</entry>

              <entry>Yes</entry>

              <entry></entry>
            </row>

            <row>
              <entry>java.util.Date</entry>

              <entry>Yes</entry>

              <entry>Precision depends on the database.</entry>
            </row>

            <row>
              <entry>java.util.HashSet</entry>

              <entry>Yes</entry>

              <entry></entry>
            </row>

            <row>
              <entry>java.util.TreeSet</entry>

              <entry>Optional</entry>

              <entry>Stateless Comparator&#39;s supported.</entry>
            </row>

            <row>
              <entry>java.util.ArrayList</entry>

              <entry>Optional</entry>

              <entry></entry>
            </row>

            <row>
              <entry>java.util.Vector</entry>

              <entry>Optional</entry>

              <entry></entry>
            </row>

            <row>
              <entry>java.util.HashMap</entry>

              <entry>Optional</entry>

              <entry></entry>
            </row>

            <row>
              <entry>java.util.TreeMap</entry>

              <entry>Optional</entry>

              <entry>Stateless Comparator&#39;s supported.</entry>
            </row>

            <row>
              <entry>java.util.Hashtable</entry>

              <entry>Optional</entry>

              <entry></entry>
            </row>

            <row>
              <entry>java.util.Collection</entry>

              <entry>Yes</entry>

              <entry></entry>
            </row>

            <row>
              <entry>java.util.Set</entry>

              <entry>Yes</entry>

              <entry></entry>
            </row>

            <row>
              <entry>java.util.List</entry>

              <entry>Optional</entry>

              <entry></entry>
            </row>

            <row>
              <entry>java.util.Map</entry>

              <entry>Optional</entry>

              <entry></entry>
            </row>

            <row>
              <entry>java.util.LinkedList</entry>

              <entry>Optional</entry>

              <entry></entry>
            </row>

            <row>
              <entry>java.util.SortedSet</entry>

              <entry>Optional</entry>

              <entry></entry>
            </row>

            <row>
              <entry>java.util.SortedMap</entry>

              <entry>Optional</entry>

              <entry></entry>
            </row>

            <row>
              <entry>java.lang.Object</entry>

              <entry>Optional</entry>

              <entry>Reference to any persistent class.</entry>
            </row>

            <row>
              <entry>&#60;interface&#62;</entry>

              <entry>Optional</entry>

              <entry>Reference to any persistent class implementing the
              interface.</entry>
            </row>

            <row>
              <entry>Primitive arrays (boolean[], byte[], short[], int[],
              long[], char[], float[], double[])</entry>

              <entry>Optional</entry>

              <entry>Stored in a BLOB/IMAGE column.</entry>
            </row>

            <row>
              <entry>Other arrays (Integer[], String[], Locale[], PC[] etc.)</entry>

              <entry>Optional</entry>

              <entry>Stored in link or join table.</entry>
            </row>

            <row>
              <entry>java.io.File</entry>

              <entry>No (extension)</entry>

              <entry>Disabled by default.</entry>
            </row>

            <row>
              <entry>java.net.URL</entry>

              <entry>No (extension)</entry>

              <entry>Disabled by default.</entry>
            </row>

            <row>
              <entry>java.sql.Timestamp</entry>

              <entry>No (extension)</entry>

              <entry>Disabled by default.</entry>
            </row>

            <row>
              <entry>Arrays of custom types (File[], user defined etc.)</entry>

              <entry>No (extension)</entry>

              <entry>Stored in link or join table.</entry>
            </row>

            <row>
              <entry>&#60;any custom type&#62;</entry>

              <entry>No (extension)</entry>

              <entry>Type must be added using the Workbench. Mapped to a
              single column.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The various Java collection types (<literal>java.util.List</literal>
      and so on) may contain any type of Object. When used with a relational
      database Versant Open Access requires that the type of object to be
      stored in the collection be specified in the meta data to generate a
      good database schema (unless you are using JDK 1.5 generics, see <xref
      linkend="generics" />). A future version of Versant Open Access will
      support collections and arrays of Objects and interface types mapped the
      same way as Object and interface references (see <xref
      linkend="mapping_interface_field" />).</para>

      <para>It is easy to make any class a persistent field type by adding it
      to the project externalized types in the Workbench (see <xref
      linkend="externalized_types" />). All fields of these types and
      corresponding arrays[] will then be considered persistent and non-array
      fields will be in the default fetch group (just like <literal>java.lang.String</literal>).
      Changes to fields within externalized types are not tracked so values of
      externalized types should be treated as immutable (i.e. set a new
      instance instead of changing the internal state of the existing
      instance). If you do change the internal state of a externalized type
      you can call <literal>JDOHelper.makeDirty(Object pc,String fieldname)</literal>
      so that the change will be persisted.</para>

      <para>You can also choose to externalize references, Collection&#39;s
      and Map to store them in a single column. By default this is done using
      Java Serialization but other Externalizers are supplied (see <xref
      linkend="externalized_types" />) and you can write your own (see <xref
      linkend="writing_externalizers" />).</para>

      <para>When working with JDBC direct interaction with ResultSet&#39;s and
      PreparedStatement&#39;s may be necessary for some types. This can be
      achieved using JDBC custom type mappings and JdbcConverter&#39;s (see
      <xref linkend="custom_type_mappings" />).</para>

      <para>For JDBC Versant Open Access has extended the default JDO
      persistent types with <literal>java.io.File</literal>,
      <literal>java.net.URL</literal> and <literal>java.sql.Timestamp</literal>.
      This support will be extended to Versant ODBMS in future. To maintain
      portability with other JDO implementations fields of these types are not
      persistent by default. You need to specifically enable them in the
      Workbench (<command>File | Datastore Properties, Java Type Mappings tab</command>).
      Change the enabled column to true for the types you want to enable. All
      fields of these types will then be considered persistent and will be in
      the default fetch group (just like <literal>java.lang.String</literal>).</para>

      <para>Changes to fields in <literal>java.sql.Timestamp</literal>
      instances are not automatically tracked (unlike <literal>java.util.Date</literal>).
      You should treat <literal>java.sql.Timestamp</literal> values as
      immutable in your application (i.e. set a new value on a Timestamp field
      instead of changing the existing instance) or call <literal>JDOHelper.makeDirty(Object
      pc,String fieldname)</literal>. A future Versant Open Access release
      will have full SCO (second class object) support for <literal>java.sql.Timestamp</literal>.</para>
    </section>

    <section id="object_identity">
      <title>Object Identity<indexterm><primary>identity</primary></indexterm></title>

      <para id="datastore_identity">Versant Open Access supports application
      and <indexterm><primary>datastore identity</primary></indexterm>datastore
      identity as defined by the JDO specification. With datastore identity
      the primary key for an instance is defined and controlled by Versant
      Open Access. It is not visible as a field in the class and is
      automatically generated for new instances. You can specify how the key
      is generated in the meta data using the Workbench. Versant Open Access
      supports the HIGH/LOW algorithm (tablename/lastusedno lookup) and user
      defined key generator classes (see <xref linkend="md_jdbc_key_generator" />).</para>

      <para id="application_identity"><indexterm><primary>application identity</primary></indexterm>With
      application identity the primary key is defined by one or more primary
      key fields in the persistent capable class. In addition an
      objectid-class containing public fields with the same names as the
      primary key fields in the persistent capable class must be defined and
      specified in the meta data. Normally the developer is responsible for
      generating and setting the primary key for new instances. However
      Versant Open Access allows a key generator to be configured in the meta
      data for application identity classes. If you use this feature the
      primary key is generated by Versant Open Access in the same way as for
      datastore identity but it is visible in the primary key fields of
      instances.</para>

      <para id="objectid_class">A future release of Versant Open Access will
      have an Ant task to generate Object ID classes. The objectid-class must:</para>

      <itemizedlist>
        <listitem>
          <para>Have public fields with the same names and types as the
          primary key fields of the persistent class.</para>
        </listitem>

        <listitem>
          <para>Have a no-arg constructor.</para>
        </listitem>

        <listitem>
          <para>Be serializeable.</para>
        </listitem>

        <listitem>
          <para>Have a constructor that accepts a String created by calling
          the toString method.</para>
        </listitem>

        <listitem>
          <para>Must implement equals and hashcode to use all the primary key
          fields.</para>
        </listitem>
      </itemizedlist>

      <para>Normally you should use datastore identity. If you have to map to
      a legacy database and work with primary keys directly then use
      application identity. The following methods from PersistenceManager are
      useful when working with object IDs:</para>

      <itemizedlist>
        <listitem>
          <para><classname>public Object getObjectById(Object oid, boolean
          validate)</classname></para>

          <para>Lookup an instance by its JDO identity. The oid may be
          constructed by the application (e.g. if using application identity)
          or returned by getObjectId or newObjectIdInstance. If the object
          exists in the local PM cache it is immediately returned (e.g. it has
          already been touched in the current transaction). If it is not in
          the local cache and validate is true then its default fetch group is
          read from the database. If validate is false then a hollow instance
          is created. As soon as you touch any fields they will be fetched
          from the database. If the instance does not exist a JDOUserException
          is thrown (only when accessed if validate is false).</para>

          <para>Versant Open Access supports a server wide cache shared by all
          PersistenceManagers. This cache is keyed by OID so if the object is
          not in the local cache of the PM it may still be retrieved from the
          shared cache and database access avoided.</para>
        </listitem>

        <listitem>
          <para><classname>public Object getObjectId(Object pc)</classname></para>

          <para>The ObjectId returned by this method represents the JDO
          identity of the instance. The ObjectId is a copy (clone) of the
          internal state of the instance, and changing it does not affect the
          JDO identity of the instance.</para>
        </listitem>

        <listitem>
          <para><classname>public Object newObjectIdInstance(Class aClass,
          String s)</classname></para>

          <para>This method returns an object id instance corresponding to the
          Class and String arguments. The String argument might have been the
          result of executing toString on an object id instance.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section id="inheritance">
      <title>Inheritance<indexterm><primary>inheritance</primary></indexterm></title>

      <para>JDO supports inheritance. A class may be persistence-capable even
      if it extends a class that is not or cannot be persistence-capable (e.g.
      <literal>java.net.Socket</literal>). Inherited fields may not be
      persisted i.e. all the fields to be persisted must be declared in a
      persistence-capable class. Inheritance relationships must be explicitly
      declared in the meta data or the classes will be persisted separately.
      If application identity is used all classes in a hierarchy must use the
      same identity and the primary key field(s) must all be declared in the
      topmost class. Versant Open Access implements inheritance by putting all
      classes in one table and adding a <literal>jdo_class</literal> column to
      identify each row.</para>
    </section>

    <section id="bytecode_enhancement">
      <title>Bytecode Enhancement<indexterm><primary>bytecode enhancement</primary></indexterm></title>

      <para>All classes to be persisted that do not implement the
      <literal>javax.jdo.PersistenceCapable</literal> interface must be
      enhanced before being used by JDO. The enhancement process modifies the
      classes to implement the javax.jdo.PersistenceCapable interface and
      provides hooks used by the JDO runtime. The runtime hooks allow JDO to
      control all field access. This makes it possible to fetch field values
      from the database as they are required and to automatically track any
      changes made to an instance. The JDO specification defines exactly how
      enhancement is done and JDO implementations must be able to work with
      classes enhanced by a different implementation.</para>
    </section>

    <section id="jdo_genie_project_file">
      <title>Versant Open Access Project File<indexterm><primary>project file</primary></indexterm><indexterm><primary>jdogenie
      file</primary></indexterm></title>

      <para>Specification compliant JDO implementations must be able to start
      from a properties file. The specification defines some of the possible
      properties and implementations are free to add their own. Versant Open
      Access uses this properties file to define all the information required
      by the runtime that is not defined in the JDO meta data. These
      properties include database URLs and connection pool settings. In
      addition the Versant Open Access Workbench uses this file as a project
      file (similar to an IDE) and provides dialogs to edit it. Versant Open
      Access property files normally have a <literal>.properties</literal>
      extension.</para>
    </section>

    <section id="generating_database_schema">
      <title>Generating the Database Schema<indexterm><primary>database schema</primary></indexterm></title>

      <para>Versant Open Access provides an Ant<footnote id="ant"><para>Ant is
      an excellent open source Java build tool from <ulink
      url="http://jakarta.apache.org/ant/">jakarta.apache.org</ulink>.</para></footnote>
      task to generate the database schema for a set of persistence-capable
      classes and meta data. This can also be done from the Workbench. The
      schema generation process uses information from the class files and the
      JDO meta data to create a suitable database schema. The tool always
      creates a SQL script for each physical store and optionally will drop
      and recreate all tables in the schema. A typical Ant project using
      Versant Open Access will have a target that recreates the database and
      runs a class to persist development data. This makes it very quick and
      easy to make model changes during development.</para>
    </section>

    <section id="jdo_genie_project_file">
      <title>JDO 2 Lifecycle Listeners<indexterm><primary>jdo 2 lifecycle
      listeners</primary></indexterm><indexterm><primary>lifecycle listeners</primary></indexterm></title>

      <para>Versant Open Access supports lifecycle listener classes as defined
      in the May 2005 public draft of the JDO 2 specification. These provide
      superior functionality to JDO 1 instance callbacks and the code does not
      have to be in the persistent class. In addition listeners can be added
      globally using methods on PersistenceManagerFactory.</para>
    </section>

    <section id="jdo_genie_project_file">
      <title>JDO 2 Single Field Identity<indexterm><primary>jdo 2 single field
      identity</primary></indexterm><indexterm><primary>single field identity</primary></indexterm></title>

      <para>Versant Open Access supports single field identity as defined in
      the May 2005 public draft of the JDO 2 specification. This is a very
      convenient feature for classes using application identity that have only
      one primary key field. No objectid-class is required in this case.</para>
    </section>
  </chapter>

  <chapter id="ejb3_persistance">
    <title>EJB3 Persistence<indexterm><primary>EJB3 Persistence</primary></indexterm></title>

    <para>This chapter provides an overview of the main EJB3 persistence
    (JSR220) concepts. EJB3 persistence requires J2SE 1.5 or higher. The EJB3
    persistence support in Open Access is alpha level as the spec is still
    under development.</para>

    <itemizedlist>
      <title>EJB3 Features</title>

      <listitem>
        <para>Use the EJB 3 persistence (JSR220) and JDO API (JSR243) in the
        same application.</para>
      </listitem>

      <listitem>
        <para>Persistent classes may be JDO POJO&#39;s or EJB 3 entities and
        may be mixed in the same model (they can reference each other etc.).</para>
      </listitem>

      <listitem>
        <para>Eclipse Plugin with live visual mapping editor.</para>
      </listitem>
    </itemizedlist>

    <itemizedlist>
      <title>Current EJB3 Limitations</title>

      <listitem>
        <para>Limited implementation of EJBQL.</para>
      </listitem>

      <listitem>
        <para>Limited annotation processing.</para>
      </listitem>

      <listitem>
        <para>Tools only edit meta data stored in XML and do not edit source
        code. The Eclipse JSR220ORM project will solve this issue.</para>
      </listitem>

      <listitem>
        <para>Composite primary keys are not supported.</para>
      </listitem>
    </itemizedlist>

    <para>We are putting a lot of resources into our EJB 3 effort to address
    these limitations. We have added a very simple EJB3 demo, showing basic
    functionality in <filename>demos/ejb3</filename>.</para>

    <section id="entity_manager_factory">
      <title>The EntityManagerFactory<indexterm><primary>EntityManagerFactory</primary></indexterm></title>

      <para>A <classname>javax.persistence.EntityManagerFactory</classname>
      (EMF) is analogous to a JDBC driver. It is a factory for
      <classname>javax.persistence.EntityManager</classname>&#39;s (EM&#39;s)
      which are similar to JDBC connections. Versant Open Access supports
      several runtime environments. In all cases the same
      <filename>*.properties</filename> properties file defines the
      configuration of the Versant Open Access engine, the EMF and the initial
      configuration of EM&#39;s created by it. All options can be configured
      using the Workbench and source code annotations.</para>

      <section id="obtaining_emf">
        <title>Obtaining an EntityManagerFactory<indexterm><primary>getting an
        emf</primary></indexterm></title>

        <para>In the current release an EntityManagerFactory is obtained from
        a JDO PersistenceManagerFactory as shown in the code fragment below:</para>

        <programlisting>import javax.persistence.EntityManagerFactory;
import com.versant.core.jdo.VersantPersistenceManagerFactory;

...
VersantPersistenceManagerFactory pmf = ...
EntityManagerFactory emf = (EntityManagerFactory)pmf.getEntityManagerFactory();
...</programlisting>

        <para>We will support persistence archive (.par) files and the
        persistence.xml descriptor in a future release.</para>
      </section>

      <section id="ejb3_annotations">
        <title>Annotations<indexterm><primary>annotations</primary></indexterm></title>

        <para>EJB 3 persistence annotations are read if present in the .class
        files. Here is an example from <filename>demos/ejb3</filename>:</para>

        <programlisting>import javax.persistence.*;
...
@Entity(access = AccessType.FIELD)
@Table(name = &#34;ADDRESS&#34;)
public class Address implements java.io.Serializable {

    @Id(generate = GeneratorType.TABLE, generator = &#34;HIGHLOW&#34;)
    @Column(name = &#34;GEN_ID&#34;)
    private int generatedId; 
...</programlisting>

        <para>You still need to list the persistent classes in a .jdo meta
        data file:</para>

        <programlisting>&#60;jdo&#62;
    &#60;package name=&#34;ejb3.model&#34;&#62;
        &#60;class name=&#34;Address&#34; /&#62;
        &#60;class name=&#34;Employee&#34;/&#62;
    &#60;/package&#62;
&#60;/jdo&#62;</programlisting>
      </section>
    </section>

    <section id="entity_manager">
      <title>EntityManager&#39;s<indexterm><primary>EntityManager</primary></indexterm></title>

      <para>The <classname>javax.persistence.EntityManager</classname>
      interface defines most of the EJB3 persistence developer API. It
      contains methods for persisting objects, deleting objects, creating
      queries, looking up objects by ID, transaction control and cache
      management. EntityManager&#39;s (EM&#39;s) are created from a
      EntityManagerFactory (EMF) just like JDBC connections are created from a
      JDBC driver. In Versant Open Access a EM is a lightweight object that
      does not consume many resources. However when a transaction is active
      the EM must maintain a reference to every persistence instance involved
      in the transaction.</para>

      <section id="obtaining_em">
        <title>Obtaining a EntityManager<indexterm><primary>obtaining an
        EntityManager</primary></indexterm></title>

        <para>An EntityManager is obtained from an EntityManagerFactory as
        shown below:</para>

        <programlisting>import javax.persistence.EntityManagerFactory;
import javax.persistence.EntityManager;
...
EntityManagerFactory emf = ...
EntityManager em = emf.getEntityManager();</programlisting>
      </section>

      <section id="using_em">
        <title>Using a EntityManager<indexterm><primary>using an EntityManager</primary></indexterm></title>

        <para>The EntityManager are used for starting and ending transactions
        (In a unmanaged environment), persisting and removing objects and
        querying.</para>

        <para>Some example code fragments are shown below but please also look
        at <filename>demos/ejb3</filename>.</para>

        <programlisting>import javax.persistence.EntityManager;
...
EntityManager em = getEMF().getEntityManager();

// persisting a Object
Employee employee = new Employee();
employee.setEmpNo(55);

em.getTransaction().begin();
em.persist(employee);
em.getTransaction().commit();

// finding a persistent Object
em.getTransaction().begin();
Employee employee = em.find(Employee.class, 55);
employee.setSal(444);
em.getTransaction().commit();

// removing a persistent Object
em.getTransaction().begin();
em.remove(em.find(Employee.class, 55));
em.getTransaction().commit();

// querying for persistent Objects
em.getTransaction().begin();
Query q = em.createQuery(&#34;SELECT o FROM Address o where o.street = ?1&#34;);
q.setParameter(0, &#34;bla&#34;);
List result = q.getResultList();
em.getTransaction().commit();</programlisting>
      </section>
    </section>
  </chapter>

  <chapter id="workbench_guide">
    <title>Workbench Overview</title>

    <para>The Versant Open Access Workbench is a powerful IDE for mapping your
    classes, reverse engineering classes from tables, monitoring Versant Open
    Access servers and running JDOQL queries. To run JDOQL queries a Versant
    Open Access server is started inside of the Workbench. The Workbench works
    in a similar way to a normal IDE: you edit meta data for your classes,
    compile the meta data, build the JDBC schema and run the Versant Open
    Access server.</para>

    <para>Most fields in the Workbench have tooltips. The tooltips displayed
    on a yellow background are extracted from the manual. Pressing
    <command>Shift-F1</command> will open the manual in your browser
    positioned at the relevant information for the last displayed tooltip.
    Pressing <command>F1</command> on most fields will also open the manual
    and display help for the field.</para>

    <tip>
      <para>Pressing <command>Shift-F1</command> will open the manual in your
      browser positioned at the relevant information for the last displayed
      tooltip.</para>
    </tip>

    <para>Values displayed in workbench fields are shown in blue if they have
    been edited (i.e. changed from the default setting). Most drop downs have
    a default button at the end of the list. If the default is selected then
    the default value for the field is restored.</para>

    <section id="projects_and_datastores">
      <title>Projects<indexterm><primary>projects</primary></indexterm></title>

      <para>The Workbench and Ant tasks use the properties file used to start
      a Versant Open Access server as a project file (<filename>.properties</filename>
      extension). This file contains the database connection properties, the
      configuration of the Versant Open Access Server, default meta data
      settings, the classpath for the project and so on. You can edit this by
      hand but it is usually easier to use the Workbench. Only one project may
      be open at a time (<command>File | Open Project</command>). You can edit
      project wide settings using <command>File | Project &#38; Datastore
      Properties</command>.</para>

      <para><inlinemediaobject><imageobject><imagedata
      fileref="images/project_properties_general.png" /></imageobject></inlinemediaobject></para>

      <para>The search box on the top right hand corner will search all of the
      tabs on the tree for a field labeled with part of the entered text.
      Press F3 to move from one match to the next. Press enter to move the
      focus to the current matching field. For example if you enter
      &#34;drive&#34; in the box F3 will cycle between &#34;Hyperdrive
      classes&#34; on the Project tab and &#34;JDBC driver class&#34; on
      Datastore tab.</para>
    </section>

    <section id="classes_and_meta_data">
      <title>Classes and Meta Data<indexterm><primary>classes</primary></indexterm><indexterm><primary>reloading
      classes</primary></indexterm></title>

      <para>The workbench needs to load and analyze your persistent classes.
      For this reason you should have classes compiled when using the
      Workbench. If you make changes and recompile your classes outside of the
      Workbench (e.g. using an IDE or Ant) then they need to be reloaded. The
      Workbench will automatically reload your classes when it is activated or
      you can choose <command>File | Reload Classes</command> to reload them
      manually.</para>

      <para>The workbench also parses your .jdo meta data (mappings) in the
      background. If there are errors in the meta data then the
      <command>compile meta data</command> icon on the toolbar in the graphic
      below goes red. You can click the icon to open a wizard with the error
      message and help on how to fix the problem.</para>

      <para><inlinemediaobject><imageobject><imagedata
      fileref="images/workbench_toolbar.png" /></imageobject></inlinemediaobject></para>
    </section>

    <section id="workbench_views">
      <title>Views<indexterm><primary>views</primary></indexterm></title>

      <para>The toolbar down the left hand side of the Workbench selects
      different views of your classes and actives other functionality (e.g.
      developing JDOQL queries). The buttons on the toolbar depend on the
      selected view.</para>

      <para><inlinemediaobject><imageobject><imagedata
      fileref="images/workbench_views.png" /></imageobject></inlinemediaobject></para>

      <section id="tree_view">
        <title>Tree View<indexterm><primary>tree view</primary></indexterm><indexterm><primary>workbench
        tree view</primary></indexterm></title>

        <para>The tree view is the easiest way to edit your persistent class
        mappings. The tree on the left shows persistent classes, interfaces
        and fields. A form to edit the selected node is displayed on the
        right. Classes and fields with meta data errors have red indicators on
        the tree.</para>

        <para><inlinemediaobject><imageobject><imagedata
        fileref="images/mapping_map_link_table.png" /></imageobject></inlinemediaobject></para>
      </section>

      <section id="diagrams_view">
        <title>Diagrams View<indexterm><primary>diagrams view</primary></indexterm><indexterm><primary>workbench
        diagrams view</primary></indexterm></title>

        <para>You can create diagrams to represent your model. These diagrams
        are similar to UML class diagrams but reflect extra information
        available in the JDO meta data (e.g. one-to-many and many-to-many
        relationships, table names, column names, cache settings etc.).</para>

        <para><inlinemediaobject><imageobject><imagedata
        fileref="images/diagram_view.png" /></imageobject></inlinemediaobject></para>

        <para>You can edit meta data for classes and fields on the diagram by
        double clicking or using the toolbar and right click menu. The lines
        between classes and fields are automatically routed. You may need to
        refresh the diagram after making changes to classes by clicking the
        refresh icon.</para>
      </section>

      <section id="grid_view">
        <title>Grid View<indexterm><primary>grid view</primary></indexterm><indexterm><primary>workbench
        grid view</primary></indexterm></title>

        <para>This is an advanced view of the mapping with classes displayed
        on one grid and fields on another. You can click on the column headers
        to sort (e.g. to sort all fields by type for example) and use the
        fields on the toolbar to filter.</para>

        <para><inlinemediaobject><imageobject><imagedata
        fileref="images/grid_view.png" /></imageobject></inlinemediaobject></para>

        <para>Versant Open Access supports different column mappings for
        different databases in the same meta data files. The mappings drop
        down selects the database type that mappings are being viewed and
        edited for (Sybase, Oracle, Informix etc.) or &#34;all&#34; for all
        databases (default mappings). This selection applies to all dialogs
        and windows opened for the datastore. When &#34;all&#34; is selected
        column properties are displayed for the database type in the datastore
        connection properties.</para>
      </section>

      <section id="view_schema_window">
        <title>Schema View<indexterm><primary>view schema view</primary></indexterm><indexterm><primary>workbench
        view schema view</primary></indexterm></title>

        <para>This view displays the database create script for the project.
        There are buttons to drop and recreate tables, to update the database
        schema for changes to the model (migrate schema) and to copy a
        database from one server to another (even between different servers
        e.g. Oracle to MySQL). The displayed create script does not
        automatically update for changes to the meta data. You need to click
        the refresh button to update it.</para>

        <para><inlinemediaobject><imageobject><imagedata
        fileref="images/schema_view.png" /></imageobject></inlinemediaobject></para>

        <section id="copy_database_dialog">
          <title>Copy Database Dialog<indexterm><primary>copy database dialog</primary></indexterm></title>

          <para>The <command>copy database</command> button displays a dialog
          to copy the database for the project to a new URL. Each table in the
          database is copied to the destination URL. <emphasis>The destination
          can be a different database on a different server</emphasis>. Only
          tables and columns mapped to Versant Open Access classes and fields
          are copied. Example: You can use this to copy an Informix database
          to an Oracle database. Note that there is also an Ant task to copy a
          database (see <xref linkend="task_jdo_copy_db" />).</para>

          <para><inlinemediaobject><imageobject><imagedata
          fileref="images/copy_database.png" /></imageobject></inlinemediaobject></para>
        </section>
      </section>

      <section id="query_view">
        <title>Query View<indexterm><primary>query view</primary></indexterm><indexterm><primary>workbench
        query view</primary></indexterm></title>

        <para>You can run JDOQL and SQL queries and write BeanShell scripts
        using the query view.</para>

        <section id="query_view_jdoql">
          <title>JDOQL Queries<indexterm><primary>workbench JDOQL queries</primary></indexterm></title>

          <para>The large editable area to the left of the parameters grid is
          for editing the JDOQL filter expression. It supports syntax
          highlighting and code completion for fields, parameters, variables
          and methods (activated by pressing control-SPACE).</para>

          <para><inlinemediaobject><imageobject><imagedata
          fileref="images/query_view_jdoql.png" /></imageobject></inlinemediaobject></para>

          <para>The class field specifies the extent for the query (i.e. the
          class being queried against). The imports, variables and ordering
          fields correspond to the normal Query methods. You can save and open
          queries using the buttons on the toolbar. Queries are stored in XML
          files with a <filename>.jdoql</filename> extension.</para>

          <para>The large editable area to the left of the parameters grid is
          for editing the JDOQL filter expression. It supports syntax
          highlighting and code completion for fields, parameters, variables
          and methods (activated by pressing control-SPACE).</para>

          <para>Click the <command>Add</command> button to add parameters to
          the grid. Enter the declaration of the parameter in the Parameter
          column (e.g. &#34;int n&#34;) and optionally enter a value in the
          value column. For parameters that are references to persistence
          instances (e.g. &#34;Category c&#34;) you need to run another query
          to find the instance to use as the value. Once you have the query
          results press <command>control-C</command> or <command>Edit | Copy</command>
          to copy the OID of the instance to the clipboard. Select the
          parameter on the grid and press <command>control-V</command> or
          <command>Edit | Paste</command> to set the value.</para>

          <para>Run the query by clicking the <command>Play</command> button.
          This will start a Versant Open Access Server within the Workbench if
          this has not already been done. The tree in result window shows the
          persistent fields of each instance. Fields that have not been loaded
          are shown in gray. If an unloaded field is clicked it is loaded. You
          can see the SQL used to fetch it in the event log of the Management
          Console (see xxx). You can copy references to persistent instances
          to the clipboard to use as parameters to other queries.</para>
        </section>

        <section id="sql_window">
          <title>SQL Queries<indexterm><primary>workbench SQL queries</primary></indexterm></title>

          <para>You can edit and run normal SQL queries using the SQL window.
          The SQL editor supports syntax highlighting and code completion for
          tables (including aliases) and columns (activated by pressing
          control-SPACE). You must select the portion of the SQL text to
          execute before clicking the <command>Play</command> button. The
          selected text can contain many queries and statements separated with
          semicolons or &#39;go&#39;.</para>

          <para><inlinemediaobject><imageobject><imagedata
          fileref="images/query_view_sql.png" /></imageobject></inlinemediaobject></para>

          <para>Results are displayed on a grid with clickable column headers.
          You can save and open SQL files and export query results using the
          buttons on the toolbar.</para>
        </section>

        <section id="workbench_beanshell_scripts">
          <title>BeanShell Scripts<indexterm><primary>workbench SQL queries</primary></indexterm></title>

          <para>You can generate a BeanShell script for a JDOQL query by click
          the <command>generate BeanShell</command> button on the toolbar.
          This will generate Java code to execute the query. You can edit this
          code in the Workbench and run it or cut and paste it into your
          application. BeanShell scripts are very useful for quick data fixes.</para>

          <para><inlinemediaobject><imageobject><imagedata
          fileref="images/query_view_beanshell.png" /></imageobject></inlinemediaobject></para>

          <para>Results are displayed on a grid with clickable column headers.
          You can save and open SQL files and export query results using the
          buttons on the toolbar.</para>
        </section>
      </section>

      <section id="console_view">
        <title>Console View<indexterm><primary>console view</primary></indexterm><indexterm><primary>workbench
        console view</primary></indexterm></title>

        <para>The management console is a comprehensive monitoring and tuning
        tool. It is fully describe in <xref linkend="performance_monitoring" />.</para>

        <para><inlinemediaobject><imageobject><imagedata
        fileref="images/management_console.png" /></imageobject></inlinemediaobject></para>
      </section>

      <section id="codegen_view">
        <title>Reverse Engineering View<indexterm><primary>reverse engineering
        view</primary></indexterm><indexterm><primary>code generation view</primary></indexterm></title>

        <para>Versant Open Access can generate Java source files and
        corresponding .jdo meta data directly from database tables. The
        generation process is interactive and the Java source for a given
        table is displayed and updated as you make changes. You can
        incrementally generate Java files as your project progresses. If your
        database as referential integrity constraints Versant Open Access will
        automatically link related classes with references as they are mapped.</para>

        <para><inlinemediaobject><imageobject><imagedata
        fileref="images/codegen_view.png" /></imageobject></inlinemediaobject></para>
      </section>
    </section>
  </chapter>

  <chapter id="plugins">
    <title>Plugins</title>

    <para>Versant Open Access is supplied with plugins for the following IDEs:</para>

    <section id="eclipse_plugin">
      <title>Eclipse<indexterm><primary>Eclipse plugin</primary></indexterm><indexterm><primary>plugins
      Eclipse</primary></indexterm></title>

      <para>Two plugins is supplied for the Eclipse platform: Basic and Tools.
      Use the Basic plugin if you are using Eclipse 2.* or if you prefer to
      use the standalone workbench. Use the Tools plugin if you are using
      Eclipse 3.0.1 or later and want a rich UI for changing the mapping from
      inside the Eclipse platform without starting the standalone workbench.</para>

      <section>
        <title>Basic</title>

        <para>This plugin integrates JDO enhancement into the Eclipse build
        process. The standalone Versant Open Access Workbench is still used to
        edit mappings and to setup a Versant Open Access project.</para>

        <para>The basic plugin has been tested on Eclipse 2.1.2 and Eclipse
        3.0.1.</para>

        <para>The basic plugin is located in the
        [OPENACCESS_HOME]/plugins/eclipse directory. Please read
        <filename>README.txt</filename> for installation instructions.</para>
      </section>

      <section>
        <title>Eclipse Tools</title>

        <para>Some features of the standalone OpenAccess Workbench is
        integrated into the VOA Perspective and can be used to edit mappings
        and to set up a project. This plugin also integrates JDO enhancement
        into the Eclipse build process.</para>

        <para><inlinemediaobject><imageobject><imagedata
        fileref="images/eclipse_tools.png" /></imageobject></inlinemediaobject></para>

        <para>The tools plugin has been tested on Eclipse 3.0.1 &#38; 3.1.0M4
        on Windows.</para>

        <para>The tools plugin is located in the
        [OPENACCESS_HOME]/plugins/eclipseTools directory. Please read
        <filename>README.txt</filename> for installation instructions.</para>

        <para>Once you have installed this plugin you can switch workspace to
        <filename>demos/eclipse_workspace</filename> to see tut1 demo running
        from eclipse.</para>
      </section>
    </section>

    <section id="wasd_plugin">
      <title>WebSphere Application Studio Developer<indexterm><primary>WASD
      plugin</primary></indexterm> <indexterm><primary>plugins WASD</primary></indexterm></title>

      <para>This plugin integrates JDO enhancement into the WASD build process
      and has been tested on WebSphere Application Studio Developer 5.1.2. The
      standalone Versant Open Access Workbench is still used to edit mappings
      and to setup a Versant Open Access project.</para>

      <para>This plugin is located in the [OPENACCESS_HOME]/plugins/WASD
      directory. Please read <filename>README.txt</filename> for installation
      instructions.</para>
    </section>
  </chapter>

  <chapter id="ant_support">
    <title>Versant Open Access and Ant<indexterm><primary>Ant tasks</primary></indexterm></title>

    <para>Versant Open Access provides Ant tasks for JDO bytecode enhancement
    and schema generation. The Versant Open Access Workbench also supports Ant
    filter tokens in project files. Ant version 1.5 or newer is required. Ant
    is a free, open source, Java build tool and can be obtained from <ulink
    url="http://jakarta.apache.org">http://jakarta.apache.org</ulink>. It has
    become the standard way to build Java projects.</para>

    <para>To use the tasks in your project you need to use a
    <command>taskdef</command> as shown in the following build file (taken
    from <filename>demos/tut1/build.xml</filename>):</para>

    <programlisting linenumbering="unnumbered">&#60;project name=&#34;tut1&#34; default=&#34;compile&#34; basedir=&#34;.&#34;&#62;

    &#60;property name=&#34;src&#34; value=&#34;src&#34;/&#62;
    &#60;property name=&#34;build&#34; value=&#34;build&#34;/&#62;
    &#60;property name=&#34;build.classes&#34; value=&#34;${build}/classes&#34;/&#62;
    &#60;property name=&#34;jdo.project&#34; value=&#34;versant.properties&#34;/&#62;
    &#60;property name=&#34;jdo.home&#34; value=&#34;../..&#34;/&#62;
    &#60;property name=&#34;jdo.license&#34; value=&#34;${jdo.home}/license&#34;/&#62;
    &#60;property name=&#34;jdo.lib&#34; value=&#34;${jdo.home}/lib&#34;/&#62;
    &#60;property name=&#34;jdo.tools&#34; value=&#34;${jdo.home}/tools&#34;/&#62;

    &#60;path id=&#34;cp&#34;&#62;
        &#60;pathelement path=&#34;${src}&#34;/&#62;
        &#60;pathelement path=&#34;${build.classes}&#34;/&#62;
        &#60;pathelement path=&#34;${jdo.license}&#34;/&#62;
        &#60;fileset dir=&#34;${jdo.lib}&#34; includes=&#34;**/*.jar&#34;/&#62;
    &#60;/path&#62;

    &#60;target name=&#34;init&#34;&#62;
        &#60;mkdir dir=&#34;${build.classes}&#34;/&#62;
        &#60;copy file=&#34;${jdo.project}&#34; todir=&#34;${build.classes}&#34;/&#62;
        &#60;!-- Define Versant Open Access tasks (jdo-xxx) --&#62;
        &#60;taskdef resource=&#34;versant.tasks&#34;&#62;
            &#60;classpath&#62;
                &#60;path refid=&#34;cp&#34;/&#62;
                &#60;fileset dir=&#34;${jdo.tools}&#34; includes=&#34;**/*.jar&#34;/&#62;
            &#60;/classpath&#62;
        &#60;/taskdef&#62;
    &#60;/target&#62;

    ... other targets ...

&#60;/project&#62;</programlisting>

    <para><emphasis>It is important that the taskdef is only defined once the
    directory containing the class files for your project has been created</emphasis>.
    Otherwise the Versant Open Access tasks will be unable to load your
    application classes. This will cause your build to fail the first time it
    is run and work the second time (as the directory exists).</para>

    <para>The classpath used to define the tasks must include your own
    classes, a directory containing your Versant Open Access license and all
    the jars in the Versant Open Access <filename>lib</filename> and
    <filename>tools</filename> directories. The tools jars are not required at
    runtime.</para>

    <section id="ant_tasks">
      <title>Ant tasks<indexterm><primary>Ant tasks</primary></indexterm></title>

      <section id="task_jdo_enhance">
        <title>jdo-enhance<indexterm><primary>jdo-enhance task</primary></indexterm></title>

        <para>Use this task to enhance your persistent classes for use with
        the Versant Open Access runtime. Persistence aware classes
        (non-persistent classes that directly access fields of persistent
        classes) are also modified by this task. You must re-enhance if any of
        your classes are recompiled or you change JDO meta data. This is best
        done as in the following example from the tut1 demo:</para>

        <programlisting>&#60;target name=&#34;compile&#34; depends=&#34;init&#34;
        description=&#34;Compile and enhance all Java sources&#34;&#62;
    &#60;dependset&#62;
        &#60;!-- Delete the classes if the JDO meta data has been changed.
             They need to be recompiled and enhanced. --&#62;
        &#60;srcfileset dir=&#34;${src}&#34; includes=&#34;**/*.jdo&#34;/&#62;
        &#60;targetfileset dir=&#34;${build.classes}&#34; includes=&#34;**/*.class&#34;/&#62;
    &#60;/dependset&#62;
    &#60;javac srcdir=&#34;${src}&#34; destdir=&#34;${build.classes}&#34; classpathref=&#34;cp&#34;/&#62;
    &#60;jdo-enhance&#62;
        &#60;persistentaware dir=&#34;${build.classes}&#34;&#62;
            &#60;package name=&#34;tut1.model.*&#34;/&#62;
        &#60;/persistentaware&#62;
    &#60;/jdo-enhance&#62;
&#60;/target&#62;</programlisting>

        <formalpara>
          <title>Parameters</title>

          <para><informaltable><tgroup cols="3"><thead><row><entry>Attribute</entry><entry>Description</entry><entry>Required</entry></row></thead><tbody><row><entry>outputdir</entry><entry>Directory
          where the enhanced classes should be written. If this property is
          not specified then the classes will be overritten. This should
          normally be the same directory used for the compiled classes. Using
          a different directory is not recommended as it complicates classpath
          setup.</entry><entry>No</entry></row><row><entry>genhyper</entry><entry>Write
          hyperdrive classes to outputdir (ignored if hyperdrive has been
          disabled). Normally the Hyperdrive classes are generated at runtime.
          Use this option to generate them at enhancement time and package
          them with your classes. This improves the startup time of the
          Versant Open Access server and is required if you are using Java Web
          Start (see <xref linkend="java_web_start" />). <emphasis>If you
          change your .properties project file, any .jdo files or target a
          different database you must delete and regenerate the Hyperdrive
          classes.</emphasis></entry><entry>No (false)</entry></row><row><entry>makefieldsprivate</entry><entry>Makes
          the persistent fields private. This is non-standard but safer than
          leaving the fields accessable. It defaults to false.</entry><entry>No
          (false)</entry></row><row><entry>detach</entry><entry>Include Open
          Access specific code to support JDO 2 attach/detach. This option
          will become a NOP when JDO is released.</entry><entry>No (true)</entry></row><row><entry>project</entry><entry>Resource
          name of .properties project file. <emphasis>This must be on the
          classpath</emphasis>.</entry><entry>No (<filename>versant.properties</filename>)</entry></row></tbody></tgroup></informaltable></para>
        </formalpara>

        <formalpara>
          <title>Parameters specified as nested elements</title>

          <para>There can be multiple nested <command>persistentaware</command>
          elements each specifying a set of classes that may directly access
          fields of your persistent classes (use the <command>dir</command>
          attribute). You can use the nested <command>package</command>
          element to persistentaware to restrict the set of classes to a
          particular package or packages. Specifying &#60;package
          name=&#34;za.co.hemtech.app.model&#34;/&#62; includes only the model
          package. Specifying &#60;package
          name=&#34;za.co.hemtech.app.*&#34;/&#62; includes the app package,
          the model package and all other packages below app.</para>
        </formalpara>
      </section>

      <section id="task_jdo_create_db">
        <title>jdo-create-db<indexterm><primary>jdo-create-db task</primary></indexterm></title>

        <para>Use this task to create and/or validate the database tables for
        your model. The task will create an SQL script and also optionally
        drop and optionally recreate all the tables in each datastore using
        the connection properties in your project file. <emphasis>This will
        destroy any data in those tables</emphasis>. Here is an example from
        the tut1 demo:</para>

        <programlisting>&#60;target name=&#34;create-db&#34; depends=&#34;compile&#34;
        description=&#34;Re-create database schema&#34;&#62;
    &#60;jdo-create-db
            out=&#34;${build}/versant.sql&#34;
            droptables=&#34;true&#34;
            createtables=&#34;true&#34; /&#62;
&#60;/target&#62;</programlisting>

        <para>The validate option will check that the tables exist and that
        all the columns are as expected.</para>

        <formalpara>
          <title>Parameters</title>

          <para><informaltable><tgroup cols="3"><thead><row><entry>Attribute</entry><entry>Description</entry><entry>Required</entry></row></thead><tbody><row><entry>out</entry><entry>Name
          of .sql script file.</entry><entry>No (<filename>versant.sql</filename>)</entry></row><row><entry>droptables</entry><entry><literal>true</literal>
          to drop all tables with the same names (case insensitive) as tables
          in the schema.</entry><entry>No (false)</entry></row><row><entry>createtables</entry><entry><literal>true</literal>
          to connect to the database and create tables. If <literal>false</literal>
          only a script is generated.</entry><entry>No (false)</entry></row><row><entry>validate</entry><entry><literal>true</literal>
          to check that all tables and columns in the schema exist.</entry><entry>No
          (false)</entry></row><row><entry>logevents</entry><entry>Event
          logging level (none, errors, normal, verbose, all).</entry><entry>No
          (errors)</entry></row><row><entry>project</entry><entry>Resource
          name of .properties project file. <emphasis>This must be on the
          classpath</emphasis>.</entry><entry>No (<filename>versant.properties</filename>)</entry></row></tbody></tgroup></informaltable></para>
        </formalpara>
      </section>

      <section id="task_jdo_copy_db">
        <title>jdo-copy-db<indexterm><primary>jdo-copy-db task</primary></indexterm></title>

        <para>Use this task to copy the database for a datastore to a new URL.
        Each table in the database is copied to the destination URL.
        <emphasis>The destination can be a different database on a different
        server</emphasis>. Only tables and columns mapped to Versant Open
        Access classes and fields are copied. Versant ODBMS as a source and/or
        destination will be supported in a future release. Example: You can
        use this to copy an Informix database to an Oracle database. Note that
        there is also a Workbench dialog to copy a database (see <xref
        linkend="copy_database_dialog" />). Here is an example:</para>

        <programlisting>&#60;target name=&#34;copy-db-to-test&#34; depends=&#34;compile&#34;
        description=&#34;Copy database to test server&#34;&#62;
    &#60;jdo-copy-db url=&#34;jdbc:postgresql://jdotest2/rcm&#34; /&#62;
&#60;/target&#62;</programlisting>

        <formalpara>
          <title>Parameters</title>

          <para><informaltable><tgroup cols="3"><thead><row><entry>Attribute</entry><entry>Description</entry><entry>Required</entry></row></thead><tbody><row><entry>url</entry><entry>Destination
          database JDBC URL.</entry><entry>Yes</entry></row><row><entry>db</entry><entry>Destination
          database type (db2, cache, firebird, hypersonic, informix,
          informixse, interbase, mssql, mysql, oracle, pointbase, postgres,
          sapdb, sybase).</entry><entry>No (as source)</entry></row><row><entry>driver</entry><entry>Destination
          database JDBC driver class.</entry><entry>No (as source)</entry></row><row><entry>user</entry><entry>Destination
          database user name.</entry><entry>No (as source)</entry></row><row><entry>password</entry><entry>Destination
          database password.</entry><entry>No (as source)</entry></row><row><entry>properties</entry><entry>Extra
          connection properties for destination database.</entry><entry>No (as
          source)</entry></row><row><entry>droptables</entry><entry>Drop
          tables in the destination database with names the same as those in
          the schema?</entry><entry>No (true)</entry></row><row><entry>createtables</entry><entry>Create
          tables in the destination database.</entry><entry>No (true)</entry></row><row><entry>rowspertransaction</entry><entry>The
          number of rows inserted per transaction.</entry><entry>No (1000)</entry></row><row><entry>logevents</entry><entry>Event
          logging level (none, errors, normal, verbose, all).</entry><entry>No
          (errors)</entry></row><row><entry>project</entry><entry>Resource
          name of .properties project file. <emphasis>This must be on the
          classpath</emphasis>.</entry><entry>No (<filename>versant.properties</filename>)</entry></row></tbody></tgroup></informaltable></para>
        </formalpara>
      </section>

      <section id="task_jdo_migrate_db">
        <title>jdo-migrate-db <indexterm><primary>jdo-migrate-db task</primary></indexterm></title>

        <para>Use this task to update the database schema to match the current
        model and mappings. This task will create a SQL migration script
        called <filename>Schema_Migration_&#60;datastore
        type&#62;_dd-MM-yyyy_H-m.sql</filename> in the output directory. It
        can also optionally run the migration script against the database
        directly using JDBC. Here is an example:</para>

        <programlisting>&#60;target name=&#34;migrate-db&#34; depends=&#34;compile&#34;
         description=&#34;Migrate database on test server&#34;&#62;
    &#60;jdo-migrate-db
        outputdir=&#34;${build}&#34;
        checkConstraint=&#34;false&#34;
        direct=&#34;true&#34;&#62;
    &#60;/jdo-migrate-db&#62;
&#60;/target&#62;</programlisting>

        <para>Currently schema migration is not supported on Hypersonic.</para>

        <formalpara>
          <title>Parameters</title>

          <para><informaltable><tgroup cols="3"><thead><row><entry>Attribute</entry><entry>Description</entry><entry>Required</entry></row></thead><tbody><row><entry>outputdir</entry><entry>Directory
          to put .sql migration script in. <emphasis>The *.sql script will not
          be generated if this in not set.</emphasis></entry><entry>No</entry></row><row><entry>datastore</entry><entry>Name
          of the datastore to migrate. Defaults to first (default) datastore.</entry><entry>No</entry></row><row><entry>direct</entry><entry>Run
          the generated migration script directly against the database?
          Defaults to false.</entry><entry>No</entry></row><row><entry>checkConstraint</entry><entry>Must
          database constraints be checked? Defaults to true.</entry><entry>No</entry></row><row><entry>checkExtraColumns</entry><entry>Must
          extra columns be checked, and if found, droped? Defaults to true.</entry><entry>No</entry></row><row><entry>checkIndex</entry><entry>Must
          database indexes be checked? Defaults to true.</entry><entry>No</entry></row><row><entry>checkLength</entry><entry>Must
          column lengths be checked? Defaults to true.</entry><entry>No</entry></row><row><entry>checkNulls</entry><entry>Must
          column null or not null datad? Defaults to true.</entry><entry>No</entry></row><row><entry>checkPK</entry><entry>Must
          table primary keys be checked? Defaults to true.</entry><entry>No</entry></row><row><entry>checkScale</entry><entry>Must
          column scale be checked? Defaults to true.</entry><entry>No</entry></row><row><entry>checkType</entry><entry>Must
          column data types be checked? Defaults to true.</entry><entry>No</entry></row><row><entry>project</entry><entry>Resource
          name of .properties project file. <emphasis>This must be on the
          classpath</emphasis>.</entry><entry>No (versant.properties)</entry></row></tbody></tgroup></informaltable></para>
        </formalpara>
      </section>

      <section id="task_jdo_exec_sql">
        <title>jdo-exec-sql <indexterm><primary>jdo-exec-sql task</primary></indexterm></title>

        <para>Use this task to run SQL scripts or statements against a
        database. The task will execute a SQL script and/or SQL statement in
        the body of this tag for the given datastore. If both script and
        statement is present then the statement in the body will be executed
        first. Here is an example:</para>

        <programlisting>&#60;target name=&#34;run-script&#34; depends=&#34;compile&#34;
         description=&#34;Runs a SQL script on the database&#34;&#62;
    &#60;jdo-exec-sql
        scriptFile=&#34;${build}/Schema_Migration_oracle_01-01-2004_12-30.sql&#34;&#62;

        select * from person; -- comments like this will be taken out

        /* comments like this will also be taken out */
        select * from dual;

        /* go statements will work on Sybase and MS SQL server  */

    &#60;/jdo-exec-sql&#62;
&#60;/target&#62;</programlisting>

        <formalpara>
          <title>Parameters</title>

          <para><informaltable><tgroup cols="3"><thead><row><entry>Attribute</entry><entry>Description</entry><entry>Required</entry></row></thead><tbody><row><entry>scriptFile</entry><entry>The
          SQL script file to execute.</entry><entry>No</entry></row><row><entry>project</entry><entry>Resource
          name of .properties project file. <emphasis>This must be on the
          classpath</emphasis>.</entry><entry>No (versant.properties)</entry></row></tbody></tgroup></informaltable></para>
        </formalpara>
      </section>

      <section id="task_jdo_log_download">
        <title>jdo-log-download<indexterm><primary>jdo-log-download</primary></indexterm></title>

        <para>Use this task to download events and/or performance metric
        snapshots from a remote Versant Open Access server. These can be
        analyzed using the Workbench management console. This is a wrapper
        around a JavaBean that you can cut and paste or embed in your own
        applications (<classname>com.versant.core.jdo.LogDownloader</classname>).</para>

        <programlisting>&#60;target name=&#34;log-remote&#34; depends=&#34;compile&#34;
        description=&#34;Download event log and metrics from remote server&#34;&#62;
    &#60;jdo-log-download host=&#34;127.0.0.1&#34; /&#62;
&#60;/target&#62;</programlisting>

        <para>The LogDownloader bean can be invoked directly from the command
        line:</para>

        <programlisting>java com.versant.core.jdo.LogDownloader -host 127.0.0.1</programlisting>

        <para>The attributes listed in the following table are the command
        line arguments.</para>

        <formalpara>
          <title>Parameters</title>

          <para><informaltable><tgroup cols="3"><thead><row><entry>Attribute</entry><entry>Description</entry><entry>Required</entry></row></thead><tbody><row><entry>project</entry><entry>Resource
          name of .properties project file. <emphasis>This must be on the
          classpath</emphasis>.</entry><entry>No (server.properties)</entry></row><row><entry>host</entry><entry>Remote
          host. If not set then this defaults to the host in the project file.</entry><entry>No
          (if project set)</entry></row><row><entry>server</entry><entry>Name
          of the remote Versant Open Access server. If not set then this
          defaults to the server in the project file.</entry><entry>No (if
          project set)</entry></row><row><entry>port</entry><entry>Port of the
          remote Versant Open Access server. If not set then this defaults to
          the port in the project file or the default port.</entry><entry>No</entry></row><row><entry>username</entry><entry>Username
          to use to connect. If not set then this defaults to the username in
          the project file.</entry><entry>No</entry></row><row><entry>password</entry><entry>Password
          to use to connect. If not set then this defaults to the password in
          the project file.</entry><entry>No</entry></row><row><entry>filename</entry><entry>Filename
          without extension to write events and snapshots to. Default is
          <filename>jdogenie_&#60;host&#62;_&#60;server&#62;</filename>.</entry><entry>No</entry></row><row><entry>eventBinary</entry><entry>Write
          events to binary file (<filename>&#60;filename&#62;.jdolog</filename>).
          Defaults to true.</entry><entry>No</entry></row><row><entry>eventText</entry><entry>Write
          events to text file (<filename>&#60;filename&#62;.txt</filename>).
          Defaults to false. Note that the binary file contains very much more
          information.</entry><entry>No</entry></row><row><entry>metricBinary</entry><entry>Write
          performance metric snapshots to binary file (<filename>&#60;filename&#62;.jdoperf</filename>).
          Defaults to true.</entry><entry>No</entry></row><row><entry>append</entry><entry>Append
          to existing event log text file (if any). Note that the binary files
          are never appended. Defaults to false.</entry><entry>No</entry></row><row><entry>maxFileSizeK</entry><entry>The
          maximum size of any of the files written in K. When a file exceeds
          this size it rolls over to a series of numbered backups (<filename>&#60;filename&#62;.jdoperf.1</filename>,
          <filename>&#60;filename&#62;.jdoperf.2</filename>, ...). The oldest
          file has the highest backup number. Default is 1000.</entry><entry>No</entry></row><row><entry>backups</entry><entry>The
          number of backups to maintain for each file. Default is 3.</entry><entry>No</entry></row><row><entry>eventPollSecs</entry><entry>The
          number of seconds between each poll of the remote server for new
          events. Default is 1. You may want to increase this if you are on a
          slow connection and have configured a big ring buffer on the server.</entry><entry>No</entry></row><row><entry>metricPollSecs</entry><entry>The
          number of seconds between each poll of the remote server for new
          performance metric snapshots. Default is 60. The server buffers one
          hour of data by default so this could be much longer.</entry><entry>No</entry></row><row><entry>quiet</entry><entry>Enable
          quite mode. If true then no progress output is generated. Defaults
          to false.</entry><entry>No</entry></row><row><entry>single</entry><entry>Do
          a single poll of the server for events and/or metrics and then exit.
          Defaults to false.</entry><entry>No</entry></row><row><entry>dateFormat</entry><entry>Set
          the format of dates written to the event text file. Default is &#39;<literal>HH:mm:ss.SSS</literal>&#39;.
          Use patterns from <classname>java.text.SimpleDateFormat</classname>.</entry><entry>No</entry></row></tbody></tgroup></informaltable></para>
        </formalpara>
      </section>
    </section>

    <section id="using_ant_filter_tokens">
      <title>Using Ant filter tokens<indexterm><primary>Ant filter tokens</primary></indexterm></title>

      <para>Ant provides support for replaceable &#34;filter tokens&#34; in
      text files (see <ulink
      url="http://jakarta.apache.org/ant/manual/CoreTasks/filter.html">http://jakarta.apache.org/ant/manual/CoreTasks/filter.html</ulink>).
      This feature is makes it easy to parameterize any file in your
      application with different properties for development, test, production
      and so on. Typically you will use filter tokens in place of connection
      properties in the Versant Open Access project file. The Versant Open
      Access Workbench supports the use of Ant tokens in many places. It uses
      a properties file to resolve the tokens within the Workbench so it can
      still connect to the database. This properties file can also be used
      with the Ant <command>filter</command> task to resolve the tokens during
      your build process.</para>

      <para>Here is part of the build.xml from the tut1 demo (demos/tut1)
      converted to use filter tokens in the project file:</para>

      <programlisting>&#60;target name=&#34;init&#34;&#62;
    &#60;mkdir dir=&#34;${build.classes}&#34;/&#62;
    &#60;filter filtersfile=&#34;tut1.properties&#34;/&#62;
    &#60;copy file=&#34;${jdo.project}&#34; todir=&#34;${build.classes}&#34;
        filtering=&#34;true&#34; overwrite=&#34;true&#34; /&#62;
    ...
&#60;/target&#62;</programlisting>

      <para>The filter task defines filter tokens for all of the properties in
      tut1.properties. The copy task copies the project file to
      <filename>build/classes</filename> with filtering=&#34;true&#34; and
      overwrite=&#34;true&#34; to replace the filter tokens in the file. The
      <filename>tut1.properties</filename> file is as follows:</para>

      <programlisting>MAIN.DB=postgres
MAIN.URL=jdbc\:postgresql\://127.0.0.1/jdo_tut1
MAIN.DRIVER=org.postgresql.Driver
MAIN.USER=postgres
MAIN.PASSWORD=postgres
MAIN.PROPERTIES=
MAIN.MAX.ACTIVE=20
MAIN.MAX.IDLE=5</programlisting>

      <para>The tokenized part of the <filename>.properties</filename> project
      file is as follows (note the use of @TOKEN@ tokens):</para>

      <programlisting>store0.name=main
store0.driver=@MAIN.DRIVER@
store0.url=@MAIN.URL@
store0.db=@MAIN.DB@
store0.user=@MAIN.USER@
store0.password=@MAIN.PASSWORD@
store0.properties=@MAIN.PROPERTIES@
store0.maxActive=@MAIN.MAX.ACTIVE@
store0.maxIdle=@MAIN.MAX.IDLE@</programlisting>

      <para>You can use the Workbench to automatically tokenize your project
      file and create a properties file from the current connection
      properties. Click the &#34;Ant Tokens&#34; button on the
      <command>Datastore Properties | Connection</command> tab.</para>
    </section>
  </chapter>

  <chapter id="class_mapping">
    <title>Class Mapping<indexterm><primary>class mapping</primary></indexterm></title>

    <para>This chapter describes the different inheritance mapping strategies
    supported by Versant Open Access (flat, vertical and horizontal) and the
    columns added to the table for a class other than those for its fields.</para>

    <section id="class_table">
      <title>Table<indexterm><primary>class table</primary></indexterm><indexterm><primary>table
      for class</primary></indexterm></title>

      <para>Classes not in an inheritance hierarchy are mapped to a table name
      generated from the name of the class by the name generator configured
      for the project. You can change the table name and other class
      properties using the class properties form in the Workbench. Double
      click tables and columns on the E/R diagram to edit them.</para>

      <para><inlinemediaobject><imageobject><imagedata
      fileref="images/class_er.png" /></imageobject></inlinemediaobject></para>

      <para>The <command>Do not create</command> option shown in the
      screenshot is useful when some of the tables in your schema are already
      present and must not be created. The default value of this option is
      controlled using <command>File | Project Properties | General Settings</command>
      in the Workbench. Link tables for Collection and Map fields of classes
      with <command>Do not create</command> set are automatically excluded
      from the generated schema.</para>

      <para>You can also edit the table name and other settings directly in
      the .jdo meta data:</para>

      <programlisting>&#60;class name=&#34;Address&#34;&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-table-name&#34; value=&#34;addr&#34; /&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-do-not-create-table&#34; value=&#34;true&#34; /&#62;
&#60;/class&#62;</programlisting>
    </section>

    <section id="primary_key">
      <title>Primary Key<indexterm><primary>primary key</primary></indexterm></title>

      <para>Versant Open Access supports datastore and application identity
      (see <xref linkend="object_identity" />). Both types of identity can be
      used with built in or user defined key generators (see <xref
      linkend="md_jdbc_key_generator" />).</para>

      <section id="pk_datastore_identity">
        <title>Datastore Identity<indexterm><primary>datastore identity</primary></indexterm></title>

        <para>The default primary key column for a datastore identity class is
        the column that Java int&#39;s are mapped to. This is normally a SQL
        INTEGER but can be changed using the <command>jdbc-primary-key</command>
        extension (see <xref linkend="md_jdbc_primary_key" />). Primary key
        values are provided by a key generator. The default key generator uses
        a last used number table to generate new numbers.</para>

        <para>You change the type and other properties of the primary key
        column by editing the <literal>&#60;pk&#62;</literal> field in the
        workbench or by editing the meta data directly. This example uses the
        <command>jdbc-primary-key</command> and <command>jdbc-column</command>
        extensions to change the type of the column to SMALLINT:</para>

        <programlisting>&#60;class name=&#34;Category&#34;&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-primary-key&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-column&#34;&#62;
            &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-type&#34; value=&#34;SMALLINT&#34; /&#62;
        &#60;/extension&#62;
    &#60;/extension&#62;
&#60;/class&#62;</programlisting>
      </section>

      <section id="pk_application_identity">
        <title>Application Identity<indexterm><primary>application identity</primary></indexterm></title>

        <para>For application identity classes the primary key is composed of
        columns for the primary key field(s). Versant Open Access supports
        composite primary keys for application identity classes. This is not
        recommended unless you need to map to a legacy schema as single column
        primary keys are more efficient.</para>

        <para>The JDO specification requires that the values for the primary
        key fields of a new instance of an application identity class be
        filled in by the developer. However Versant Open Access supports the
        use of key generators for application identity fields (see <xref
        linkend="md_jdbc_key_generator" />). If an application identity class
        has a key generator then the values of the primary key fields of a new
        instance are filled by the key generator on commit or when
        PM.getObjectId(pc) is called. The key generator is only invoked If the
        primary key fields have values the same as a new instance of the
        objectid-class. If the primary key fields have different values then
        these are used instead of invoking the key generator.</para>

        <programlisting>&#60;class name=&#34;Order&#34; identity-type=&#34;application&#34;&#62;
    &#60;field name=&#34;orderNo&#34; primary-key=&#34;true&#34; &#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-key-generator&#34; value=&#34;HIGHLOW&#34; /&#62;
&#60;/class&#62;</programlisting>

        <para>Here is some example code showing when the key generator is
        invoked and when it is not:</para>

        <programlisting>pm.currentTransaction().begin();
Order o1 = new Order();
pm.makePersistent(o1);
Order o2 = new Order();
o2.setOrderNo(1000);
pm.makePersistent(o2);
pm.currentTransaction().commit();
// a primary key is generated for o1 but not for o2 as it already
// has a primary key (1000)</programlisting>

        <para>This feature is very useful when instances are copied from one
        database to another (e.g. an offline application synchronizing with a
        central server).</para>
      </section>

      <section id="key_generators">
        <title>Key Generators<indexterm><primary>key generators</primary></indexterm></title>

        <para>Versant Open Access supports user written key generators for
        datastore and application identity classes. The source for the built
        in key generators (HIGHLOW and AUTOINC) is provided as an example (see
        <filename>src/com/versant/core/jdbc/sql</filename> in the Versant Open
        Access distribution). To configure a user written key generator for a
        class use the Workbench Class Properties window and enter the name of
        the <classname>JdbcKeyGeneratorFactory</classname> class in the field
        provided. The standard key generators use a public static inner class
        as the factory. Here is an example:</para>

        <programlisting>&#60;class name=&#34;Order&#34; identity-type=&#34;application&#34;&#62;
    &#60;field name=&#34;orderNo&#34; primary-key=&#34;true&#34; &#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-key-generator&#34;
        value=&#34;com.acme.erp.jdo.FunkyKeyGenerator$Factory&#34; /&#62;
&#60;/class&#62;</programlisting>
      </section>

      <section id="autoinc_columns">
        <title>Autoinc / Identity / Serial Columns<indexterm><primary>AUTO_INCREMENT
        columns</primary></indexterm><indexterm><primary>IDENTITY columns</primary></indexterm><indexterm><primary>SERIAL
        columns</primary></indexterm></title>

        <para>Versant Open Access supports IDENTITY columns on Sybase and
        Microsoft SQL Server, SERIAL columns on Informix and AUTO_INCREMENT
        columns on MySQL. To enable this support select the AUTOINC key
        generator using the Workbench (right click the class and select
        <command>Class Properties</command>). Both application and datastore
        identity classes are supported. You can also configure the default key
        generator for all the datastore identity classes in the datastore in
        the Workbench (<command>File | Datastore Properties, General Settings
        tab</command>). Here is an example of an application identity class
        using the AUTOINC key generator:</para>

        <programlisting>&#60;class name=&#34;Order&#34; identity-type=&#34;application&#34;&#62;
    &#60;field name=&#34;orderNo&#34; primary-key=&#34;true&#34; &#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-key-generator&#34; value=&#34;AUTOINC&#34; /&#62;
&#60;/class&#62;</programlisting>

        <para>Note that the AUTOINC key generator is slower than the default
        HIGHLOW key generator and not portable across databases. Usually a
        separate database query must be run after each insert to retrieve the
        generated primary key value. This is slow and also prevents the use of
        JDBC 2.0 statement batching. Only use this feature if you need to map
        to a legacy database schema using AUTO_INCREMENT, IDENTITY or SERIAL
        columns.</para>
      </section>
    </section>

    <section id="mapping_inheritance">
      <title>Inheritance<indexterm><primary>inheritance</primary></indexterm></title>

      <para>Classes in an inheritance hierarchy can be mapped to the same
      table (flat) or to different tables (vertical and horizontal) or a
      combination of the three strategies. For flat and vertical mappings each
      class indicates how it is mapped to its superclass. Horizontal mapping
      may only be specified for the topmost class in a hierarchy and the
      setting applies to its immediate subclasses.</para>

      <para>Flat mapping requires the addition of a discriminator or indicator
      column to the table for the base class to identify the type of each row
      (except for one special case <xref linkend="flat_no_descriminator" />).
      The default name of the discriminator column is &#39;jdo_class&#39;.
      This is optional for vertical mapping and not required for horizontal
      mapping. The discriminator column value for each class can be an int or
      a String.</para>

      <para>The discriminator column is mapped to a SQL INTEGER if all of the
      discriminator values are ints, and a SQL VARCHAR otherwise, but can be
      changed using the Workbench or editing the <literal>jdbc-class-id</literal>
      extension (see <xref linkend="md_jdbc_class_id" />) in the meta data.
      The default class-id (or discriminator) value for a class is a 32 bit
      positive hash of the fully qualified class name but you can also change
      this using jdbc-class-id extension or by editing class properties in the
      Workbench. In particular the default can be changed to the fully
      qualified name of the class or the name without package (see <xref
      linkend="inheritance_defaults" />).</para>

      <para>The screenshots and examples in the sections below use the
      inheritance demo in <filename>demos/inheritance</filename>. The class
      hierarchy in this demo is as follows:</para>

      <para><inlinemediaobject><imageobject><imagedata
      fileref="images/pet_heirachy.png" /></imageobject></inlinemediaobject></para>

      <section id="flat">
        <title>Flat Mapping<indexterm><primary>flat inheritance mapping</primary></indexterm><indexterm><primary>inheritance
        flat mapping</primary></indexterm></title>

        <para>With flat mapping fields from the subclasses are mapped to the
        superclass table. Flat mapping is the simplest and usually fastest
        option so it is the default.</para>

        <para>Advantages of flat mapping:</para>

        <itemizedlist>
          <listitem>
            <para>Only a single query is required to retrieve all of the
            instances in a hierarchy without any extra joins.</para>
          </listitem>

          <listitem>
            <para>Creating, updating or deleting an instance requires only a
            single INSERT, UPDATE or DELETE statement.</para>
          </listitem>
        </itemizedlist>

        <para>Disadvantages of flat mapping:</para>

        <itemizedlist>
          <listitem>
            <para>The base table has many columns that may be used by only a
            few subclass instances.</para>
          </listitem>

          <listitem>
            <para>A discriminator or class indicator column is required to
            identify the type of each row (except <xref
            linkend="flat_no_descriminator" />).</para>
          </listitem>
        </itemizedlist>

        <para>The image below shows part of the class properties form in the
        Workbench for the <classname>Dog</classname> class in the
        <classname>Pet</classname> hierarchy. All the classes are mapped flat
        so all of their fields are in the <literal>pet</literal> table and
        there is a <literal>jdo_class</literal> column (the discriminator).</para>

        <para><inlinemediaobject><imageobject><imagedata
        fileref="images/pet_all_flat.png" /></imageobject></inlinemediaobject></para>

        <para>Since this is the default mapping the .jdo meta data is very
        simple:</para>

        <programlisting>&#60;jdo&#62;
    &#60;package name=&#34;inheritance.model&#34;&#62;
        &#60;class name=&#34;Cat&#34; persistence-capable-superclass=&#34;Pet&#34; /&#62;
        &#60;class name=&#34;Dog&#34; persistence-capable-superclass=&#34;Pet&#34; /&#62;
        &#60;class name=&#34;Pet&#34; /&#62;
        &#60;class name=&#34;Rottweiler&#34; persistence-capable-superclass=&#34;Dog&#34; /&#62;
        &#60;class name=&#34;WienerDog&#34; persistence-capable-superclass=&#34;Dog&#34; /&#62;
    &#60;/package&#62;
&#60;/jdo&#62;</programlisting>

        <para>When only certain subclasses are required the generated SQL uses
        the discriminator column to filter the results. Here is an example:</para>

        <programlisting>Query query = pm.newQuery(Dog.class);
Collection col = (Collection)query.execute();</programlisting>

        <para>The values in the where clause IN list are the default
        <literal>jdbc-class-id</literal>&#39;s for <classname>Dog</classname>,
        <classname>WeinerDog</classname> and <classname>Rottweiler</classname>.</para>

        <programlisting>SELECT pet_id, jdo_class, best_friend, nme, jdo_version,
       cats_eaten, lngth
  FROM pet
 WHERE jdo_class IN (759263421,1302943882,958541839)</programlisting>
      </section>

      <section id="vertical">
        <title>Vertical Mapping<indexterm><primary>vertical inheritance
        mapping</primary></indexterm><indexterm><primary>inheritance vertical
        mapping</primary></indexterm></title>

        <para>With vertical mapping each class has its own table containing
        only its fields.</para>

        <para>Advantages of vertical mapping:</para>

        <itemizedlist>
          <listitem>
            <para>Tables are normalized as they only contain columns for the
            fields of the class they are for and rows are only present for
            instances of the class.</para>
          </listitem>

          <listitem>
            <para>New subclasses can be added without changing existing
            tables.</para>
          </listitem>

          <listitem>
            <para>A discriminator column is not required. This may help when
            mapping an inheritance hierarchy to existing tables.</para>
          </listitem>
        </itemizedlist>

        <para>Disadvantages of vertical mapping:</para>

        <itemizedlist>
          <listitem>
            <para>Joins are used to fetch fields from possible subclasses in a
            single query. If the type of the instance being fetched is known
            then only its tables are joined otherwise all possible subclass
            tables must be included.</para>
          </listitem>

          <listitem>
            <para>Creating, updating or deleting an instance requires multiple
            INSERT, UPDATE or DELETE statements (one for each table involved).</para>
          </listitem>
        </itemizedlist>

        <para>The image below shows part of the class properties form for the
        Pet class. The discriminator column has been disabled so all of the
        subclasses use vertical inheritance.</para>

        <para><inlinemediaobject><imageobject><imagedata
        fileref="images/pet_no_descriminator.png" /></imageobject></inlinemediaobject></para>

        <para>The tables are shown below:</para>

        <para><inlinemediaobject><imageobject><imagedata
        fileref="images/pet_all_vertical_tables.png" /></imageobject></inlinemediaobject></para>

        <para>The special value <literal>{no}</literal> is used for the
        jdbc-class-id in the meta data to disable the discriminator column.</para>

        <programlisting>&#60;jdo&#62;
    &#60;package name=&#34;inheritance.model&#34;&#62;
        &#60;class name=&#34;Cat&#34; persistence-capable-superclass=&#34;Pet&#34; /&#62;
        &#60;class name=&#34;Dog&#34; persistence-capable-superclass=&#34;Pet&#34; /&#62;
        &#60;class name=&#34;Pet&#34;&#62;
            &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-class-id&#34; value=&#34;{no}&#34; /&#62;
        &#60;/class&#62;
        &#60;class name=&#34;Rottweiler&#34; persistence-capable-superclass=&#34;Dog&#34; /&#62;
        &#60;class name=&#34;WienerDog&#34; persistence-capable-superclass=&#34;Dog&#34; /&#62;
    &#60;/package&#62;
&#60;/jdo&#62;</programlisting>

        <para>The SQL to fetch all of the pets for a vertical inheritance
        mapping without a discriminator column is shown below. All tables are
        pulled in with OUTER joins and the null/not-null dataf their primary
        keys is used to determine the type of the row. Any number of instances
        of different types can be retrieved with a single query. Some O/R
        mapping tools even run an extra query for each row returned to
        discover its true type (N+1 queries) or run a separate query against
        each possible table and merge the results in memory.</para>

        <programlisting>SELECT a.pet_id, b.pet_id, c.pet_id, d.pet_id, e.pet_id,
       a.nme, a.jdo_version, b.lives_left, c.best_friend,
       d.cats_eaten, e.lngth
  FROM pet a 
       LEFT JOIN cat AS b ON (a.pet_id = b.pet_id)
       LEFT JOIN dog AS c ON (a.pet_id = c.pet_id)
       LEFT JOIN rottweiler AS d ON (c.pet_id = d.pet_id)
       LEFT JOIN wiener_dog AS e ON (c.pet_id = e.pet_id)</programlisting>

        <para>If a discriminator column is used the SQL is as follows:</para>

        <programlisting>SELECT a.pet_id, a.jdo_class, a.nme, a.jdo_version,
       b.lives_left, c.best_friend, d.cats_eaten, e.lngth
  FROM pet a 
       LEFT JOIN cat AS b ON (a.pet_id = b.pet_id)
       LEFT JOIN dog AS c ON (a.pet_id = c.pet_id)
       LEFT JOIN rottweiler AS d ON (c.pet_id = d.pet_id)
       LEFT JOIN wiener_dog AS e ON (c.pet_id = e.pet_id)</programlisting>

        <para>If all the instances returned are known to be of a given
        subclass Versant Open Access will optimize the joins as shown in this
        example:</para>

        <programlisting>Query query = pm.newQuery(Dog.class);
Collection col = (Collection)query.execute();</programlisting>

        <para>Note that an INNER join is used to pickup the base class fields:</para>

        <programlisting>SELECT a.pet_id, a.pet_id, c.pet_id, d.pet_id,
       a.best_friend, b.nme, b.jdo_version, c.cats_eaten,
       d.lngth
  FROM dog a 
       INNER JOIN pet AS b ON (a.pet_id = b.pet_id)
       LEFT JOIN rottweiler AS c ON (a.pet_id = c.pet_id)
       LEFT JOIN wiener_dog AS d ON (a.pet_id = d.pet_id)</programlisting>

        <para>If the subclass is a leaf class all the joins will be INNER
        joins:</para>

        <programlisting>Query query = pm.newQuery(Rottweiler.class);
Collection col = (Collection)query.execute();</programlisting>

        <para>SQL:</para>

        <programlisting>SELECT a.pet_id, a.cats_eaten, b.best_friend, c.nme, c.jdo_version
  FROM rottweiler a 
       INNER JOIN dog AS b ON (a.pet_id = b.pet_id)
       INNER JOIN pet AS c ON (a.pet_id = c.pet_id)</programlisting>
      </section>

      <section id="horizontal">
        <title>Horizontal Mapping<indexterm><primary>horizontal inheritance
        mapping</primary></indexterm></title>

        <para>Horizontal inheritance can only be enabled for the topmost class
        in a hierarchy. Each immediate subclass is stored in its own table
        with a &#34;copy&#34; of the fields from the superclass. No table is
        created for the superclass itself and instances of it are not allowed.
        Each subclass may map the fields inherited from the superclass
        differently. Each subclass may have its own settings for identity
        type, objectid-class, key generator and optimistic locking just like a
        top level class. Classes further down the hierarchy may be mapped with
        any combination of flat and vertical inheritance.</para>

        <para>Advantages of horizontal inheritance:</para>

        <itemizedlist>
          <listitem>
            <para>Creating, updating or deleting an instance requires only a
            single INSERT, UPDATE or DELETE statement.</para>
          </listitem>

          <listitem>
            <para>Fetching a single instance does not require any joins.</para>
          </listitem>
        </itemizedlist>

        <para>Disadvantages:</para>

        <itemizedlist>
          <listitem>
            <para>Querying the topmost class in the hierarchy is expensive as
            one query is required for each subclass table. Querying subclasses
            is just as efficient as flat mapping.</para>
          </listitem>

          <listitem>
            <para>References to and collections and maps of the topmost class
            are not supported.</para>
          </listitem>
        </itemizedlist>

        <para>The .jdo meta data for the FarmAnimal hierarchy in the demo is
        as follows:</para>

        <programlisting>&#60;jdo&#62;
    &#60;package name=&#34;inheritance.model&#34;&#62;
        &#60;class name=&#34;FarmAnimal&#34;&#62;
            &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-inheritance&#34; 
                    value=&#34;horizontal&#34; /&#62;
        &#60;/class&#62;
        &#60;class name=&#34;Cow&#34; persistence-capable-superclass=&#34;FarmAnimal&#34; 
                identity-type=&#34;application&#34;
                objectid-class=&#34;inheritance.model.Cow$ID&#34;&#62;
            &#60;field name=&#34;number&#34; primary-key=&#34;true&#34; /&#62;
        &#60;/class&#62;
        &#60;class name=&#34;Sheep&#34; persistence-capable-superclass=&#34;FarmAnimal&#34;&#62;
        &#60;/class&#62;
    &#60;/package&#62;
&#60;/jdo&#62;</programlisting>
      </section>

      <section id="flat_and_vertical">
        <title>Mixed Flat and Vertical<indexterm><primary>mixed inheritance
        mapping</primary></indexterm></title>

        <para>Versant Open Access supports mixing flat and vertical mappings
        in the same hierarchy. You could use vertical mapping for seldom used
        subclasses with many large fields to save database space for example.
        To enable vertical mapping for a subclass just change the inheritance
        strategy to &#34;vertical&#34; as shown in this portion of the class
        properties form.</para>

        <para><inlinemediaobject><imageobject><imagedata
        fileref="images/pet_mixed.png" /></imageobject></inlinemediaobject></para>

        <para>If both <classname>Dog</classname> and <classname>Cat</classname>
        are changed to vertical with <classname>WeinerDog</classname> and
        <classname>Rottweiler</classname> left flat the hierarchy will be
        mapped to 3 database tables as shown below. A discriminator column (<literal>jdo_class</literal>)
        is added to the base table to distinguish between
        <classname>Dog</classname>, <classname>WeinerDog</classname> and
        <classname>Rottweiler</classname>.</para>

        <para><inlinemediaobject><imageobject><imagedata
        fileref="images/pet_mixed_tables.png" /></imageobject></inlinemediaobject></para>

        <para>The .jdo meta data is as follows:</para>

        <programlisting>&#60;jdo&#62;
    &#60;package name=&#34;inheritance.model&#34;&#62;
        &#60;class name=&#34;Cat&#34; persistence-capable-superclass=&#34;Pet&#34;&#62;
            &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-inheritance&#34; value=&#34;vertical&#34; /&#62;
        &#60;/class&#62;
        &#60;class name=&#34;Dog&#34; persistence-capable-superclass=&#34;Pet&#34;&#62;
            &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-inheritance&#34; value=&#34;vertical&#34; /&#62;
        &#60;/class&#62;
        &#60;class name=&#34;Pet&#34; /&#62;
        &#60;class name=&#34;Rottweiler&#34; persistence-capable-superclass=&#34;Dog&#34; /&#62;
        &#60;class name=&#34;WienerDog&#34; persistence-capable-superclass=&#34;Dog&#34; /&#62;
    &#60;/package&#62;
&#60;/jdo&#62;</programlisting>
      </section>

      <section id="inheritance_defaults">
        <title>Mapping Defaults<indexterm><primary>inheritance mapping
        defaults</primary></indexterm></title>

        <para>The default inheritance mapping strategies can be set by
        selecting <command>File | Project Properties | Datastore / General</command>
        in the Workbench. Selecting <literal>NO</literal> for the
        <command>Discriminator column</command> field will disable use of a
        discriminator column by default. The <literal>{fullname}</literal> and
        <literal>{name}</literal> options use the fully qualified name or
        unqualified (i.e. no package) name of the class respectively. The
        <literal>{hash}</literal> option (the default) uses a 32 bit positive
        hash of the class name.</para>

        <para><inlinemediaobject><imageobject><imagedata
        fileref="images/inheritance_defaults.png" /></imageobject></inlinemediaobject></para>

        <para>You can also edit the .properties file directly:</para>

        <programlisting>versant.ext.jdbc-inheritance=vertical
versant.ext.jdbc-class-id={name}</programlisting>
      </section>

      <section id="changing_class_names">
        <title>Discriminator Column<indexterm><primary>changing class names</primary></indexterm><indexterm><primary>discriminator
        column</primary></indexterm><indexterm><primary>jdo_class column</primary></indexterm></title>

        <para>The discriminator column is used to identify the type of each
        row with flat mapping (and optionally vertical mapping). It is mapped
        to a SQL INTEGER if all of the discriminator values are ints, and a
        SQL VARCHAR otherwise, but can be changed using the Workbench or
        editing the <literal>jdbc-class-id</literal> extension (see <xref
        linkend="md_jdbc_class_id" />) for the least derived class in the meta
        data. The default class-id (or discriminator) value for a class is a
        32 bit positive hash of the fully qualified class name. You can change
        the default in the Workbench (see <xref linkend="inheritance_defaults" />).
        In particular the default can be changed to the fully qualified name
        of the class or the name without package.</para>

        <para>If you are using the default class-id values be careful if you
        change the name or package of a class in a hierarchy. The
        automatically generated class-id used in the discriminator column will
        change invalidating existing data. You can either specify the old
        class-id as shown in the following example (see <xref
        linkend="md_jdbc_class_id" />) or update the table.</para>

        <para>The following example maps the class-id column to a TINYINT and
        specifies new class-id values that will fit into a byte field:</para>

        <programlisting>&#60;jdo&#62;
    &#60;package name=&#34;inheritance.model&#34;&#62;
        &#60;class name=&#34;Cat&#34; persistence-capable-superclass=&#34;Pet&#34;&#62;
            &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-class-id&#34; value=&#34;12&#34; /&#62;
        &#60;/class&#62;
        &#60;class name=&#34;Dog&#34; persistence-capable-superclass=&#34;Pet&#34;&#62;
            &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-class-id&#34; value=&#34;4&#34; /&#62;
        &#60;/class&#62;
        &#60;class name=&#34;Pet&#34;&#62;
            &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-class-id&#34; value=&#34;8&#34;&#62;
                &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-column&#34;&#62;
                    &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-type&#34; value=&#34;TINYINT&#34; /&#62;
                &#60;/extension&#62;
            &#60;/extension&#62;
        &#60;/class&#62;
        &#60;class name=&#34;Rottweiler&#34; persistence-capable-superclass=&#34;Dog&#34;&#62;
            &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-class-id&#34; value=&#34;6&#34; /&#62;
        &#60;/class&#62;
        &#60;class name=&#34;WienerDog&#34; persistence-capable-superclass=&#34;Dog&#34;&#62;
            &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-class-id&#34; value=&#34;2&#34; /&#62;
        &#60;/class&#62;
    &#60;/package&#62;
&#60;/jdo&#62;</programlisting>
      </section>

      <section id="flat_no_descriminator">
        <title>Flat with No Discriminator<indexterm><primary>flat inheritance</primary></indexterm><indexterm><primary>inheritance
        flat</primary></indexterm></title>

        <para>Normally a discriminator column is required for flat
        inheritance. However if each class in the hierarchy has at most one
        subclass, then the discriminator can be disabled and all rows are
        considered instances of the leaf class of the hierarchy. A
        JDOUserException is thrown on any attempt to persist a non-leaf-class
        instance. Queries, navigation and getObjectById calls always return
        instances of the leaf class.</para>

        <para>One use-case for this feature is to add behaviour (and data) to
        classes that are automatically generated by a tool. Subclassing each
        generated class and using this mapping option avoids mixing generated
        and hand written code in the same class. The database structure and
        generated SQL are as if the subclass behaviour and fields had been
        merged into the base class.</para>
      </section>
    </section>

    <section id="optimistic_locking">
      <title>Optimistic Locking<indexterm><primary>optimistic locking</primary></indexterm></title>

      <para>Optimistic (also known as long) transactions (see <xref
      linkend="optimistic_transactions" />) are supported by adding a version
      or timestamp column to the table for the class. Three different
      optimistic locking modes are available (see <xref
      linkend="md_jdbc_optimistic_locking" />) and optimistic locking may be
      disabled. They all work by including the old value of a column (or
      columns) in the where clause when doing updates and deletes and updating
      the column (or columns) on each update. The optimistic locking column
      can be an existing timestamp or int field in your class or one may be
      added automatically. The automatically added field is called
      <literal>&#60;opt-lock&#62;</literal> in the Workbench.</para>
    </section>

    <section id="persistent_interfaces">
      <title>Persistent Interfaces<indexterm><primary>persistent interfaces</primary></indexterm><indexterm><primary>interfaces</primary></indexterm></title>

      <para>Interface references are not persistent by default with JDO 1.0.1
      but it is likely that they will be supported in JDO 2.0. Versant Open
      Access has support for persistent interfaces as an extension. You can
      add interfaces to your project in the same way that classes are added.
      The interfaces themselves are not persistent (as they have no fields)
      but references to persistent interfaces (e.g. &#39;<classname>private
      MyInterface ref</classname>&#39;) are persistent by default.</para>

      <para>Persistent interfaces are displayed in the tree view of the
      project. <classname>HasAddress</classname> in the following image is a
      persistent interface.</para>

      <para><inlinemediaobject><imageobject><imagedata
      fileref="images/interface_on_tree.png" /></imageobject></inlinemediaobject></para>

      <para>The mapping of the references themselves is explained in <xref
      linkend="mapping_interface_field" />. The .jdo meta data for this
      example is shown below:</para>

      <programlisting>&#60;package name=&#34;model&#34;&#62;
    &#60;class name=&#34;Resturant&#34; /&#62;
    &#60;class name=&#34;Supplier&#34; /&#62;
    &#60;class name=&#34;Address&#34; /&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;interface&#34; value=&#34;HasAddress&#34; /&#62;
&#60;/package&#62;</programlisting>

      <para>Currently Versant Open Access does not support Collection&#39;s
      and Map&#39;s of interface types or queries against the extent of an
      interface type (i.e. using an interface as the candidate class for a
      query). These features will be added in a future release. Note that
      efficient queries through interface and Object references are supported
      by downcasting to a persistent class (see <xref
      linkend="casting_in_jdoql" />). They are executed entirely in SQL.</para>
    </section>
  </chapter>

  <chapter id="field_mapping">
    <title id="simple_and_ref_mapping">Simple and Reference Field Mapping<indexterm><primary>field
    mapping</primary></indexterm><indexterm><primary>O/R mapping</primary></indexterm></title>

    <para>Versant Open Access supports flexible mappings from Java types (e.g.
    java.lang.String) to JDBC types (e.g. VARCHAR) to database specific SQL
    types (e.g. VARCHAR2 on Oracle). The default mappings can be customised
    for a datastore in the Versant Open Access Workbench. The mapping for
    specific fields can also be customised. Mappings are resolved by first
    using any information specified for the field, then looking up a JDBC type
    for the type of the field using the Java Type Mapping, then converting
    this JDBC type into actual SQL type information using the JDBC Type
    Mapping. You can have different mapping information for each database
    supported by Versant Open Access. The default mappings for each database
    are in <xref linkend="database_specific_information" />.</para>

    <para>FIelds of any type can be persisted using externalization to another
    persistent type (typically a byte[] or String). By default externalized
    fields are stored using Java serialization but user defined externalizers
    can be written to support other formats. You can add externalized type
    mappings for any class (<xref linkend="externalized_types" />) and all
    fields of that type will be considered persistent.</para>

    <para>When working with JDBC direct interaction with ResultSet&#39;s and
    PreparedStatement&#39;s may be necessary to access proprietary JDBC
    features or to work around bugs in JDBC drivers. This can be achieved
    using JDBC custom type mappings and JdbcConverter&#39;s (see <xref
    linkend="custom_type_mappings" />).</para>

    <para>Versant Open Access supports sharing of columns between different
    fields. This is very useful when mapping to legacy database schemas. It is
    possible to use a reference to a PC class as part of the primary key or to
    use the primary key of a table as part of a foreign key reference to
    another table.</para>

    <section id="datastore_mappings">
      <title>JDBC Type Mappings<indexterm><primary>Java type mappings</primary></indexterm><indexterm><primary>JDBC
      type mappings</primary></indexterm><indexterm><primary>datastore
      mappings</primary></indexterm></title>

      <para>You can change the default mappings for a datastore by selecting
      <command>File | Project &#38; Datastore Properties</command> and
      choosing the <command>Java Type Mapping</command> or <command>JDBC Type
      Mapping</command> on the tree. The mappings drop down selects the
      database type to define mappings for. You can edit mappings for all
      database types by selecting <command>all</command> in the drop down.
      Mappings cascade so you can set the default length of the JDBC type
      VARCHAR for all databases to 250 and still make it 4000 for Oracle. The
      drop downs always display the default value in round brackets. The
      defaults for all database are taken from the current database selected
      for the datastore.</para>

      <para>The JDBC type mappings form is shown below. Properties set for a
      given JDBC type (e.g. <literal>VARCHAR</literal>) become the defaults
      for columns of that type. Individual Java Type mappings and fields can
      still change individual column properties.</para>

      <para><inlinemediaobject><imageobject><imagedata
      fileref="images/jdbc_type_mapping.png" /></imageobject></inlinemediaobject></para>
    </section>

    <section id="externalized_types">
      <title>Externalized Types<indexterm><primary>externalized field types</primary></indexterm><indexterm><primary>custom
      type mappings</primary></indexterm></title>

      <para>It is easy to make any class a persistent field type by adding it
      to the project externalized types in the Workbench. By default
      externalized fields are converted to byte[] using Java serialization but
      this can be customized. Changes to fields within externalized types are
      not tracked so values of externalized types should be treated as
      immutable (i.e. set a new instance instead of changing the internal
      state of the existing instance). If you do change the internal state of
      a externalized type you can call <literal>JDOHelper.makeDirty(Object
      pc,String fieldname)</literal> so that the change will be persisted.</para>

      <para>Install an externalizer for any persistent field type using the
      project properties dialog in the Workbench. Click the
      <command>Add Externalized Type</command> button to add a new type. By
      default the type will be serialized to a byte[] using Java
      serialization. You can change this by selecting a different externalizer
      using the drop down or by writing your own (see <xref
      linkend="writing_externalizers" />). All fields of these types will then
      be considered persistent and will be in the default fetch group (just
      like <literal>java.lang.String</literal>).</para>

      <para><inlinemediaobject><imageobject><imagedata
      fileref="images/externalized_types.png" /></imageobject></inlinemediaobject></para>

      <para>The externalization demo (in <filename>demos/externalization</filename>)
      is used as an example.</para>

      <section id="externalizer_string">
        <title>String Types<indexterm><primary>custom string types</primary></indexterm></title>

        <para>If your type has a constructor that accepts a
        <classname>String</classname> then you can select an Externalizer
        called STRING from the drop down. This externalizer will use the
        <classname>String</classname> constructor to create new instances from
        data read from the database. The type&#39;s <literal>toExternalString</literal>
        or <literal>toString</literal> method is used to externalize it for
        storage. Here is the <classname>PhoneNumber</classname> class from the
        externalization demo:</para>

        <programlisting>public class PhoneNumber {
    private String countryCode;
    private String areaCode;
    private String number;

    /**
     * Create from a String formatted like +27 21 6703940. Versant Open Access uses
     * this method to create an instance from a String read from the
     * database.
     */
    public PhoneNumber(String s) {
        ... parse String and fill fields ...
    }

    /**
     * Versant Open Access uses this method to get the String to store in the database.
     * If there is a toExternalString method then it is used instead.
     */
    public String toString() {
        return &#34;+&#34; + countryCode + &#34; &#34; + areaCode + &#34; &#34; + number;
    }
...
}</programlisting>
      </section>

      <section id="externalizer_bytes">
        <title>byte[] Types<indexterm><primary>custom byte[] types</primary></indexterm></title>

        <para>If your type has a constructor that accepts a
        <literal>byte[]</literal> and a method public <literal>byte[]
        toBytes()</literal> then you can select an Externalizer called BYTES
        from the drop down. This externalizer will use the <literal>byte[]</literal>
        constructor to create new instances from data read from the database.
        The <literal>toBytes</literal> method is used to externalize it for
        storage. Here is the <literal>PngImage</literal> class from the
        customtypes demo:</para>

        <programlisting>public class PngImage implements Icon {
    private transient BufferedImage image;

    /**
     * Versant Open Access uses this constructor after the bytes for the image have
     * been read from the database.
     */
    public PngImage(byte[] a) {
        try {
            image = ImageIO.read(new ByteArrayInputStream(a));
        } catch (IOException e) {
            throw new IllegalArgumentException(e.toString());
        }
    }

    /**
     * Versant Open Access calls this method when it needs to store the image in the
     * database.
     */
    public byte[] toBytes() {
        ByteArrayOutputStream o = new ByteArrayOutputStream(1024);
        try {
            ImageIO.write(image, &#34;PNG&#34;, o);
        } catch (IOException e) {
            throw new IllegalStateException(e.toString());
        }
        return o.toByteArray();
    }
...
}</programlisting>
      </section>

      <section id="writing_externalizers">
        <title>Writing Externalizer&#39;s<indexterm><primary>writing
        Externalizer&#39;s</primary></indexterm><indexterm><primary>Externalizer</primary></indexterm></title>

        <para>Externalizer&#39;s are usually used to convert a non-persistent
        type into a persistent type for persistence. However they can also be
        used just to change one type into another. For example you could
        persist a Collection of String by externalizing it and writing an
        Externalizer to flatten it into a single comma separated String for
        storage. The source for the built in Externalizer&#39;s is provided in
        <filename>src/com/versant/core/jdo/externalizer</filename>.</para>
      </section>
    </section>

    <section id="mapping_simple_field">
      <title>Mapping a Simple Field<indexterm><primary>simple field mapping</primary></indexterm></title>

      <para>The default mapping (column properties) for a simple field are
      taken from the datastore mappings and database mappings as described in
      the previous section. It is easiest to edit the mapping use the tree
      view in the Workbench as shown in the following screenshot:</para>

      <para><inlinemediaobject><imageobject><imagedata
      fileref="images/mapping_simple_field.png" /></imageobject></inlinemediaobject></para>

      <para>To edit the properties for a column on the E/R diagram just double
      click it:</para>

      <para><inlinemediaobject><imageobject><imagedata
      fileref="images/edit_column.png" /></imageobject></inlinemediaobject></para>

      <para>You can edit properties for any table on the E/R diagram by double
      clicking it:</para>

      <para><inlinemediaobject><imageobject><imagedata
      fileref="images/edit_table.png" /></imageobject></inlinemediaobject></para>

      <para>You can also edit the .jdo meta data directly. Use one or more
      <command>jdbc-column</command> extensions (see <xref
      linkend="md_jdbc_column" />) to change the defaults for each field. You
      will only need one <command>jdbc-column</command> extension unless you
      require different mappings for different database types. This example
      changes the length (precision) and scale of a field to 10,2 for all
      databases and 12,4 for SAP DB.</para>

      <programlisting>&#60;field name=&#34;qty&#34;&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-column&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-length&#34; value=&#34;10&#34; /&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-scale&#34; value=&#34;2&#34; /&#62;
    &#60;/extension&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-column&#34; value=&#34;sapdb&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-length&#34; value=&#34;12&#34; /&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-scale&#34; value=&#34;4&#34; /&#62;
    &#60;/extension&#62;
&#60;/field&#62;</programlisting>

      <section id="using_clob_or_text_columns">
        <title>Using CLOB or TEXT Columns<indexterm><primary>CLOB columns</primary></indexterm><indexterm><primary>TEXT
        columns</primary></indexterm></title>

        <para>String fields are normally mapped to a VARCHAR column. To map to
        a CLOB or TEXT column specify a JDBC type of CLOB. An appropriate SQL
        type and JdbcConverter are selected depending on the database type.
        This is easy to do in the Workbench or you can edit the meta data
        directly:</para>

        <programlisting>&#60;field name=&#34;description&#34;&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-column&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-type&#34; value=&#34;CLOB&#34; /&#62;
    &#60;/extension&#62;
&#60;/field&#62;</programlisting>

        <warning>
          <para>LONG columns are broken in SAP DB 7.3. See <xref
          linkend="sapdb" /> for details.</para>
        </warning>
      </section>

      <section id="using_blob_or_image_columns">
        <title>Using BLOB, IMAGE and VARBINARY Columns<indexterm><primary>BLOB
        columns</primary></indexterm><indexterm><primary>IMAGE columns</primary></indexterm><indexterm><primary>VARBINARY
        columns</primary></indexterm></title>

        <para>Embedded fields and arrays of primitive types (byte[], int[]
        etc.) are mapped to a BLOB column by default. If your field is small
        (255 bytes or less) you may be able to use a VARBINARY column instead.
        To map to a VARBINARY column specify a JDBC type of VARBINARY. An
        appropriate SQL type and JdbcConverter are selected depending on the
        database type. If the target database only has a BLOB type then this
        will be used instead.</para>

        <programlisting>&#60;field name=&#34;binaryData&#34;&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-column&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-type&#34; value=&#34;VARBINARY&#34; /&#62;
    &#60;/extension&#62;
&#60;/field&#62;</programlisting>

        <warning>
          <para>LONG BYTE columns are broken in SAP DB 7.3. See <xref
          linkend="sapdb" /> for details.</para>
        </warning>
      </section>

      <section id="oracle_long_columns">
        <title>Oracle LONG and LONG RAW Columns<indexterm><primary>Oracle LONG
        and LONG RAW columns</primary></indexterm></title>

        <para>Oracle recommends that applications use CLOB and BLOB columns
        instead of LONG and LONG RAW columns. This option is only provided for
        compatibility with existing database schema&#39;s.</para>

        <para>You may only have one LONG or LONG RAW column per table. Also
        the Oracle JDBC driver requires that the data for a LONG or LONG RAW
        column be read before any CLOB or BLOB columns in the same result row.
        This is a problem as Versant Open Access will often join columns for
        several instances into a single row to improve performance. The
        easiest way to disable this is to set
        default-fetch-group=&#34;false&#34; on the field mapped to the LONG
        column so it is fetched with a separate query when touched.
        Alternately make sure that all references to and from the class with
        the LONG field are not in the default fetch group.</para>

        <para>To use a LONG column for one of your fields on Oracle change the
        JDBC type of the field to LONGVARCHAR. The column will still be mapped
        to a TEXT or CLOB on other databases. For embedded fields (e.g.
        byte[]) mapped to a LONG RAW column change the JDBC type to
        LONGVARBINARY.</para>

        <programlisting>&#60;field name=&#34;description&#34;&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-column&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-type&#34; value=&#34;LONGVARCHAR&#34; /&#62;
    &#60;/extension&#62;
&#60;/field&#62;</programlisting>
      </section>
    </section>

    <section id="mapping_ref_field">
      <title>Mapping a Reference Field<indexterm><primary>reference field
      mapping</primary></indexterm></title>

      <para>The default mapping (column properties) for a reference field are
      taken from the primary key column(s) of the referenced class. You should
      be careful if you change anything other than name of the column as it
      must be comparable with the referenced primary key in SQL statements.</para>

      <para>You can also choose to externalize the referenced object (e.g.
      serialize it to a BLOB, see <xref linkend="externalized_types" />) or
      embed its fields in the table for the referencing class (see <xref
      linkend="embedded_references" />). Usually it is better to use embedding
      as BLOBs do not support queries.</para>

      <para>It is easiest to edit the mapping using the tree view in the
      Workbench as shown in the following screenshot.</para>

      <para><inlinemediaobject><imageobject><imagedata
      fileref="images/mapping_ref_field.png" /></imageobject></inlinemediaobject></para>

      <para>You can edit the column and table properties by double clicking
      the elements on the E/R diagram. You can also edit properties for the
      reference in the same way:</para>

      <para><inlinemediaobject><imageobject><imagedata
      fileref="images/edit_foreign_key_ref.png" /></imageobject></inlinemediaobject></para>

      <para>The top set of radio buttons controls the type of join Versant
      Open Access will use when prefetching the referenced object (e.g. if you
      put the field in the default fetch group). Do not select INNER unless
      you are sure of your database referential integrity and the reference
      cannot be null. If you select INNER and the referenced object does not
      exist rows will be silently lost from queries.</para>

      <para>The bottom set of radio buttons control constraint generation.
      Note that some databases do not support referential integrity
      constraints on columns that allow nulls in which case the constraint
      will not be generated.</para>

      <para>The way the mapping for a reference field is defined in the meta
      data depends on the type of primary key of the referenced class.</para>

      <section id="ref_to_single_column_pk">
        <title>Reference to Single Column Primary Key</title>

        <para>If the primary key of the referenced class consists of a single
        column then column properties are set using <command>jdbc-column</command>
        extensions in the same was as done for a simple field:</para>

        <programlisting>&#60;field name=&#34;customer&#34;&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-column&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-column-name&#34; value=&#34;custid&#34; /&#62;
    &#60;/extension&#62;
&#60;/field&#62;</programlisting>

        <para>As with simple fields it is easiest to edit mappings using the
        Workbench. If you choose &#34;Ref&#34; in the &#34;Field View&#34;
        dropdown the fields grid will show only reference fields with grid
        column headers for column properties. You can edit the properties on
        the grid or in the field properties dialog.</para>
      </section>

      <section id="ref_to_composite_pk">
        <title>Reference to Composite Primary Key<indexterm><primary>composite
        primary key</primary></indexterm></title>

        <para>If the referenced class has a composite primary key (more than
        one column i.e. application identity with more than one primary key
        field) then you must use a <command>jdbc-ref</command> extension (see
        <xref linkend="md_jdbc_ref" />) for each field in the primary key:
        Using composite primary keys is not recommended but is often required
        to map to legacy database schema&#39;s.</para>

        <programlisting>&#60;field name=&#34;refa&#34;&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-ref&#34; value=&#34;partA&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-column&#34;&#62;
            &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-column-name&#34; value=&#34;foo&#34; /&#62;
        &#60;/extension&#62;
    &#60;/extension&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-ref&#34; value=&#34;partB&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-column&#34;&#62;
            &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-column-name&#34; value=&#34;bar&#34; /&#62;
        &#60;/extension&#62;
    &#60;/extension&#62;
&#60;/field&#62;</programlisting>

        <para>It is easiest to edit the column mappings using the &#34;Edit
        Columns&#34; button on the &#34;Field Properties&#34; window in the
        Workbench.</para>
      </section>

      <section id="embedded_references">
        <title>Embedded References<indexterm><primary>embedded references</primary></indexterm></title>

        <para>If a reference field is mapped as embedded then its fields are
        included in the table for the referencing class.</para>

        <para>For example: <literal>Person</literal> has a <literal>Address
        address</literal> reference. If you mark the <literal>address</literal>
        reference field as embedded then columns for the <literal>street</literal>
        and <literal>city</literal> fields of <literal>Address</literal> will
        be created in the table for <literal>Person</literal>. The
        <literal>City city</literal> reference field on <literal>Address</literal>
        can also be marked as embedded and this would then again result in all
        the fields of <literal>City</literal> to be created in the referers
        table. In this case the referer is <literal>Address</literal>, but as
        it is already embedded on <literal>Person</literal>, the columns for
        the fields will be included in the table for <literal>Person</literal>.</para>

        <para><inlinemediaobject><imageobject><imagedata
        fileref="images/embedded_ref.png" /></imageobject></inlinemediaobject></para>

        <para>There are two ways to mark a field as embedded.</para>

        <para>It can be done when the class is described in the jdo metadata.
        This field would then always be embedded.</para>

        <programlisting>    &#60;package name=&#34;embedded.model&#34;&#62;
        &#60;class name=&#34;Person&#34;&#62;
            &#60;field name=&#34;address&#34; embedded=&#34;true&#34;/&#62;
        &#60;/class&#62;
        &#60;class name=&#34;Address&#34;/&#62;
    &#60;/package&#62;</programlisting>

        <para>It can be done in the context of another embedded field. This is
        usefull if you don&#39;t want the field to be embedded by default.</para>

        <programlisting>    &#60;package name=&#34;embedded.model&#34;&#62;
        &#60;class name=&#34;Person&#34;&#62;
            &#60;field name=&#34;address&#34; embedded=&#34;true&#34;&#62;
                &#60;extension vendor-name=&#34;versant&#34; key=&#34;field&#34; value=&#34;city&#34;&#62;
                    &#60;extension vendor-name=&#34;versant&#34; key=&#34;embedded&#34; value=&#34;true&#34; /&#62;
                &#60;/extension&#62;
            &#60;/field&#62;
        &#60;/class&#62;
        &#60;class name=&#34;Address&#34;/
        &#60;class name=&#34;City&#34;/&#62;
    &#60;/package&#62;</programlisting>

        <para>Embedded references behave like SCO instance and therefore they
        have no identity. The <literal>address</literal> and
        <literal>city</literal> instances are only obtainable from their
        <literal>Person</literal> owner.</para>

        <para>Embedded self references are allowed. In other words
        <literal>Person</literal> could have a self reference to
        <literal>Person</literal> and mark it as embedded. This behaviour is
        not recursive and the depth is only as far as is described in the
        metadata.</para>

        <para>By default an embedded reference (eg <literal>Address address</literal>
        on <literal>Person</literal>) will always return non-null (i.e.
        <literal>Person.getAddress()</literal> will always return an
        <literal>Address</literal> instance) even if it was null when the
        <literal>Person</literal> instance was persisted. The
        <literal>null-indicator</literal> extension is used to specify which
        field on the embedded instance should be used to determine if the
        embedded instance is null. If this field is null then the whole
        instance is considered null.</para>

        <programlisting>    &#60;class name=&#34;EmbeddedSelfRef&#34;&#62;
        &#60;field name=&#34;next&#34; embedded=&#34;true&#34;&#62;
            &#60;extension vendor-name=&#34;versant&#34; key=&#34;field&#34; value=&#34;next&#34;&#62;
                &#60;extension vendor-name=&#34;versant&#34; key=&#34;embedded&#34; value=&#34;false&#34; /&#62;
                &#60;extension vendor-name=&#34;versant&#34; key=&#34;default-fetch-group&#34; value=&#34;true&#34; /&#62;
            &#60;/extension&#62;
            &#60;extension vendor-name=&#34;versant&#34; key=&#34;field&#34; value=&#34;val&#34;&#62;
                &#60;extension vendor-name=&#34;versant&#34; key=&#34;null-indicator&#34; value=&#34;true&#34; /&#62;
            &#60;/extension&#62;
        &#60;/field&#62;
    &#60;/class&#62;</programlisting>

        <para>In this example the <literal>next</literal> field is returned as
        null if <literal>next.val</literal> is null.</para>

        <para>If a class is always embedded (ie not used on its own), then the
        <literal>do-not-create-table</literal> property can be used to stop
        the table from being created.</para>
      </section>
    </section>

    <section id="mapping_interface_field">
      <title>Mapping an Interface or Object Reference<indexterm><primary>interface
      reference mapping</primary></indexterm><indexterm><primary>object
      reference mapping</primary></indexterm><indexterm><primary>polymorphic
      reference mapping</primary></indexterm></title>

      <para>Interface and <classname>java.lang.Object</classname> reference
      fields are not persistent by default. You can make an interface or
      Object field persistent by right clicking the class in the tree view and
      selecting <command>Add Fields</command>. You can also make the interface
      itself persistent by adding it to the project (see <xref
      linkend="persistent_interfaces" />).This will make all references to it
      persistent.</para>

      <para>Interface and reference fields are mapped to a column identifying
      the type of the referenced instance and one or more columns to hold its
      primary key. You can configure which classes are allowed and define the
      mapping between classes and type codes. If no classes are listed then
      any class with a primary key compatible with the columns defined in the
      mapping is allowed.</para>

      <para>You can also choose to externalize the referenced object (e.g.
      serialize it to a BLOB, see <xref linkend="externalized_types" />).</para>

      <para>The following screenshot shows the configuration of the model for
      the interfaces demo in <filename>demos/interfaces</filename>:</para>

      <para><inlinemediaobject><imageobject><imagedata
      fileref="images/interfaces_demo_tree.png" /></imageobject></inlinemediaobject></para>

      <para>If no valid classes are listed (as in this example) then the
      class-id of the referenced class is used as a value for the class (or
      type) column. You can define your own type code mapping by listing the
      valid classes and capturing an ID for each on the grid:</para>

      <para><inlinemediaobject><imageobject><imagedata
      fileref="images/interface_string_codes.png" /></imageobject></inlinemediaobject></para>

      <para>If all the ID values are ints then the default class column will
      be an int (INTEGER). If any of the values are not ints (i.e. they are
      String&#39;s as in the above sceenshot) then a String (VARCHAR) column
      is created. You can edit the column properties by double clicking it.
      The .jdo meta data for this example is as follows:</para>

      <programlisting>&#60;field name=&#34;owner&#34;&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;valid-class&#34; value=&#34;Resturant=R&#34; /&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;valid-class&#34; value=&#34;Supplier=S&#34; /&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-class-id&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-column&#34;&#62;
            &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-length&#34; value=&#34;10&#34; /&#62;
        &#60;/extension&#62;
    &#60;/extension&#62;
&#60;/field&#62;</programlisting>

      <section id="interface_ref_to_composite_pk">
        <title>Reference to Composite Primary Key<indexterm><primary>composite
        primary key</primary></indexterm></title>

        <para>All the possible referenced classes must have the same number of
        primary key columns. In addition the columns must be compatible in an
        SQL sense as Versant Open Access will generate joins for queries
        involving the reference (see <xref linkend="casting_in_jdoql" />). If
        you list valid classes for the reference then the primary key of the
        first class in the list will be used as a template for the default
        reference column(s). If you do not list any valid classes then a int
        (INTEGER) column is assumed. This will hold a reference to any
        datastore identity class. You can add more columns by right-clicking
        on the diagram and selecting <command>Add Reference Column</command>.</para>
      </section>
    </section>

    <section id="sharing_columns">
      <title>Mapping Fields To The Same Columns<indexterm><primary>sharing
      columns between fields</primary></indexterm><indexterm><primary>mapping
      fields to the same columns</primary></indexterm></title>

      <para>Versant Open Access supports mapping different fields to the same
      database columns. This makes it easier to map to complex legacy database
      schemas and can also improve performance.</para>

      <para>When a set of fields all share a common column Versant Open Access
      decides which field to use in insert and update SQL statements when the
      server starts. Updates to the common column for the other fields are
      ignored. This is much faster than deferring this decision to commit time
      and looking at the dirty fields in each instance. The following
      algorithm is used to select the field with the updatable column from the
      fields in the set:</para>

      <orderedlist>
        <listitem>
          <para>If one of the fields has primary-key=true then it is selected.</para>
        </listitem>

        <listitem>
          <para>Fields in a class are used ahead of fields from its
          subclasses.</para>
        </listitem>

        <listitem>
          <para>Simple fields are selected before reference fields (e.g.
          &#39;String countryCode&#39; will be chosen ahead of &#39;Country
          country&#39;).</para>
        </listitem>

        <listitem>
          <para>Reference fields with less columns are selected before those
          with more columns.</para>
        </listitem>

        <listitem>
          <para>The field names are sorted alphabetically and the first one
          selected.</para>
        </listitem>
      </orderedlist>

      <para>Normally it is best to update all fields with columns in common
      when you want the instance to change. That way your are sure that your
      change will reach the database and the instance is as it will be next
      time it is loaded from the database.</para>

      <section id="ref_in_pk">
        <title>Using a Reference in the Primary Key<indexterm><primary>reference
        as primary key</primary></indexterm><indexterm><primary>legacydb demo</primary></indexterm></title>

        <para>Versant Open Access supports using reference fields in the
        primary key for a class using application identity. However this has
        to be done using an extra simple field as shown in this example from
        <filename>demos/legacydb</filename>.</para>

        <para>Here are the branch and supplier tables:</para>

        <programlisting>create table branch (
    branch_no SMALLINT not null,
    nme VARCHAR(30) not null,
    constraint pk_branch primary key (branch_no)
);

create table supplier (
    branch_no SMALLINT not null,
    supplier_no SMALLINT not null,
    nme VARCHAR(30) not null,
    constraint pk_supplier primary key (branch_no, supplier_no)
);

alter table supplier add constraint ref_supplier_branch
  foreign key (branch_no)
  references branch(branch_no) match full;</programlisting>

        <para>Here are the important parts of the <classname>Branch</classname>
        and <classname>Supplier</classname> classes that are mapped to these
        tables:</para>

        <programlisting>public class Branch {
    private int branchNo;   // pk, branch_no <co id="refpk_branch_pk" />
    private String name;
    ...

    public static class ID implements Serializable { <co id="refpk_branch_id" />
        public int branchNo;
        ...
    }
}

public class Supplier {
    private int branchNo;       // pk, branch_no <co id="refpk_supplier_no" />
    private int supplierNo;     // pk, supplier_no
    private Branch branch; <co id="refpk_branch_ref" />  // branch_no
    private String name;

    public Supplier(Branch branch, int supplierNo) {
        this.branch = branch;
        branchNo = branch.getBranchNo();
        this.supplierNo = supplierNo;
    }
    ...

    public static class ID implements Serializable { <co
id="refpk_supplier_id" />
        public int branchNo;
        public int supplierNo;
        ...
    }
}</programlisting>

        <calloutlist>
          <callout arearefs="refpk_branch_pk">
            <para>The primary key of Branch is branchNo.</para>
          </callout>

          <callout arearefs="refpk_branch_id">
            <para>The objectid-class for Branch is a static inner class
            including the branchNo field.</para>
          </callout>

          <callout arearefs="refpk_supplier_no">
            <para>The primary key of Supplier is branchNo (mapped to
            branch_no) and supplierNo (mapped to supplier_no). Note that the
            branch reference is not part of the primary key.</para>
          </callout>

          <callout arearefs="refpk_branch_ref">
            <para>The branch reference is declared normally. It is mapped to
            the branch_no column from the primary key in the meta data.</para>
          </callout>

          <callout arearefs="refpk_supplier_id">
            <para>The objectid-class for Supplier includes the branchNo and
            supplierNo fields. The branch reference cannot be used here as pk
            fields must be simple types.</para>
          </callout>
        </calloutlist>

        <para>The branch reference in Supplier is mapped to the branch_no
        column in the primary key.</para>

        <figure>
          <title>Using a Reference in the Primary Key</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/supplier_branch.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>In general any of the foreign key columns making up a reference
        field may be mapped to columns in the primary key of the class or
        another reference field.</para>

        <para>The relevant portions of the .jdo meta data for the example is
        as follows:<programlisting>&#60;class name=&#34;Supplier&#34; identity-type=&#34;application&#34; objectid-class=&#34;Supplier$ID&#34;&#62;
    &#60;field name=&#34;branchNo&#34; primary-key=&#34;true&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-column&#34;&#62;
            &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-type&#34; value=&#34;SMALLINT&#34; /&#62;
        &#60;/extension&#62;
    &#60;/field&#62;
    &#60;field name=&#34;supplierNo&#34; primary-key=&#34;true&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-column&#34;&#62;
            &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-type&#34; value=&#34;SMALLINT&#34; /&#62;
        &#60;/extension&#62;
    &#60;/field&#62;
    &#60;field name=&#34;branch&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-column&#34;&#62;
            &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-column-name&#34; value=&#34;branch_no&#34; /&#62;
        &#60;/extension&#62;
    &#60;/field&#62;
&#60;/class&#62;</programlisting></para>
      </section>

      <section id="simple_field_sharing">
        <title>Using a Foreign Key as a Value<indexterm><primary>foreign key
        as value</primary></indexterm></title>

        <para>A simple field can be mapped to a foreign key column used by a
        reference field. This can improve performance when the value of the
        foreign key column is useful on its own. A good example of this is a
        reference to a Country class using the ISO code as its primary key.
        You may need to display just the country code from the Country and
        want to avoid fetching the Country instance to do this. There is an an
        example of this mapping in <filename>demos/legacydb</filename>.</para>

        <para>The branch and country tables are as follows:</para>

        <programlisting>create table branch (
    branch_no SMALLINT not null,
    nme VARCHAR(30) not null,
    country_code VARCHAR(2),
    constraint pk_branch primary key (branch_no)
);

create table country (
    code VARCHAR(2) not null,
    nme VARCHAR(40) not null,
    constraint pk_country primary key (code)
);

alter table branch add constraint ref_branch_country
    foreign key (country_code)
    references country(code);</programlisting>

        <para>Here are the important parts of the <classname>Branch</classname>
        and <classname>Country</classname> classes that are mapped to these
        tables:</para>

        <programlisting>public class Branch {
    private String name;
    private Country country;
    private String countryCode; <co id="scs_country_code" />
    ...
    public void setCountry(Country country) { <co id="scs_set_country" />
        this.country = country;
        countryCode = country == null ? null : country.getCode();
    }

    public String getCountryCode() {
        return countryCode;
    }
    ...
}

public class Country {
    private String code; // pk  <co id="scs_code" />
    private String name;
    ...
    public static class ID implements Serializable { <co id="scs_id" />
        public String code;
        ...
    }
}</programlisting>

        <calloutlist>
          <callout arearefs="scs_country_code">
            <para>The countryCode field is the same type as the primary key of
            Country.</para>
          </callout>

          <callout arearefs="scs_set_country">
            <para>The setCounty sets the country and countryCode fields.
            Setting only the countryCode field would work but then the
            instance would look different before and after commit. If only the
            country field was set the update would be ignored.</para>
          </callout>

          <callout arearefs="scs_code">
            <para>The primary key of Country is code.</para>
          </callout>

          <callout arearefs="scs_id">
            <para>The objectid-class for Country.</para>
          </callout>
        </calloutlist>

        <para>The countryCode field in branch is mapped to same column as the
        country reference.</para>

        <figure>
          <title>Using a Foreign Key as a Value</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/branch_country.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>The relevant .jdo meta data for the example is as follows:<programlisting>&#60;class name=&#34;Branch&#34; identity-type=&#34;application&#34; objectid-class=&#34;Branch$ID&#34;&#62;
    &#60;field name=&#34;branchNo&#34; primary-key=&#34;true&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-column&#34;&#62;
            &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-type&#34; value=&#34;SMALLINT&#34; /&#62;
        &#60;/extension&#62;
    &#60;/field&#62;
    &#60;field name=&#34;country&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-column&#34;&#62;
            &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-column-name&#34; value=&#34;country_code&#34; /&#62;
        &#60;/extension&#62;
    &#60;/field&#62;
    &#60;field name=&#34;countryCode&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-column&#34;&#62;
            &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-column-name&#34; value=&#34;country_code&#34; /&#62;
            &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-length&#34; value=&#34;2&#34; /&#62;
        &#60;/extension&#62;
    &#60;/field&#62;
&#60;/class&#62;</programlisting></para>
      </section>
    </section>

    <section id="dependent_refs">
      <title>Dependent References / Cascading Deletes<indexterm><primary>dependent
      references</primary></indexterm><indexterm><primary>cascading deletes</primary></indexterm></title>

      <para>Versant Open Access supports dependent references. That is if the
      referencing instance is deleted then the referenced instance is also
      deleted (cascading deletes). This feature must be used with caution as
      Versant Open Access does not check that there are no other references to
      deleted instances. If there are other references at best you will get an
      exception on commit (if there is a constraint) or the transaction will
      succeed and you will get errors when traversing references to the
      deleted instance elsewhere in the application. See <xref
      linkend="md_dependent" />.</para>

      <para>Cascading deletes are disabled by default. It is only enabled for
      references flagged as dependent using the Field Properties window in the
      Workbench or the dependent extension (see <xref linkend="md_dependent" />).</para>

      <para>In this example dependent is true for the Address reference on
      Customer so it is deleted when Customer is deleted.</para>

      <programlisting>public class Address {
    private String street;
    ...
}

public class Customer {
    private Address address;
    ...
}

&#60;class name=&#34;Customer&#34;&#62;
    &#60;field name=&#34;address&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;dependent&#34; value=&#34;true&#34; /&#62;
    &#60;/field&#62;
&#60;/class&#62;</programlisting>

      <para>Note that Versant Open Access also supports cascading deletes for
      collections (see <xref linkend="dependent_collections" />) and can also
      automatically delete certain types of orphan (unreferenced) instances
      (see <xref linkend="deleting_orphans" />).</para>

      <para>The delete-orphans extension is a class level extension (see <xref
      linkend="md_delete_orphans" />) for one-to-many relationships
      implemented using an inverse foreign key (e.g. Order and OrderLine in
      tut1, see <xref linkend="inverse_foreign_key_mapping" />). If
      delete-orphans is true for OrderLine then any instance that ends up with
      a null Order reference (parent) when a transaction is committed is
      deleted. This is very useful when the child class can have more than one
      parent class. All the parents must be null before it is deleted.</para>
    </section>

    <section id="autoset_fields">
      <title>Autoset Fields<indexterm><primary>autoset fields</primary></indexterm></title>

      <para>Versant Open Access can automatically populate timestamp and
      increment int (version number) fields when new instances are created
      and/or when existing instances are modified (see <xref
      linkend="md_autoset" />). This is very useful when using remote
      persistence managers. Normally to fill a lastModifiedDate field a call
      has to be made to the server to retrieve the current date (the time on
      the client is not trusted). With the autoset option this extra call is
      not required. Here is an example using the autoset extension to fill the
      dateCreated and dateLastModified fields for a class (this can also be
      done by editing field properties in the Workbench):</para>

      <programlisting>&#60;class name=&#34;Order&#34;&#62;
    &#60;field name=&#34;dateCreated&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;autoset&#34; value=&#34;created&#34; /&#62;
    &#60;/field&#62;
    &#60;field name=&#34;dateLastModified&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;autoset&#34; value=&#34;both&#34; /&#62;
    &#60;/field&#62;
&#60;/class&#62;</programlisting>
    </section>

    <section id="custom_type_mappings">
      <title>Custom JDBC Field Types<indexterm><primary>custom JDBC field
      types</primary></indexterm><indexterm><primary>custom JDBC type mappings</primary></indexterm></title>

      <para>When working with JDBC direct interaction with ResultSet&#39;s and
      PreparedStatement&#39;s may be necessary to access proprietary JDBC
      features or to work around bugs in JDBC drivers. Note that unless you
      need direct access to ResultSet&#39;s and PreparedStatement&#39;s use
      externalization for custom data types (see <xref
      linkend="externalized_types" />). Externalizer&#39;s are easier to write
      and also work for non-JDBC datastores.</para>

      <para>It is easy to install a converter for any persistent field type
      using the project Java type mappings in the Workbench. Click the Add
      Custom Mapping button to add a new type:</para>

      <para><inlinemediaobject><imageobject><imagedata
      fileref="images/java_type_mapping.png" /></imageobject></inlinemediaobject></para>

      <para>All fields of these types will then be considered persistent and
      will be in the default fetch group (just like <literal>java.lang.String</literal>).
      Changes to fields within custom types are not tracked so values of
      custom types should be treated as immutable (i.e. set a new instance
      instead of changing the internal state of the existing instance). If you
      do change the internal state of a custom type instance you can call
      <literal>JDOHelper.makeDirty(Object pc,String fieldname)</literal> so
      that the change will be persisted.</para>

      <para>Versant Open Access uses <interfacename>JdbcConverter</interfacename>&#39;s
      to map types to and from columns. If your custom type can be easily
      converted to/from String or byte[] then Versant Open Access will
      automatically select a suitable converter if you follow simple
      conventions described in the following sections. For other types you
      need to write a converter (see <xref linkend="writing_jdbc_converter" />)
      and enter its <interfacename>JdbcConverterFactory</interfacename> name
      on the grid.</para>

      <para>The customtypes demo (in <filename>demos/customtypes</filename>)
      is used as an example.</para>

      <section id="custom_string_types">
        <title>String Types<indexterm><primary>custom string types</primary></indexterm></title>

        <para>If your type has a constructor that accepts a
        <classname>String</classname> then Versant Open Access will assign it
        a converter called STRING when it is added. This converter will use
        the <classname>String</classname> constructor to create new instances
        from data read from the database. The type&#39;s <literal>toExternalString</literal>
        or <literal>toString</literal> method is used to externalize it for
        storage. Here is the <classname>PhoneNumber</classname> class from the
        customtypes demo:</para>

        <programlisting>public class PhoneNumber implements Serializable {
    private String countryCode;
    private String areaCode;
    private String number;

    /**
     * Create from a String formatted like +27 21 6703940. Versant Open Access uses
     * this method to create an instance from a String read from the
     * database.
     */
    public PhoneNumber(String s) {
        ... parse String and fill fields ...
    }

    /**
     * Versant Open Access uses this method to get the String to store in the database.
     * If there is a toExternalString method then it is used instead.
     */
    public String toString() {
        return &#34;+&#34; + countryCode + &#34; &#34; + areaCode + &#34; &#34; + number;
    }
...
}</programlisting>

        <para>Note that custom types only have to be <classname>Serializable</classname>
        if you are using remote persistence managers.</para>

        <para>Versant Open Access will create a <literal>VARCHAR</literal>
        column to hold the data from the field. You can change any of the
        column properties so long as the column remains compatible with
        <classname>java.lang.String</classname>. For example changing the JDBC
        type to <literal>CLOB</literal> will support storage of very long
        Strings.</para>

        <para>You can assign a different converter to the type if you need
        different behaviour (e.g. you need to call some other method to
        externalize the state of the instance).</para>
      </section>

      <section id="custom_byte_array_types">
        <title>byte[] Types<indexterm><primary>custom byte[] types</primary></indexterm></title>

        <para>If your type has a constructor that accepts a
        <literal>byte[]</literal> and a method public <literal>byte[]
        toBytes()</literal> then Versant Open Access will assign it a
        converter called BYTES when it is added. This converter will use the
        <literal>byte[]</literal> constructor to create new instances from
        data read from the database. The <literal>toBytes</literal> method is
        used to externalize it for storage. Here is the <literal>PngImage</literal>
        class from the customtypes demo:</para>

        <programlisting>public class PngImage implements Icon, Serializable {
    private transient BufferedImage image;

    /**
     * Versant Open Access uses this constructor after the bytes for the image have
     * been read from the database.
     */
    public PngImage(byte[] a) {
        try {
            image = ImageIO.read(new ByteArrayInputStream(a));
        } catch (IOException e) {
            throw new IllegalArgumentException(e.toString());
        }
    }

    /**
     * Versant Open Access calls this method when it needs to store the image in the
     * database.
     */
    public byte[] toBytes() {
        ByteArrayOutputStream o = new ByteArrayOutputStream(1024);
        try {
            ImageIO.write(image, &#34;PNG&#34;, o);
        } catch (IOException e) {
            throw new IllegalStateException(e.toString());
        }
        return o.toByteArray();
    }
...
}</programlisting>

        <para>Note that custom types only have to be <literal>Serializable</literal>
        if you are using remote persistence managers.</para>

        <para>Versant Open Access will create a <literal>BLOB</literal> column
        to hold the data from the field. You can change any of the column
        properties so long as the column remains compatible with
        <literal>byte[]</literal>. For example changing the JDBC type to
        <literal>VARBINARY</literal> is more efficient if the instances do not
        need many bytes to store.</para>

        <para>You can assign a different converter to the type if you need
        different behaviour.</para>
      </section>
    </section>

    <section id="writing_jdbc_converter">
      <title>Using JdbcConverter&#39;s<indexterm><primary>JdbcConverter</primary></indexterm><indexterm><primary>JdbcConverterFactory</primary></indexterm></title>

      <para>JdbcConverter&#39;s are used by Versant Open Access to get a Java
      object value from a column in a JDBC ResultSet and to set a Java object
      value on a JDBC PreparedStatement. Versant Open Access automatically
      uses converters to handle data types (e.g. Locale) that are not
      supported by JDBC and to work around problems with JDBC drivers. Note
      that unless you require access to low level JDBC objects (ResultSet or
      PreparedStatement) you should use Externalizer&#39;s instead of
      JdbcConverter&#39;s (see <xref linkend="externalized_types" />).</para>

      <para>You can write your own converters to handle tricky mapping
      problems. For example it is simple to write a converter to store an int
      value in a VARCHAR column. You could use a String field in your Java
      class and use JDO instance callbacks (jdoPostLoad and jdoPreStore) to
      copy to and from an int field. However it is faster and often preferable
      to do this at the mapping level. JdbcConverter&#39;s can be used
      anywhere where a <command>jdbc-column</command> extension (see <xref
      linkend="md_jdbc_column" />) is allowed making them much more flexible
      than instance callbacks. For example you can use converters on the
      columns of a link table used to store a collection. The converters used
      by Versant Open Access are in package <classname>com.versant.core.jdbc.sql.conv</classname>.
      The source for these converters is included in the <filename>src</filename>
      directory of the Versant Open Access distribution.</para>

      <para>Converters are created using a <classname>com.versant.core.jdbc.JdbcConverterFactory</classname>
      named in the meta data using a jdbc-converter extension:</para>

      <programlisting>&#60;field name=&#34;name&#34;&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-column&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-converter&#34;
            value=&#34;com.acme.app.openaccess.AcmeConverter$Factory&#34; /&#62;
    &#60;/extension&#62;
&#60;/field&#62;</programlisting>

      <para>The converters supplied with Versant Open Access use a static
      inner class of the converter as a factory. Versant Open Access will
      create one instance of each JdbcConverterFactory in the meta data and
      re-use it each time a converter is required. The factory may create a
      new JdbcConverter instance for each column or it may use one shared
      instance. The factory interface also has provision for configuring each
      JdbcConverter instance created with a Java bean but meta data and
      Workbench support for this will only be available in a future version of
      Versant Open Access.</para>
    </section>
  </chapter>

  <chapter id="collection_mapping">
    <title>Map, Collection and Array Mapping<indexterm><primary>collections
    mapping</primary></indexterm><indexterm><primary>maps</primary></indexterm><indexterm><primary>lists</primary></indexterm><indexterm><primary>arrays</primary></indexterm></title>

    <para>Versant Open Access supports all the commonly used collection and
    map types (Collection, Set, List, Map, ArrayList, Vector, LinkedList,
    HashSet, TreeSet, SortedSet, HashMap, TreeMap, SortedMap and Hashtable)
    and arrays. Of these Collection, Set and HashSet are required by the JDO
    specification and the others are optional features or extensions. The
    contents of collections, maps and arrays are normally stored in a link
    table except for arrays of primitive types (e.g. int[], short[], byte[]
    etc.) which are stored in BLOB fields (see <xref
    linkend="using_blob_or_image_columns" />). You can also choose to
    externalize any Collection or Map (e.g. serialize it to a BLOB, see <xref
    linkend="externalized_types" />).</para>

    <para>Collections and arrays of persistent classes can also be stored
    using an inverse foreign key in the persistent class (one-to-many).
    Many-to-many relationships are also supported. Bidirectional relationships
    (one-to-many and many-to-many) can be managed by Versant Open Access so
    that a change to one side is automatically reflected on the other side.
    Managed relationship support is disabled by default as it makes transient
    instances behave differently and is not portable to other JDO
    implementations.</para>

    <para>Versant Open Access supports JDK 1.5 generics. If Versant Open
    Access is running under JDK 1.5 then you do not have to specify the
    element type for generic Collections or the key and value types for
    generic Maps.</para>

    <section id="collection_and_map_support">
      <title>Collection and Map Support<indexterm><primary>collection support</primary></indexterm><indexterm><primary>map
      support</primary></indexterm></title>

      <para>This section describes how Versant Open Access handles parts of
      the JDO specification that are optional or unspecified for collections
      and maps.</para>

      <section id="valid_key_and_element_types">
        <title>Valid Element, Key and Value Types<indexterm><primary>element
        types</primary></indexterm><indexterm><primary>key types</primary></indexterm><indexterm><primary>value
        types</primary></indexterm></title>

        <para>Collections and maps in Java may hold instances of any class. To
        generate the JDBC schema Versant Open Access needs to know what type
        will be stored in the collection or map. You must specify the
        element-type for collections and the key-type and value-type for maps
        in the meta data (unless you are using JDK 1.5 and generics). This can
        be done easily using the Workbench. Versant Open Access supports
        collections and maps (key and value) of any type that is valid for a
        persistent field (Integer, String, Locale, Date, persistent class
        etc.). See <xref linkend="supported_field_types" />. If you are using
        Versant ODBMS then collections and maps without element-type and/or
        key-type can hold instances of any persistent class.</para>
      </section>

      <section id="generics">
        <title>JDK 1.5 Generics<indexterm><primary>using generics</primary></indexterm><indexterm><primary>generics</primary></indexterm><indexterm><primary>JDK
        1.5 generics</primary></indexterm></title>

        <para>If you use generic Collections and Maps then you do not have to
        specify the element type for Collections or the key and value types
        for Maps. Your classes must be compiled using the 1.5 compiler with
        source=1.5 for this to work. Here is an example showing the model
        classes and associated .jdo meta data.</para>

        <programlisting>public class Person {
    private String name;
    private List&#60;Address&#62; addresses = new ArrayList();
}

public class Address {
    private String street;
    private String city;
}</programlisting>

        <para>JDO meta data (note the lack of field and element-type
        attributes):</para>

        <programlisting>&#60;jdo&#62;
    &#60;package name=&#34;model&#34;&#62;
        &#60;class name=&#34;Person&#34; /&#62;
        &#60;class name=&#34;Address&#34; /&#62;
    &#60;/package&#62;
&#60;/jdo&#62;</programlisting>
      </section>

      <section id="list_ordering">
        <title>List and Array Ordering<indexterm><primary>list ordering</primary></indexterm></title>

        <para>Versant Open Access preserves the order of elements in
        List&#39;s and arrays by including a sequence column in the link
        table. If the ordering is not important you can use the ordered
        extension to disable ordering (see <xref linkend="md_ordered" />) and
        a sequence column will not be added. Lists stored using a foreign key
        in the element table do not preserve ordering. You can also specify a
        JDOQL ordering expression for unordered lists and arrays (no sequence
        column). See <xref linkend="ordering_unordered_lists" />.</para>
      </section>

      <section id="duplicate_elements">
        <title>Duplicate Elements in Collections<indexterm><primary>duplicate
        elements in collections</primary></indexterm></title>

        <para>Versant Open Access supports duplicate values in ordered Lists
        and arrays. Unordered Lists may not contain duplicate values. The
        reason for this is that the primary key of the link table used to
        store an unordered collection consists of the primary key of the
        owning table and the value column used to store the elements.</para>
      </section>

      <section id="null_elements">
        <title>Null Elements in Lists and Maps<indexterm><primary>null
        elements in collections</primary></indexterm><indexterm><primary>null
        values in maps</primary></indexterm></title>

        <para>Versant Open Access supports null values in lists and maps. For
        lists ordering must be enabled so lists mapped one-to-many using an
        inverse foreign key cannot contain nulls. Note that JDO Genie did not
        support null values.</para>
      </section>

      <section id="null_elements_in_arrays">
        <title>Null Elements in Arrays<indexterm><primary>null elements in
        arrays</primary></indexterm></title>

        <para>Versant Open Access supports null values in arrays stored in a
        link table except for arrays of wrapper types (Integer, Short etc.)
        which will be supported in a future release. Null values are not
        supported for arrays of persistent classes stored using an inverse
        foreign key (one-to-many mapping).</para>
      </section>

      <section id="null_collections_and_maps">
        <title>Null Collections and Maps<indexterm><primary>null collection</primary></indexterm><indexterm><primary>null
        map</primary></indexterm></title>

        <para>Versant Open Access does not preserve null collections and maps.
        If a collection or map field is set to null then requerying the
        instance will return an empty collection or map instead of a null.</para>
      </section>

      <section id="set_map_comparators">
        <title>TreeSet and TreeMap Comparators<indexterm><primary>TreeSet
        Comparator</primary></indexterm><indexterm><primary>TreeMap Comparator</primary></indexterm><indexterm><primary>Comparator</primary></indexterm></title>

        <para>Versant Open Access supports <classname>TreeSet</classname>&#39;s
        and <classname>TreeMap</classname>&#39;s using user defined
        <classname>Comparator</classname>&#39;s as well as those without
        <classname>Comparator</classname>&#39;s (i.e. using natural ordering).
        The <classname>Comparator</classname> (if any) is taken from the value
        of the <classname>TreeMap</classname> or <classname>TreeSet</classname>
        field on an instance of the persistent class created using its default
        constructor. This means that the <classname>Comparator</classname>
        instance must be stateless and should not be a non-static or anonymous
        inner class. The persistent class must also have a no-arg constructor
        that initializes the fields using a <classname>Comparator</classname>.
        The Versant Open Access enhancer will add a no-arg constructor to
        persistent classes but this will not initialize fields in this way.</para>

        <para>Here is an example:</para>

        <programlisting>public class ClassWithTreeSet {

    private TreeSet set = new TreeSet();
        // of String, natural ordering
    private TreeSet revSet = new TreeSet(new RevComp()); <co
id="comp_treeset_init" />
        // of String, reversed
    ...

    public ClassWithTreeSet() { <co id="comp_noarg_cons" />
    }
    ...
}

/** Stateless Comparator to reverse String&#39;s. **/
public class RevComp implements Comparator { 
    public int compare(Object o1, Object o2) {
        return ((String)o2).compareTo((String)o1);
    }
}</programlisting>

        <calloutlist>
          <callout arearefs="comp_treeset_init">
            <para>The <classname>TreeSet</classname> is created with an
            instance of <classname>RevComp</classname> (the
            <classname>Comparator</classname>).</para>
          </callout>

          <callout arearefs="comp_noarg_cons">
            <para>The no-arg constructor will invoke the inline initialization
            code for the <classname>TreeSet</classname>&#39;s.</para>
          </callout>
        </calloutlist>
      </section>
    </section>

    <section id="link_table_mapping">
      <title>Link Table Mapping<indexterm><primary>link table mapping</primary></indexterm></title>

      <para>If no extensions are specified for a collection or array of
      non-primitives then it will be mapped to a link table. Maps are always
      mapped to a link table. The structure of a link table depends on the
      type of collection or map and if ordering is required. All of the link
      table properties may be changed using the jdbc-link-table extension (see
      <xref linkend="md_jdbc_link_table" />). the jdbc-do-not-create-table
      extension can be used to leave the link table out of the generated
      schema (e.g. when mapping to a legacy database). Link tables for classes
      with jdbc-do-not-create-table are automatically excluded from the
      generated schema.</para>

      <section id="unordered_collection">
        <title>Unordered Collection<indexterm><primary>unordered collection
        mapping</primary></indexterm></title>

        <para>This structure is used for unordered collections (Collection,
        Set and HashSet), Lists and arrays with ordering set to false.</para>

        <informaltable>
          <tgroup cols="3">
            <thead>
              <row>
                <entry>Column(s)</entry>

                <entry>Primary Key</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>Foreign key reference to owning class</entry>

                <entry>Yes</entry>

                <entry>Reference to the class that the collection or array
                belongs to. There will be more than one column if the owning
                class has a composite primary key.</entry>
              </row>

              <row>
                <entry>Element column(s)</entry>

                <entry>Yes</entry>

                <entry>If the element-type is a PC class then this is a
                foreign key reference to the class and there will be more than
                one column if it has a composite primary key. Otherwise this
                is a column to hold the value.</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Example:<programlisting>public class Order {
    private Set lines = new HashSet(); // of OrderLine
    ...
}

public class OrderLine {
    ...
}  </programlisting></para>

        <para><inlinemediaobject><imageobject><imagedata
        fileref="images/mapping_col_link_table_unordered.png" /></imageobject></inlinemediaobject></para>
      </section>

      <section id="list_mapping">
        <title>List and Array<indexterm><primary>list mapping</primary></indexterm></title>

        <para>This structure is used for Lists and arrays of non-primitives.</para>

        <informaltable>
          <tgroup cols="3">
            <thead>
              <row>
                <entry>Column(s)</entry>

                <entry>Primary Key</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>Foreign key reference to owning class</entry>

                <entry>Yes</entry>

                <entry>Reference to the class that the list or array belongs
                to. There will be more than one column if the owning class has
                a composite primary key.</entry>
              </row>

              <row>
                <entry>Sequence column</entry>

                <entry>Yes</entry>

                <entry>This column is used to maintain the order of the
                elements.</entry>
              </row>

              <row>
                <entry>Element column(s)</entry>

                <entry>No</entry>

                <entry>If the element-type is a PC class then this is a
                foreign key reference to the class and there will be more than
                one column if it has a composite primary key. Otherwise this
                is a column to hold the value.</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Example:<programlisting>public class Order {
    private List lines = new ArrayList(); // of OrderLine
    ...
}

public class OrderLine {
    ...
}  </programlisting></para>

        <para><inlinemediaobject><imageobject><imagedata
        fileref="images/mapping_col_link_table.png" /></imageobject></inlinemediaobject></para>
      </section>

      <section id="map_mapping">
        <title>Map<indexterm><primary>map mapping</primary></indexterm></title>

        <para>This structure is used for Maps.</para>

        <informaltable>
          <tgroup cols="3">
            <thead>
              <row>
                <entry>Column(s)</entry>

                <entry>Primary Key</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>Foreign key reference to owning class</entry>

                <entry>Yes</entry>

                <entry>Reference to the class that the map belongs to. There
                will be more than one column if the owning class has a
                composite primary key.</entry>
              </row>

              <row>
                <entry>Key column(s)</entry>

                <entry>Yes</entry>

                <entry>If the key-type is a PC class then this is a foreign
                key reference to the class and there will be more than one
                column it has a composite primary key. Otherwise this is a
                column to hold the key.</entry>
              </row>

              <row>
                <entry>Value column(s)</entry>

                <entry>No</entry>

                <entry>If the value-type is a PC class then this is a foreign
                key reference to the class and there will be more than one
                column if it has a composite primary key. Otherwise this is a
                column to hold the value.</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Example:<programlisting>public class Profession {
    private Map skillCostMap = new HashMap(); 
    // Skill -&#62; SkillCost
    ...
}

public class Skill {
    ...
}

public class SkillCost {
    ...
}  </programlisting></para>

        <para><inlinemediaobject><imageobject><imagedata
        fileref="images/mapping_map_link_table.png" /></imageobject></inlinemediaobject></para>
      </section>
    </section>

    <section id="inverse_foreign_key_mapping">
      <title>One-to-many Mapping<indexterm><primary>foreign key mapping</primary></indexterm><indexterm><primary>inverse
      foreign key mapping</primary></indexterm><indexterm><primary>one-to-many</primary></indexterm><indexterm><primary>inverse
      one-to-many</primary></indexterm><indexterm><primary>managed one-to-many</primary></indexterm><indexterm><primary>one-to-many
      managed</primary></indexterm></title>

      <para>You can map collections and arrays of persistent classes by using
      foreign key column(s) in the table for the element class to complete the
      collection or array (one-to-many or master-detail). The foreign key(s)
      can be provided by a reference field in the element class but this is
      not required. For arrays and lists the ordering of elements is not
      preserved (but see <xref linkend="ordering_unordered_lists" />).</para>

      <para><inlinemediaobject><imageobject><imagedata
      fileref="images/mapping_col_one_to_many.png" /></imageobject></inlinemediaobject></para>

      <para>If you use a reference field in your model to provide the foreign
      key(s), then by default Open Access will not try to keep it in sync with
      the collection (i.e. relationship is unmanaged). Your model must ensure
      that the collection or array and the reference field used to complete it
      are in sync. This has the advantage that transient instances behave in
      exactly the same way as persistent instances. Your application will also
      be portable to JDO implementations without managed relationship support.</para>

      <para>Example code for an unmanaged one-to-many:</para>

      <programlisting>public class Order {
    private List lines = new ArrayList(); // of OrderLine
    ...
    public void addLine(OrderLine l) {
        if (l.getOrder() != null) {
            throw new IllegalArgumentException(
                &#34;line belongs to &#34; + l.getOrder());
        }
        lines.add(l);
        l.setOrder(this);
    }

    public void removeLine(OrderLine l) {
        if (l.getOrder() != this) {
            throw new IllegalArgumentException(
                &#34;line belongs to &#34; + l.getOrder());
        }
        lines.remove(l);
        l.setOrder(null);
    }
}

public class OrderLine {
    private Order order;

    void setOrder(Order o) { order = o; }
    public Order getOrder() { return order; }
}</programlisting>

      <para>In this example if the OrderLine is added to the lines List and
      the order reference on it is not set then the database will not be
      correctly updated on commit. When the collection is next read the new
      line will be missing. Enable model consistency checking during
      development and testing (see <xref linkend="model_consistency" />) to
      trap this class of bug.</para>

      <para>If only the reference field is set then database update will be
      done correctly. The collection will be correctly filled next time it is
      read. The model will be inconsistent until the Order is reloaded from
      the database. This will be next time it is touched unless you have
      retainValues=true (see <xref linkend="cache_retain_values" />). This
      technique can provide substantial performance improvements in some
      applications (see <xref linkend="one_to_many_performance" />).</para>

      <para>The .jdo meta data for this example is as follows:</para>

      <programlisting>&#60;field name=&#34;lines&#34;&#62;
    &#60;collection element-type=&#34;OrderLine&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;inverse&#34;
            value=&#34;order&#34; /&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;managed&#34;
            value=&#34;false&#34; /&#62;
    &#60;/collection&#62;
&#60;/field&#62;</programlisting>

      <section id="one_to_many_performance">
        <title>One-to-many Performance<indexterm><primary>one-to-many
        performance</primary></indexterm></title>

        <para>The standard JDO code to add to a bidirectional one-to-many
        collection (e.g. in the Order and OrderLine example above) is as
        follows:</para>

        <programlisting>pm.currentTransaction().begin();
Order o = (Order)pm.getObjectById(oid, true);
OrderLine line = new OrderLine();
line.setOrder(o);
o.getLines().add(o);
pm.currentTransaction().commit();</programlisting>

        <para>This produces SQL like the following (assuming an optimistic
        transaction):</para>

        <programlisting>SELECT customer_id, order_date, jdo_version FROM ordr WHERE ordr_id = ?
COMMIT
SELECT a.order_line_id, a.item_id, a.ordr_id, a.qty, a.jdo_version 
FROM order_line AS a 
     LEFT JOIN item AS b ON (a.item_id = b.item_id) WHERE a.ordr_id = ?
COMMIT
UPDATE ordr SET jdo_version=? where ordr_id = ? and jdo_version=?
INSERT INTO order_line (order_line_id, item_id, ordr_id, qty, jdo_version) 
    VALUES (?, ?, ?, ?, ?)
COMMIT</programlisting>

        <para>Note that the Order and its lines must be read from the database
        (assuming this data is not in the level 2 cache) and that the
        optimistic locking column (jdo_version) on the Order must be updated
        on commit. This transaction can be optimized:</para>

        <programlisting>pm.currentTransaction().begin();
Order o = (Order)pm.getObjectById(oid, <emphasis>false</emphasis>);
OrderLine line = new OrderLine();
line.setOrder(o);
<emphasis>// o.getLines().add(o);</emphasis>
pm.currentTransaction().commit();</programlisting>

        <para>The Order is looked up with the validate flag set to false so
        there is no need for Versant Open Access to check that it actually
        exists. A hollow instance is returned instead. Only the order
        reference on the new OrderLine is set. The collection of lines is
        never touched and does not have to be read. The SQL is as follows:</para>

        <programlisting>INSERT INTO order_line (order_line_id, item_id, ordr_id, qty, jdo_version) 
    VALUES (?, ?, ?, ?, ?)
COMMIT</programlisting>

        <para>If the database supports referential integrity checking then an
        insert for a nonexistent order will fail.</para>

        <para>The optimistic locking column (jdo_version) on Order is not
        updated. For most applications checking optimistic locking for this
        transaction is not required. If you do need the check then add the
        line to the collection. This will still be quicker than the original
        as the Order is not fetched, only its lines. In all cases the Order
        will be correctly evicted from the level 2 cache.</para>

        <para>Note that the optimized version of this transaction will fail if
        model consistency checking is enabled. You cannot use this
        optimization with retainValues (see <xref
        linkend="cache_retain_values" />).</para>
      </section>

      <section id="unmanaged_one_to_many">
        <title>Managed one-to-many<indexterm><primary>managed one-to-many</primary></indexterm><indexterm><primary>one-to-many
        managed</primary></indexterm></title>

        <para>Versant Open Access will keep the reference field used to create
        the collection and the collection in sync automatically if you enable
        managed relationship support for the field or project. This is done by
        Versant Open Access using the second class object (SCO) implementation
        of the collection. If you add an element to the collection its inverse
        (foreign key) field will be set and it will be removed from the
        collection it currently belongs to (if any). You can also set the
        inverse field in the detail in which case the element will be
        removed/added to the master collection automatically. See <xref
        linkend="md_inverse" /> for details on the JDO meta data required.
        Arrays are never managed.</para>

        <para>You can make all of your one-to-many relationships managed by
        changing the default in the Workbench (select <command>File | Project
        Properties | Datastore / General Settings</command>). Note that this
        is not portable to other JDO implementations and your managed
        instances will behave differently to transient instances.</para>

        <para>The relationship is not maintained for transient instances as
        the SCO implementation is only set on JDO managed instances. This is
        not normally a problem as the inverse fields are filled when the
        master is made persistent. However you should enable model consistency
        checking during development and testing (see <xref
        linkend="model_consistency" />) even if you are using managed
        collections.</para>

        <para>If you are not using a reference field to complete the
        collection then the foreign keys added to the table for the element
        class are always filled by Open Access.</para>

        <para>Example code for a managed one-to-many:</para>

        <programlisting>public class Order {
    private List lines = new ArrayList(); // of OrderLine
    ...
    public void addLine(OrderLine l) {
        lines.add(l);
        // the SCO will make sure that l.order == this
    }

    public void removeLine(OrderLine l) {
        lines.remove(l);
        // the SCO will make sure that l.order == null
    }
}

public class OrderLine {
    private Order order;
    ...
}</programlisting>
      </section>

      <section id="deleting_orphans">
        <title>Automatically Deleting Orphans<indexterm><primary>deleting
        orphans</primary></indexterm></title>

        <para>Normally instances on the many side of a one-to-many
        relationship with a null parent reference (the field used as the
        inverse on the one side to complete the collection or array) are
        permitted. However you can use the delete-orphans extension (see <xref
        linkend="md_delete_orphans" />) to delete these automatically. Note
        that if the instance has several parent reference fields (i.e. can be
        in more than one one-to-many collection at the same time) then they
        must all be null before the instance is deleted. In many cases this is
        more convenient than using cascading deletes (see <xref
        linkend="dependent_collections" />). Versant Open Access does not
        check for other references to the instance to be deleted so this
        feature should be used with caution.</para>

        <para>There is an example of this extension in <filename>demos/tut1</filename>.
        The important parts of the <classname>Order</classname> and
        <classname>OrderLine</classname> classes from this demo are shown
        here:<programlisting>public class Order {
    ...
    private List lines = new ArrayList();
        // inverse OrderLine.order
    ...
}

public class OrderLine {
    private Order order;
    private Item item;
    private int qty;
    ...
}</programlisting></para>

        <para>The .jdo meta data for this example is as follows:</para>

        <programlisting>&#60;class name=&#34;OrderLine&#34;&#62;
    &#60;extension vendor-name=&#34;versant&#34;
        key=&#34;delete-orphans&#34; value=&#34;true&#34; /&#62;
&#60;/class&#62;

&#60;class name=&#34;Order&#34;&#62;
    &#60;field name=&#34;lines&#34;&#62;
        &#60;collection element-type=&#34;OrderLine&#34;&#62;
            &#60;extension vendor-name=&#34;versant&#34;
                key=&#34;inverse&#34; value=&#34;order&#34; /&#62;
        &#60;/collection&#62;
    &#60;/field&#62;
&#60;/class&#62;</programlisting>
      </section>
    </section>

    <section id="many_to_many_mapping">
      <title>Many-to-many Mapping<indexterm><primary>inverse many-to-many</primary></indexterm><indexterm><primary>many-to-many</primary></indexterm><indexterm><primary>unmanaged
      many-to-many</primary></indexterm><indexterm><primary>many-to-many
      unmanaged</primary></indexterm></title>

      <para>Versant Open Access supports many-to-many mappings where two
      collections share a common link table. At commit or flush time the link
      table is updated to match only one side of the many-to-many (since any
      given element will be in both collections but must only get one row in
      the link table). See <xref linkend="md_inverse" /> for details on the
      JDO meta data required to setup a many-to-many. However it is much
      easier to use the Workbench to edit the meta data as shown in the
      graphic below:</para>

      <para><inlinemediaobject><imageobject><imagedata
      fileref="images/mapping_col_many_to_many.png" /></imageobject></inlinemediaobject></para>

      <para>When an element is added or removed from one collection the other
      side must be updated by the application. Failure to keep the collections
      in sync may result in database updates being lost or stale data
      remaining in the level 2 cache. You should enable model consistency
      checking during development and testing (see <xref
      linkend="model_consistency" />) to trap any bugs in your code related to
      the consistency of bidrectional relationships.</para>

      <para>Note that prior to Versant Open Access 3.0.0beta14 many-to-many
      relationships were always completed (managed) by Versant Open Access
      (see <xref linkend="managed_many_to_many" />). The new default behaviour
      can be changed using the Workbench (<command>File | Project Properties |
      Datastore / General Settings</command>).</para>

      <para>If the non-inverse side of the relationship is a List then the
      order of its elements is preserved by default using a sequence column in
      the link table (see <xref linkend="list_mapping" />). The order of the
      inverse side of the relationship is not preserved. However if the
      collection on either side is a list you can use the ordering extension
      (see <xref linkend="ordering_unordered_lists" />) to define an ordering
      using a JDOQL ordering expression. It is easiest to just specify the
      ordering using the Workbench as you do not need to worry about which
      side is the inverse.</para>

      <para>Here is sample code for an unmanaged many-to-many. A User has many
      Group&#39;s and a Group has many User&#39;s:</para>

      <programlisting>public class Group {
    private String name;
    private List users = new ArrayList(); // of User
    ...
    public void addUser(User u) {
        addUserImp(u);
        u.addGroupImp(this);
    }

    public void removeUser(User u) {
        removeUserImp(u);
        u.removeGroupImp(this);
    }

    void addUserImp(User u) { users.add(u); }
    void removeUserImp(User u) { users.remove(u); }

    public List getUsers() { return users; }
}

public class User {
    private String name;
    private List groups = new ArrayList(); // inverse Group.users
    ...
    public void addGroup(Group g) {
        addGroupImp(g);
        g.addUserImp(this);
    }

    public void removeGroup(Group g) {
        removeGroupImp(g);
        g.removeUserImp(this);
    }

    void addImp(Group g) { groups.add(g); }
    void removeImp(Group g) { groups.remove(g); }

    public List getGroups() { return groups; }
} </programlisting>

      <para>Here is the JDO meta data. Note that the ordering extension is
      used to ensure that Group.users is sorted by user name. The order of
      User.groups is preserved by the seq column in the link table.</para>

      <programlisting>&#60;class name=&#34;User&#34;&#62;
    &#60;field name=&#34;groups&#34;&#62;
        &#60;collection element-type=&#34;Groups&#34; /&#62;
    &#60;/field&#62;
&#60;/class&#62;

&#60;class name=&#34;Groups&#34;&#62;
    &#60;field name=&#34;users&#34;&#62;
        &#60;collection element-type=&#34;User&#34;&#62;
            &#60;extension vendor-name=&#34;versant&#34; key=&#34;inverse&#34; value=&#34;groups&#34; /&#62;
            &#60;extension vendor-name=&#34;versant&#34; key=&#34;ordering&#34; value=&#34;name ascending&#34; /&#62;
        &#60;/collection&#62;
    &#60;/field&#62;
&#60;/class&#62;</programlisting>

      <section id="managed_many_to_many">
        <title>Managed Many-to-many<indexterm><primary>managed many-to-many</primary></indexterm><indexterm><primary>many-to-many
        managed</primary></indexterm></title>

        <para>You can flag an individual many-to-many relationship as managed
        by ticking the box on the form in the Workbench or by adding the
        managed=true extension to the non-inverse side. You can make all of
        your many-to-many relationships managed by changing the default in the
        Workbench (select <command>File | Project Properties | Datastore /
        General Settings</command>). The default behaviour was managed in
        Versant Open Access releases prior to 3.0.0beta14. You should enable
        model consistency checking during development and testing (see <xref
        linkend="model_consistency" />) even if you are using managed
        collections.</para>

        <para>When an element is added or removed from one collection the
        other side is automatically kept in sync and visa versa. The
        relationship is maintained by the second class object (SCO)
        implementations of the collections on either side. See <xref
        linkend="md_inverse" /> for details on the JDO meta data required. If
        you delete an instance using PM.deletePersistent(pc) it will
        automatically be removed from the other side of any many-to-many
        relationships it is part of.</para>

        <para>The relationship is not maintained for transient instances as
        the SCO implementations are only set on JDO managed instances. However
        when transient instances are made persistent the relationship is
        completed.</para>

        <para>Example code for a managed many-to-many:</para>

        <programlisting>public class Group {
    private String name;
    private List users = new ArrayList(); // of User
    ...
    public void addUser(User u) {
        users.add(u);
        // the SCO will make sure that u.groups.contains(this)
    }

    public void removeUser(User u) {
        users.remove(u);
        // the SCO will make sure that !u.groups.contains(this)
    }

    public List getUsers() {
        return users;
    }
}

public class User {
    private String name;
    private List groups = new ArrayList(); // inverse Group.users
    ...
    public void addGroup(Group g) {
        groups.add(g);
        // the SCO will make sure that g.users.contains(this)
    }

    public void removeGroup(Group g) {
        groups.remove(g);
        // the SCO will make sure that !g.users.contains(this)
    }

    public List getGroups() {
        return groups;
    }

} </programlisting>

        <para>Note that if you flag a many-to-many as managed and you complete
        the relationship in your code then any List&#39;s will get duplicate
        entries. Its is too expensive for the SCOs to guard against this.</para>

        <para>The .jdo meta data for this example is as follows:</para>

        <programlisting>&#60;class name=&#34;User&#34;&#62;
    &#60;field name=&#34;groups&#34;&#62;
        &#60;collection element-type=&#34;Groups&#34;&#62;
            &#60;extension vendor-name=&#34;versant&#34; key=&#34;managed&#34; value=&#34;true&#34; /&#62;
        &#60;/collection&#62;
    &#60;/field&#62;
&#60;/class&#62;

&#60;class name=&#34;Groups&#34;&#62;
    &#60;field name=&#34;users&#34;&#62;
        &#60;collection element-type=&#34;User&#34;&#62;
            &#60;extension vendor-name=&#34;versant&#34; key=&#34;inverse&#34; value=&#34;groups&#34; /&#62;
            &#60;extension vendor-name=&#34;versant&#34; key=&#34;ordering&#34; value=&#34;name ascending&#34; /&#62;
        &#60;/collection&#62;
    &#60;/field&#62;
&#60;/class&#62;</programlisting>
      </section>
    </section>

    <section id="model_consistency">
      <title>Model Consistency Checking<indexterm><primary>model consistency
      checking</primary></indexterm><indexterm><primary>bidirectional
      relationship consistency</primary></indexterm></title>

      <para>It is important that one-to-many and many-to-many relationships
      are consistent in your model. If one side of the relationship is out of
      sync with the other side then either the database will not be updated
      properly or stale data will be left in the level 2 cache. If you are
      using managed relationships then this is usually taken care of by
      Versant Open Access. If you are using unmanaged relationships then you
      must handle this in your code.</para>

      <para>Versant Open Access has support for automatically checking the
      consistency of all of the objects in the PM (local) cache on commit.
      This is not enabled by default as the check is expensive. It may even
      have to load new instances from the database or level 2 cache. You
      should enable this during development and testing (choose File | Project
      Properties / Project and enable &#34;Check model consistency on
      commit&#34;) and turn it off for production.</para>

      <para>This feature can also be enabled and disabled for individual
      PersistenceManager&#39;s (see VersantPersistenceManager javadoc). If you
      are careful and understand exactly what you are doing you can sometimes
      get better performance by only updating one side of a bidirectional
      relationship. In these cases it may be useful to disable consistency
      checking to avoid failures when the flag is enabled for the
      PersistenceManagerFactory.</para>
    </section>

    <section id="dependent_collections">
      <title>Dependent Collections / Cascading Deletes<indexterm><primary>dependent
      collections</primary></indexterm><indexterm><primary>cascading deletes</primary></indexterm></title>

      <para>Versant Open Access supports dependent collections, arrays and
      maps for collections or arrays containing persistent class elements and
      maps with persistent class keys and/or values. If the instance owning
      such a collection, array or map is deleted then the persistent class
      instances are also deleted.</para>

      <para>That is if the referencing instance is deleted then the referenced
      instance is also deleted (cascading deletes). This feature must be used
      with caution as Versant Open Access does not check that there are no
      other references to deleted instances. If there are other references at
      best you will get an exception on commit (if there is a constraint) or
      the transaction will succeed and you will get errors when traversing
      references to the deleted instance elsewhere in the application. See
      <xref linkend="md_dependent" />.</para>

      <para>If you are using one-to-many relationships it may be more
      convenient to use the delete-orphans extension instead of cascading
      deletes (see <xref linkend="deleting_orphans" />).</para>
    </section>

    <section id="ordering_unordered_lists">
      <title>JDOQL Style Ordering for Unordered Lists<indexterm><primary>ordering
      list fields</primary></indexterm></title>

      <para>Versant Open Access supports ordering for otherwise unordered
      lists and arrays (e.g. lists mapped using an inverse foreign key or link
      table without a sequence column). This is done by specifying an ordering
      extension for the list or array in the meta data. This extension uses
      the same syntax as the ordering property of a JDOQL query (i.e. comma
      separated field expressions followed by ascending or descending). For
      lists of String&#39;s and other non-persistence capable types the
      expression must be <literal>this ascending</literal> or
      <literal>this descending</literal> with <literal>this</literal>
      referring to the value itself. You can edit this extension using the
      <command>Field Properties</command> window in the Workbench.</para>

      <para>Note that the ordering only applies to the initial contents of the
      list or array populated from the SQL query. No attempt is made to keep
      the list in order as changes are made during normal execution. See <xref
      linkend="md_ordering" /> for more information.</para>

      <para>Examples:</para>

      <programlisting>&#60;field name=&#34;studentList&#34;&#62;
    &#60;collection element-type=&#34;Student&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;ordering&#34;
            value=&#34;addr.city ascending, addr.street ascending&#34; /&#62;
    &#60;/collection&#62;
&#60;/field&#62;

&#60;field name=&#34;emailList&#34;&#62;
    &#60;collection element-type=&#34;java.lang.String&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;ordering&#34;
            value=&#34;this descending&#34; /&#62;
    &#60;/collection&#62;
&#60;/field&#62;</programlisting>
    </section>
  </chapter>

  <chapter id="jdoql">
    <title>Queries and JDOQL Extensions</title>

    <para>Versant Open Access supports extensions to the standard
    javax.jdo.Query interface to control query and result processing, to add
    JDO 2 preview features and to extend JDOQL with additional operations. You
    can efficiently work with queries that return millions of instances<indexterm><primary>large
    resultset support</primary></indexterm> using the randomAccess option. You
    can use the countOnSize option to run COUNT(*) queries while maintaining
    JDO 1.0.1 compatibility (i.e. without using JDO 2 preview features). You
    can use JDO 2 preview features such as projections, aggregates, group by
    and having without waiting for the final specification to be released.
    Query results are automatically cached for optimistic transactions (see
    <xref linkend="optimistic_transactions" />) involving classes with caching
    enabled. You can use direct SQL queries and invoke stored procedures with
    IN and OUT parameters (see <xref linkend="sql_query_language" />).</para>

    <section id="oids_as_params">
      <title>OIDs as Parameters<indexterm><primary>OIDs as parameters</primary></indexterm></title>

      <para>Normally to use an object ID (OID) as a parameter to a query you
      have to lookup the associated JDO instance using
      PersistenceManager.getObjectById(oid, false) and use it as the
      parameter. Versant Open Access supports the direct use of OIDs as
      parameters in this case. Example:</para>

      <programlisting>public class Country {
    private String code; // primary-key=true
    ...
    public static class ID { // app identity class
        public String code;
        public ID(String code) {
            this.code = code;
        }
        ...
    }
}

public class Order {
    private Country country;
    ...
}

To find all the Order&#39;s for &#39;ZA&#39;:

Query q = pm.newQuery(Order.class, &#34;country == c&#34;);
q.declareParameters(&#34;Object c&#34;);
Collection ans = (Collection)q.execute(new Country.ID(&#34;ZA&#34;));
...</programlisting>

      <para>This extension also works for datastore identity using OIDs
      returned by pm.getObjectId(pc) or pm.newObjectIdInstance(Class, String).</para>

      <para>Note that this feature makes it possible to query for instances
      referencing an object that does not exist (dangling reference i.e.
      invalid foreign key). The damaged instances can then be fixed by setting
      the refence to null or to a valid instance.</para>
    </section>

    <section id="collections_as_params">
      <title>Collections as Parameters (SQL IN list)<indexterm><primary>collections
      as parameters</primary></indexterm><indexterm><primary>IN list</primary></indexterm><indexterm><primary>SQL
      IN list</primary></indexterm></title>

      <para>If you specify a Collection as a parameter to a query and use it
      with Collection.contains then an IN list is generated in the SQL. Here
      is an example using a Collection of instances of a persistent class:</para>

      <programlisting>List cats = new ArrayList();
cats.add(cat1);
cats.add(cat2);

Query query = pm.newQuery(Item.class);
query.declareParameters(&#34;Collection p&#34;);
query.setFilter(&#34;p.contains(category)&#34;);
Collection col = (Collection)query.execute(cats);
...

SELECT item_id, category_id, code, description, jdo_version 
FROM item 
WHERE category_id in (?,?)</programlisting>

      <para>Here is anpther example using a List of Strings as the parameter:</para>

      <programlisting>ArrayList codes = new ArrayList();
codes.add(&#34;D001&#34;);
codes.add(&#34;D002&#34;);
codes.add(&#34;C001&#34;);

Query query = pm.newQuery(Item.class);
query.declareParameters(&#34;Collection p&#34;);
query.setFilter(&#34;p.contains(code)&#34;);
Collection col = (Collection)query.execute(codes);
...

SELECT item_id, category_id, code, description, jdo_version 
FROM item 
WHERE code in (?,?,?)</programlisting>

      <para>This feature cannot be used with Collections of classes with a
      composite primary key. Care must be taken to avoid this technique when
      the number of elements in the collection might be large as many
      databases have limitations on the maximum size of an SQL query and
      parameters.</para>
    </section>

    <section id="query_properties">
      <title>Query Properties<indexterm><primary>query properties</primary></indexterm></title>

      <para>Versant Open Access extends <classname>the javax.jdo.Query</classname>
      interface with properties to improve performance and control how the
      results are accessed. There are two ways to use these options in your
      application:</para>

      <itemizedlist>
        <listitem>
          <para>Cast the <classname>javax.jdo.Query</classname> returned by
          PersistenceManager.newQuery(...) to a <classname>com.versant.core.jdo.VersantQuery</classname>
          and call the setXXX methods. This is clear in code but the code will
          not compile with other JDO implementations. Example:</para>

          <programlisting>VersantQuery q = (VersantQuery)pm.newQuery(Item.class);
q.setFetchGroup(&#34;codeOnly&#34;);
q.setRandomAccess(true);
List ans = (List)q.execute();
...</programlisting>
        </listitem>

        <listitem>
          <para>Add a &#39;String versantOptions&#39; parameter to the query
          and specify a semicolon delimited String of property=value pairs
          when the query is executed. Compilation portability is maintained
          and other JDO implementations should ignore this unused parameter.</para>

          <programlisting>Query q = pm.newQuery(Item.class);
q.declareParameters(&#34;String versantOptions&#34;);
Collection ans = (Collection)q.execute(&#34;fetchGroup=codeOnly;randomAccess=true&#34;);
...</programlisting>
        </listitem>
      </itemizedlist>

      <para>The source for <classname>com.versant.core.jdo.VersantQuery</classname>
      is in <filename>src</filename> directory of the distribution. The
      subsections below describe each supported property.</para>

      <section id="jdoql_fetchgroup">
        <title>FetchGroup<indexterm><primary>FetchGroup query property</primary></indexterm></title>

        <para>This property specifies the fetch group used to execute the
        query. If it is not set then the default fetch group of the candidate
        class for the query is used. Versant Open Access fetch groups control
        exactly which fields are returned in each instance. They also make it
        possible to fetch other referenced instances and collections at the
        same time i.e. you can prefetch a large part of your object graph with
        a single query. This solves the N+1 database calls problem. See <xref
        linkend="md_fetch_group" /> for more information on fetch groups.</para>
      </section>

      <section id="parallel_collection_fetch">
        <title>Bounded<indexterm><primary>Bounded query property</primary></indexterm><indexterm><primary>eager
        fetch of collections</primary></indexterm></title>

        <para>This property is a hint to Versant Open Access that the number
        of instances returned by the query is limited. If it is true then
        collections and maps are fetched in bulk using parallel queries
        derived from the orginal filter expression. If it is false then
        individual queries are issued for each collection or map for each
        instance in the result. The default setting is false.</para>

        <para>Consider the following query using the Customer, Order and
        OrderLine classes from tut1. The collection of OrderLine&#39;s on the
        Order is in the default fetch group.</para>

        <programlisting>Query query = pm.newQuery(Order.class);
query.setFilter(&#34;customer.name.toLowerCase().startsWith(\&#34;j\&#34;)&#34;);
Collection col = (Collection)query.execute();</programlisting>

        <para>With bounded=false the following SQL is executed:</para>

        <programlisting>SELECT a.ordr_id, a.customer_id, a.order_date, a.jdo_version 
FROM ordr AS a JOIN customer AS b ON (a.customer_id = b.customer_id) 
WHERE lower(b.nme) LIKE &#39;j%&#39;

SELECT order_line_id, item_id, ordr_id, qty, jdo_version 
FROM order_line 
WHERE ordr_id = ?
[... repeated for each Order returned ...]</programlisting>

        <para>If 100 Orders are returned by the query then 101 SQL queries
        will be run. With bounded=true the following SQL is executed:</para>

        <programlisting>SELECT a.ordr_id, a.customer_id, a.order_date, a.jdo_version 
FROM ordr AS a JOIN customer AS b ON (a.customer_id = b.customer_id) 
WHERE lower(b.nme) LIKE &#39;j%&#39;
ORDER BY 1

SELECT a.ordr_id, c.ordr_id, c.order_line_id, c.item_id, c.ordr_id, 
    c.qty, c.jdo_version 
FROM ordr AS a 
     JOIN customer AS b ON (a.customer_id = b.customer_id) 
     JOIN order_line AS c ON (a.ordr_id = c.ordr_id) 
WHERE lower(b.nme) LIKE &#39;j%&#39;
ORDER BY 1</programlisting>

        <para>No matter how many Orders are returned only 2 SQL queries are
        executed!</para>

        <para>Before enabling bounded on all of your queries consider the
        following example:</para>

        <programlisting>Query query = pm.newQuery(Order.class);
query.setFilter(&#34;customer.name &#62;= \&#34;j\&#34;)&#34;;
Collection col = (Collection)query.execute();</programlisting>

        <para>The web page using this query only displays the first 10 orders.
        However the query itself might return thousands of orders. If
        bounded=true then the parallel query to fetch the lines will return
        even more rows and take a long time to execute. Some JDBC drivers will
        even return all rows from a query to the client at once instead of
        fetching them as they are needed. Of these rows only the first few are
        used so in this case it is more efficient to issue a query for each
        order.</para>

        <para>This option cannot be used with randomAccess. If you set
        randomAccess=true then bounded is disabled.</para>
      </section>

      <section id="random_access">
        <title>RandomAccess<indexterm><primary>RandomAccess query property</primary></indexterm></title>

        <para>Indicate that random access to query results is required or not.
        If this is true then the collection returned by execute can be cast to
        a List and the get(index) method can be used to get any entry in the
        list. See the next section for more information on query results and
        RandomAccess. Note that the countStarOnSize option is ignored if
        randomAccess is true (see <xref linkend="count_on_size" />) and
        bounded is disabled (see <xref linkend="parallel_collection_fetch" />).</para>
      </section>

      <section id="max_rows">
        <title>MaxRows<indexterm><primary>MaxRows query property</primary></indexterm></title>

        <para>Limit the number of instances to be returned. This property is
        passed through to JDBC drivers that support it. If this property has
        been set and FetchSize is not set then the FetchSize is set to
        MaxRows.</para>
      </section>

      <section id="fetch_size">
        <title>FetchSize<indexterm><primary>FetchSize query property</primary></indexterm></title>

        <para>Set the number of instances fetched per server round trip. This
        property controls Versant Open Access&#39;s own batching and is also
        passed through to JDBC drivers that support it. If this property is
        not set and MaxRows is set then the default is MaxRows.</para>
      </section>

      <section id="count_on_size">
        <title>CountStarOnSize<indexterm><primary>CountStarOnSize query
        property</primary></indexterm><indexterm><primary>Count(*) query
        property</primary></indexterm></title>

        <para>Normally when size() is called on the Collection returned by
        executing a non-randomAccess Query all of the results are fetched in
        one operation to detirmine the size of the collection. If this
        property is true then a &#39;SELECT COUNT(*) ...&#39; version of the
        query is used to count the results. Subsequent calls to to size()
        after the first call will revert to normal behaviour and resolve all
        of the results. The count is cached if JDOQL caching is enabled.</para>

        <para>Note that the actual number of results might differ to those
        first returned by size() when this option is used. This can happen if
        new rows that meet the filter criteria are inserted after the
        &#39;SELECT COUNT(*)...&#39; query has run but before the normal
        &#39;SELECT ...&#39; to fetch the data. This may be possible even in a
        non-optimistic transaction (see <xref
        linkend="optimistic_transactions" />) depending on how the database
        handles locking.</para>

        <para>If countStarOnSize is used with the maxRows property then the
        first call to size() will count all rows in the result even if there
        are more than maxRows. The number of rows actually returned is subject
        to the maxRows value.</para>

        <para>Here is an example using this property:</para>

        <programlisting>Query q = ...
q.declareParameters(&#34;String versantOptions, ...&#34;);
Collection ans = (Collection)q.execute(&#34;countStarOnSize=true&#34;, ...);
int count = ans.size(); // &#39;SELECT COUNT(*) ..&#39;
if (count &#62; 100) {
    // too many results - user must narrow search
} else {
    ArrayList data = new ArrayList(ans); // &#39;SELECT col1, ..&#39;
    ...
}</programlisting>

        <para>The countStarOnSize option is ignored if randomAccess is true
        (see <xref linkend="random_access" />).</para>
      </section>
    </section>

    <section id="using_query_results">
      <title>Using Query Results<indexterm><primary>query results</primary></indexterm></title>

      <para>The JDO specification requires only that Query.execute(..) should
      return a read-only Collection and that the size() method does not have
      to implemented (i.e. it may return MAXINT or 0). So the only JDO
      implementation portable way to work with the collection is to call
      iterator() and iterator over the instances. Versant Open Access provides
      extra functionality depending on how you access the collection and the
      RandomAccess query property (see <xref linkend="random_access" />):</para>

      <section id="randomaccess_false">
        <title>RandomAccess is false<indexterm><primary>random access false</primary></indexterm></title>

        <para>If you get an iterator and get new instances by calling next()
        we keep the ResultSet open and fetch batches of rows at a time
        (configurable using the fetchSize query option, see <xref
        linkend="fetch_size" />). This works well if you only want the first
        few results. The instances are only created when you ask for them.</para>

        <para>If you cast the collection to a List (without calling size())
        and call get(index) we will efficiently skip rows until we get to
        index. The index must be greater than or equal to the previously
        highest requested index. The row skipping is done with a tight
        rs.next() loop or by using relative positioning in the ResultSet
        (depending on the JDBC driver).</para>

        <para>If you call size() on the collection and countStarOnSize is
        false (see <xref linkend="count_on_size" />) we assume you want all
        the results and get all of them in one go and close the ResultSet. The
        results are stored for random access. You can cast the collection to a
        List and call get(index) etc. This also means that you can do
        ArrayList a = new ArrayList(q.execute()) - something that is
        impossible if size() is implemented to return MAXINT or zero.</para>

        <para>If you call size() on the collection and countStarOnSize is true
        (see <xref linkend="count_on_size" />) then a &#39;SELECT
        COUNT(*)...&#39; query is run to count the rows. Subsequent calls to
        size() behave normally i.e. fetch all of the data.</para>
      </section>

      <section id="randomaccess_true">
        <title>RandomAccess is true<indexterm><primary>random access true</primary></indexterm></title>

        <para>You can cast the Collection to a List and call get(index) to get
        any element. You can also call size() without resolving the entire
        list. Versant Open Access must use a scrollable JDBC ResultSet to
        provide this functionality. This may use more database resources
        (cursors etc.) than a normal forward only ResultSet. This option is
        useful for paged results i.e. you only want a few results from
        position n onwards.</para>

        <para>The countStarOnSize option (see <xref linkend="count_on_size" />)
        is ignored if randomAccess is true.</para>
      </section>
    </section>

    <section id="query_result_caching">
      <title>Query Result Caching<indexterm><primary>query result caching</primary></indexterm></title>

      <para>Versant Open Access will cache the results of queries executed in
      optimistic transactions (see <xref linkend="optimistic_transactions" />)
      and outside of a transaction subject to certain conditions:</para>

      <itemizedlist>
        <listitem>
          <para>All the classes involved in the query in some way (candidate
          class, filter or ordering) must have a cache-strategy of
          &#39;yes&#39; (the default) or &#39;all&#39; (see <xref
          linkend="md_cache_strategy" />).</para>
        </listitem>

        <listitem>
          <para>All of the query results must be retrieved in order (i.e.
          caching of random access results is not supported).</para>
        </listitem>

        <listitem>
          <para>Changes must not have been flushed to the data store during
          the transaction. Changes are flushed (i.e. SQL updates and inserts
          generated) when a query is executed with dirty instances in the
          local cache and the standard JDO option &#39;ignoreCache&#39; is
          false or you have called flush() on VersantPersistenceManager.</para>
        </listitem>
      </itemizedlist>

      <para>The cached results are reused when an identical query is executed
      with the same parameters. The cached results are evicted if any instance
      of any of the classes involved in the query is modified. For normal
      JDOQL queries the classes involved in the query are automatically
      determined. For JDOQL queries using inline SQL you may need to add
      additional classes (see <xref linkend="inline_sql" />) as shown below:</para>

      <programlisting>Query q = pm.newQuery(Person.class);
q.setFilter(&#34;age == 18 &#38;&#38;\n&#34; +
    &#34;sql(\&#34;$1 IN (SELECT person_id FROM user_person WHERE user_id = 2)\&#34;)&#34;);
((VersantQuery)q).setEvictionClasses(new Class[]{User.class}, true);</programlisting>

      <para>You can also override the default caching behaviour for a query:</para>

      <programlisting>Query q = pm.newQuery(...);
((VersantQuery)q).setCacheable(false);</programlisting>

      <para>This can be used to enable caching for SQL queries (see <xref
      linkend="sql_query_language" />) or to disable caching for a JDOQL query
      when you know that this will not benefit the application.</para>
    </section>

    <section id="projections">
      <title>Projections, Aggregates and Grouping<indexterm><primary>aggregates</primary></indexterm><indexterm><primary>projections</primary></indexterm><indexterm><primary>group
      by</primary></indexterm><indexterm><primary>having</primary></indexterm><indexterm><primary>grouping</primary></indexterm><indexterm><primary>setResult</primary></indexterm><indexterm><primary>result</primary></indexterm><indexterm><primary>select
      list</primary></indexterm></title>

      <para>Versant Open Access has preview support for most of the additional
      query features proposed for JDO 2 (projections, aggregates, group by and
      having). It is possible that these may change before the final version
      of the specification is released. However the query portion of the
      specification was one of the first things discussed by the expert group
      and is not likely to change significantly.</para>

      <para>To use these features you need to cast the Query to a
      VersantQuery. The examples in this section are from
      <filename>demos/aggregates</filename>. The model for this example is
      shown below:</para>

      <para><inlinemediaobject><imageobject><imagedata
      fileref="images/aggregates_model.png" /></imageobject></inlinemediaobject></para>

      <para>Projections in JDO 2 make it possible to return &#34;rows&#34;
      using a SQL style select list instead of returning instances of the
      candidate class. The &#34;columns&#34; can be simple fields, whole
      objects and aggregate expressions (<literal>COUNT</literal>,
      <literal>SUM</literal>, <literal>MIN</literal>, <literal>MAX</literal>
      and <literal>AVG</literal>). Each row is returned as an
      <classname>Object[]</classname> unless there is only one logical result
      (e.g. using <literal>COUNT</literal> without grouping) in which case a
      <classname>java.lang.Number</classname> is returned.</para>

      <para>Here is a simple COUNT query from <filename>demos/aggregates</filename>:</para>

      <programlisting>VersantQuery q = (VersantQuery)pm.newQuery(Contact.class);
q.setResult(&#34;count(this)&#34;);
num = (Number)q.execute();
System.out.println(&#34;There are &#34; + num + &#34; Contact&#39;s&#34;);
q.closeAll();</programlisting>

      <para>The SQL will look something like this:</para>

      <programlisting>SELECT count(contact_id) FROM contact</programlisting>

      <para>Here is an example that uses grouping to return the number of
      contacts for each contact name:</para>

      <programlisting>VersantQuery q = (VersantQuery)pm.newQuery(Contact.class);
q.setResult(&#34;name, count(this)&#34;);
q.setGrouping(&#34;name&#34;);
q.setOrdering(&#34;name ascending&#34;);
ans = (Collection)q.execute();
for (Iterator i = ans.iterator(); i.hasNext();) {
    Object[] row = (Object[])i.next();
    String name = (String)row[0];
    int count = ((Number)row[1]).intValue();
    System.out.println(name + &#34;, &#34; + count);
}
q.closeAll();</programlisting>

      <para>The output is:</para>

      <programlisting>carl, 6
david, 5
dirk, 1
jaco, 7
lisa, 2
michelle, 3
pickle, 2</programlisting>

      <para>The SQL is as follows:</para>

      <programlisting>SELECT nme, count(contact_id) 
FROM contact 
GROUP BY nme 
ORDER BY nme</programlisting>

      <para>Here is a more advanced example using a grouping expression with
      <literal>having</literal> to list all countries with at least 3
      contacts. Note that actual county objects are returned, not just the
      name of each country:</para>

      <programlisting>VersantQuery q = (VersantQuery)pm.newQuery(Contact.class);
q.setResult(&#34;address.country, count(this)&#34;);
q.setGrouping(&#34;address.country having count(this) &#62;= 3&#34;);
q.setOrdering(&#34;address.country.name ascending&#34;);
ans = (Collection)q.execute();
for (Iterator i = ans.iterator(); i.hasNext();) {
    Object[] row = (Object[])i.next();
    Country country = (Country)row[0];
    int count = ((Number)row[1]).intValue();
    System.out.println(country + &#34;, &#34; + count);
}
q.closeAll();</programlisting>

      <para>The output is:</para>

      <programlisting>Belgium, 3
China, 6
France, 5
India, 4
South Africa, 3</programlisting>

      <para>The SQL is as follows:</para>

      <programlisting>SELECT b.country_id, count(a.contact_id) 
FROM contact a 
     INNER JOIN address AS b ON (a.address_id = b.address_id) 
     INNER JOIN country AS c ON (b.country_id = c.country_id) 
GROUP BY b.country_id 
HAVING count(a.contact_id) &#62;= 3 
ORDER BY c.nme</programlisting>
    </section>

    <section id="named_queries">
      <title>Named Queries<indexterm><primary>named queries</primary></indexterm><indexterm><primary>JDO
      2 named queries</primary></indexterm></title>

      <para>JDO 2 provides for queries defined in the .jdo meta data that are
      invoked by name at runtime. Versant Open Access has preview support for
      this feature for JDOQL queries and will have support for SQL queries
      soon. The queries are placed with their candidate class in the meta
      data. Here is the meta data for the Contact class from
      <filename>demos/aggregates</filename>:</para>

      <programlisting>&#60;class name=&#34;Contact&#34;&#62;
    &#60;query name=&#34;countryContactCounts&#34; 
            ordering=&#34;address.country.name ascending&#34;&#62;
        &#60;result grouping=&#34;address.country.name having count(this) &#38;gt;= n&#34;&#62;
            &#60;![CDATA[address.country.name, count(this)]]&#62;
        &#60;/result&#62;
        &#60;declare parameters=&#34;Integer n&#34; /&#62;
    &#60;/query&#62;
&#60;/class&#62;</programlisting>

      <para>A named query is used at runtime as follows:</para>

      <programlisting>VersantPersistenceManager pm = ...
Query q = pm.jdoGenieNewNamedQuery(Contact.class, &#34;countryContactCounts&#34;);
Collection ans = (Collection)q.execute(new Integer(3));</programlisting>

      <para>It is easiest to edit named queries using the Workbench:</para>

      <para><inlinemediaobject><imageobject><imagedata
      fileref="images/named_query_edit.png" /></imageobject></inlinemediaobject></para>
    </section>

    <section id="refresh_by_query">
      <title>RefreshAll by Query<indexterm><primary>refresh by query</primary></indexterm></title>

      <para>The standard <literal>PersistenceManager</literal> method
      <literal>refreshAll(Collection)</literal> reloads the default fetch
      group fields for all objects in the collection from the database. If the
      collection is large and the level 2 cache is disabled or the PM is
      remote then this can take a long time. Versant Open Access must refresh
      each instance individually from the database (if level 2 cache is
      disabled) or the server (for a remote PM). To overcome this problem
      Versant Open Access optimizes <literal>refreshAll</literal> calls on a
      collection returned by a JDOQL query. Instances that are already in the
      local PM cache are refilled from the instances returned by the query
      avoiding separate operations (and potentially SQL queries) to refresh
      them.</para>

      <para>This is completely transparent to the application unless the fetch
      group used by the query (e.g. the default fetch group) includes
      references, Collection&#39;s or Map&#39;s. Versant Open Access will
      prefetch the persistent instances referenced by these fields and they
      will also be refreshed.</para>

      <para>Here is an example:</para>

      <programlisting>Query q = pm.newQuery(Contact.class);
q.declareParameters(&#34;String p&#34;);
q.setFilter(&#34;name.toLowerCase().startsWith(p)&#34;);
Collection ans = q.execute(&#34;d&#34;);
pm.refreshAll(ans);
q.closeAll();</programlisting>

      <para>This optimization is possible as Versant Open Access defers actual
      execution of a query until methods are invoked on the returned
      <literal>Collection</literal>.</para>
    </section>

    <section id="jdoql_extensions">
      <title>JDOQL extensions<indexterm><primary>query extensions</primary></indexterm></title>

      <para>Versant Open Access supports some useful non-standard extensions
      to JDOQL.</para>

      <section id="jdoql_tolowercase">
        <title>toLowerCase() on Strings<indexterm><primary>toLowerCase()</primary></indexterm><indexterm><primary>case
        insensitive queries</primary></indexterm></title>

        <para>This method is mentioned in version 1.0 of the JDO specification
        but was deferred to version 2.0 therefore JDO implementations do not
        have to support it. It makes it possible to do case insensitive
        queries and is supported by most implementations.</para>

        <programlisting>public class Person {
    private String name;
    ...
}

Filter: name.toLowerCase().startsWith(&#34;d&#34;)</programlisting>
      </section>

      <section id="jdoql_contains_on_maps">
        <title>contains(object) on Maps<indexterm><primary>contains(object) on
        maps</primary></indexterm></title>

        <para>This is a logical extension of the standard JDOQL method
        Collection.contains(object) to maps. It tests the values of the map.</para>

        <programlisting>public class Person {
    private Map emailMap; // &#34;home&#34;, &#34;work&#34; etc. -&#62; &#34;someone@somewhere&#34;
    ...
}

Filter: emailMap.contains(&#34;david@hemtech.co.za&#34;)</programlisting>
      </section>

      <section id="jdoql_containskey">
        <title>containsKey(object) on Maps<indexterm><primary>containsKey(object)</primary></indexterm></title>

        <para>This is a logic extension of the standard JDOQL method
        Collection.contains(object) to the keys of a Map.</para>

        <programlisting>public class Person {
    private Map emailMap; // &#34;home&#34;, &#34;work&#34; etc. -&#62; &#34;someone@somewhere&#34;
    ...
}

Filter: emailMap.containsKey(&#34;home&#34;)</programlisting>
      </section>

      <section id="jdoql_isempty">
        <title>isEmpty() on Collections and Maps<indexterm><primary>isEmpty()</primary></indexterm></title>

        <para>This may be used on Collection and Map fields to test to see if
        they are empty. Example:</para>

        <programlisting>public class Product {
    private List categoryList;
    ...
}

Filter: categoryList.isEmpty()</programlisting>
      </section>

      <section id="inline_sql">
        <title>sql(&#34;SQL text&#34;) for inline SQL<indexterm><primary>sql()</primary></indexterm><indexterm><primary>inline
        sql</primary></indexterm></title>

        <para>The sql() extension may be used on its own or on any field
        expression to embed SQL text directly in the generated SQL (also see
        <xref linkend="sql_query_language" />). A simple column name
        replacement syntax provides easy access to the column names for field
        expressions. This feature can be used to invoke database specific SQL
        functions and to replace all or part of the where clause. The SQL text
        it produces is inserted without modification.</para>

        <para>This data model is used in the examples in this section:</para>

        <programlisting>public class Person {
    private String name; // column &#39;nme&#39;
    private int age;     // column &#39;age&#39;
    private Address address;
}

public class Address {
    private String city;
}</programlisting>

        <para>Here is a simple example:</para>

        <programlisting>Query q = pm.newQuery(Person.class);
q.setFilter(&#34;age == 18 &#38;&#38; sql(\&#34;char_length(nme) &#62; 5\&#34;)&#34;);
Collection ans = (Collection)q.execute();

SELECT person_id, nme, age, address_id, jdo_version
FROM person
WHERE age = 18
  and char_length(nme) &#62; 5</programlisting>

        <para>This example mixes normal JDOQL with the Postgres
        <literal>char_length</literal> function to find all the eighteen year
        old Person&#39;s with name longer than 5 characters. It can be
        improved to avoid hardcoding in the <literal>nme</literal> column as
        follows:</para>

        <programlisting>Query q = pm.newQuery(Person.class);
q.setFilter(&#34;age == 18 &#38;&#38; name.sql(\&#34;char_length($1) &#62; 5\&#34;)&#34;);
Collection ans = (Collection)q.execute();</programlisting>

        <para>The <literal>$1</literal> expression in the SQL text refers to
        the first column for the field expression that <literal>sql()</literal>
        has been invoked on. For fields consisting of more than one column
        (e.g. a reference to a class with a composite primary key)
        <literal>$n</literal> refers to column n. Column name replacement is
        very valuable when navigating through references:</para>

        <programlisting>Query q = pm.newQuery(Person.class);
q.setFilter(&#34;address.city.sql(\&#34;char_length($1) IN (3, 6, 9)\&#34;)&#34;);
Collection ans = (Collection)q.execute();

SELECT a.person_id, a.nme, a.age, a.address_id, a.jdo_version
FROM person a
     INNER JOIN address AS b ON (a.address_id = b.address_id)
WHERE char_length(b.city) IN (3, 6, 9)</programlisting>

        <para>Versant Open Access will add the join to pickup the
        <literal>city</literal> field on <classname>Address</classname> and
        supply the correct aliased column <literal>b.city</literal> in the
        inline SQL expression. When sql() is used on its own (i.e. without a
        field expression) then the column name placeholders resolve to the
        columns in the primary key of the candidate class. This example will
        find all the Person&#39;s with age 18 and an even primary key:</para>

        <programlisting>Query q = pm.newQuery(Person.class);
q.setFilter(&#34;age == 18 &#38;&#38; sql(\&#34;$1 % 2 = 0\&#34;)&#34;);
Collection ans = (Collection)q.execute();

SELECT person_id, nme, age, address_id, jdo_version
FROM person
WHERE age = 18
  and person_id % 2 = 0</programlisting>

        <para>Inline SQL can reference tables belonging to classes not
        otherwise involved in the query. This may happen through a subquery on
        a table or view or some other mechanism. You must add the
        corresponding classes to the query eviction list to ensure that the
        query results are evicted from the cache when instances of those
        classed are changed. Note that Versant Open Access automatically
        evicts when instances of the candidate class or classes involved in
        the filter or ordering expression are modified. Here is an example:</para>

        <programlisting>public class User {
    private List personList; // user_person link table
}

Query q = pm.newQuery(Person.class);
q.setFilter(&#34;age == 18 &#38;&#38;\n&#34; +
    &#34;sql(\&#34;$1 IN (SELECT person_id FROM user_person WHERE user_id = 2)\&#34;)&#34;);
((VersantQuery)q).setEvictionClasses(new Class[]{User.class}, true);
Collection ans = (Collection)q.execute();

SELECT person_id, nme, age, address_id, jdo_version
FROM person
WHERE age = 18
  and owner IN (SELECT owner FROM user_person WHERE user_id = 2)</programlisting>

        <para>The call to <methodname>VersantQuery.setEvictionClasses</methodname>
        ensures that if any <classname>User</classname> instances are modified
        the query results will be evicted from the cache.</para>
      </section>

      <section id="jdoql_single_quote">
        <title>Single quoted &#39;string&#39; literals<indexterm><primary>string
        literals</primary></indexterm></title>

        <para>String literals may use single quotes in addition to the
        standard double quotes. This feature will be part of JDO 2.0.</para>

        <programlisting>Query q = pm.newQuery(Person.class);
q.setFilter(&#34;name == &#39;david&#39;&#34;);
// single quotes used for readability - same as:
// q.setFilter(&#34;name == \&#34;david\&#34;&#34;);</programlisting>
      </section>
    </section>

    <section id="variables">
      <title>JDOQL Variables<indexterm><primary>JDOQL variables</primary></indexterm><indexterm><primary>variables</primary></indexterm><indexterm><primary>variables
      in JDOQL</primary></indexterm></title>

      <para>JDOQL variables are a standard part of JDO and used to drill down
      through collection and map fields in a filter expression. This section
      has some examples using the classes from tut1 (<filename>demos/tut1</filename>)
      to help those new to JDO (also see the JDO books listed in <xref
      linkend="jdo_concepts" />).</para>

      <para>The tut1 domain model is shown below.</para>

      <para><inlinemediaobject><imageobject><imagedata
      fileref="images/tut1_model.png" /></imageobject></inlinemediaobject></para>

      <para>To find all the Orders for a given Item:</para>

      <programlisting>Query query = pm.newQuery(Order.class);
query.declareVariables(&#34;OrderLine v&#34;);
query.declareParameters(&#34;Item i&#34;);
query.setFilter(&#34;lines.contains(v) &#38;&#38; v.item == i&#34;);
Collection col = (Collection)query.execute(i);</programlisting>

      <para>The variable (<literal>OrderLine v</literal>) is
      <emphasis>bound</emphasis> to the lines collection on Order and filter
      conditions applied to it (<literal>v.item == i</literal>). The filter
      conditions must be on the right hand side the contains expression
      binding the variable and be joined to it with and (<literal>&#38;&#38;</literal>).</para>

      <para>For databases that support subqueries (all except MySQL) the
      generated SQL will look like this:</para>

      <programlisting>SELECT a.ordr_id, a.customer_id, a.order_date, a.jdo_version
  FROM ordr AS a
 WHERE EXISTS (SELECT 1 FROM order_line AS b
                WHERE a.ordr_id = b.ordr_id
                  AND b.item_id = ?)</programlisting>

      <para>On MySQL an equivalent query with SELECT DISTINCT is generated
      instead:</para>

      <programlisting>SELECT DISTINCT a.ordr_id, a.customer_id, a.order_date, a.jdo_version
  FROM ordr a 
       INNER JOIN order_line AS b ON (a.ordr_id = b.ordr_id AND b.item_id = ?)</programlisting>

      <para>JDOQL queries can involve more than one variable. This query finds
      all Orders with duplicate OrderLine&#39;s i.e. lines for the same Item.</para>

      <programlisting>Query query = pm.newQuery(Order.class);
query.declareVariables(&#34;OrderLine v1; OrderLine v2&#34;);
query.setFilter(&#34;lines.contains(v1) &#38;&#38; lines.contains(v2) &#34;+
        &#34;&#38;&#38; v1.item == v2.item &#38;&#38; v1 != v2&#34;);
Collection col = (Collection)query.execute();</programlisting>

      <para>For databases that support subqueries (all except MySQL) the
      generated SQL will look like this:</para>

      <programlisting>SELECT a.ordr_id, a.customer_id, a.order_date, a.jdo_version
  FROM ordr AS a
 WHERE EXISTS (SELECT 1 FROM order_line AS b
                WHERE a.ordr_id = b.ordr_id
                  AND EXISTS (SELECT 1 FROM order_line AS c
                               WHERE a.ordr_id = c.ordr_id
                                 AND b.item_id = c.item_id
                                 AND b.order_line_id &#60;&#62; c.order_line_id))</programlisting>

      <para>On MySQL an equivalent query with SELECT DISTINCT is generated
      instead:</para>

      <programlisting>SELECT DISTINCT a.ordr_id, a.customer_id, a.order_date, a.jdo_version
  FROM ordr a 
       INNER JOIN order_line AS b ON (a.ordr_id = b.ordr_id)
       INNER JOIN order_line AS c ON (a.ordr_id = c.ordr_id 
             AND b.item_id = c.item_id 
             AND b.order_line_id &#60;&#62; c.order_line_id)</programlisting>

      <section id="unbound_variables">
        <title>Unbound Variables<indexterm><primary>JDOQL unbound variables</primary></indexterm><indexterm><primary>unbound
        variables</primary></indexterm><indexterm><primary>unbound variables
        in JDOQL</primary></indexterm></title>

        <para>Versant Open Access supports unbound variables (an optional part
        of the JDO specification). Unbound variables make it possible to write
        JDOQL queries that are not otherwise supported by the model classes
        through collections and references.</para>

        <para>This query will find all Orders with at least one Item in common
        with another order.</para>

        <programlisting>Query query = pm.newQuery(Order.class);
query.declareVariables(&#34;OrderLine line1; Order other; OrderLine line2&#34;);
query.setFilter(&#34;lines.contains(line1) &#34;+
        &#34;&#38;&#38; other.lines.contains(line2) &#38;&#38; other != this &#34;+
        &#34;&#38;&#38; line1.item == line2.item&#34;);
Collection col = (Collection)query.execute();</programlisting>

        <para>The variable other is implicitly bound to the extent of the
        Order class. The line1 and line2 variables are bound normally.</para>

        <para>For databases that support subqueries (all except MySQL) the
        generated SQL will look like this:</para>

        <programlisting>SELECT a.ordr_id,
       a.customer_id,
       a.order_date,
       a.jdo_version
  FROM ordr AS a
 WHERE EXISTS (SELECT 1 FROM order_line AS b
                WHERE a.ordr_id = b.ordr_id
                  AND EXISTS (SELECT 1
                                FROM ordr AS c
                               WHERE EXISTS (SELECT 1 FROM order_line AS d
                                              WHERE c.ordr_id = d.ordr_id
                                                AND c.ordr_id &#60;&#62; a.ordr_id
                                                AND b.item_id = d.item_id)))</programlisting>

        <para>On MySQL an equivalent query with SELECT DISTINCT is generated
        instead:</para>

        <programlisting>SELECT DISTINCT a.ordr_id, a.customer_id, a.order_date, a.jdo_version
  FROM ordr a 
       INNER JOIN order_line AS b ON (a.ordr_id = b.ordr_id)
       CROSS JOIN ordr AS c 
       INNER JOIN order_line AS d ON (c.ordr_id = d.ordr_id 
              AND c.ordr_id &#60;&#62; a.ordr_id AND b.item_id = d.item_id)</programlisting>
      </section>
    </section>

    <section id="casting_in_jdoql">
      <title>Class Casts In JDOQL<indexterm><primary>casting</primary></indexterm><indexterm><primary>class
      casts</primary></indexterm></title>

      <para>Versant Open Access supports explicit class casts in JDOQL
      queries. These are especially useful with interface and Object
      references which cannot be navigated in a query without casting. It is
      actually possible to cast any reference to any other class. This does
      not make sense from a Java perspective but is useful when querying
      models mapped to legacy databases. All of these queries are executed
      entirely in SQL.</para>

      <para>Here is an example from the interfaces demo in
      <filename>demos/interfaces:</filename><programlisting>public interface HasAddress { ... }

public class Address {
    private String street;
    private String city;
    private HasAddress owner;
}

public class Supplier implements HasAddress {
    private String name;
    private Address address;
}</programlisting></para>

      <para>The query below navigates through the owner reference on Address
      by casting it to Supplier:</para>

      <programlisting>Query q = pm.newQuery(Address.class);
q.setFilter(&#34;((Supplier)owner).name.toLowerCase().startsWith(p)&#34;);
q.declareParameters(&#34;String p&#34;);
Collection ans = (Collection)q.execute(&#34;chic&#34;);</programlisting>

      <para>The generated SQL includes a join that checks the class column for
      the owner reference to see that it is actually a Supplier (the class-id
      for Supplier is 1456209927):</para>

      <programlisting>SELECT a.address_id, a.city, a.ownr_class, a.ownr_id, a.street, a.jdo_version 
FROM address AS a 
  JOIN supplier AS b ON (a.ownr_id = b.supplier_id and a.ownr_class = 1456209927) 
WHERE lower(b.nme) LIKE ?</programlisting>

      <para>If the type code for Supplier for the owner reference was
      configured to be &#39;S&#39; then the SQL would look as follows:</para>

      <programlisting>SELECT a.address_id, a.city, a.ownr_class, a.ownr_id, a.street, a.jdo_version 
FROM address AS a 
  JOIN supplier AS b ON (a.ownr_id = b.supplier_id and a.ownr_class = &#39;S&#39;) 
WHERE lower(b.nme) LIKE ?</programlisting>
    </section>

    <section id="cancel_query">
      <title>Cancelling a Query<indexterm><primary>cancelling a query</primary></indexterm></title>

      <para>You can cancel the last executed query by casting the
      <literal>PersistenceManager</literal> that created it to a
      <literal>VersantPersistenceManager</literal> and calling
      <literal>cancelQueryExecution()</literal>. This method is thread safe.
      This feature relies on cancel support from the JDBC driver and database.
      The thread executing the query will most likely receive an
      <literal>SQLException</literal> wrapped in a <literal>JDODataStoreException</literal>.</para>
    </section>

    <section id="sql_query_language">
      <title>Direct SQL and Stored Procedures<indexterm><primary>stored
      procedures</primary></indexterm><indexterm><primary>SQL query language</primary></indexterm></title>

      <para>The Enterprise edition of Versant Open Access supports SQL as a
      query language (instead of JDOQL). The ResultSet returned can be mapped
      to instances of a persistent class or returned as a JDO 2 projection.
      JDOQL is a powerful query language but sometimes you may need to do
      something not supported by JDOQL and our inline SQL extension (see <xref
      linkend="inline_sql" />) such as invoking a stored procedure.</para>

      <para>Here is a simple example:</para>

      <programlisting>Query q = pm.newQuery(&#34;SQL&#34;, 
    &#34;SELECT CUST_ID, NAME FROM CUST WHERE NAME LIKE ?&#34;);  
q.declareParameters(&#34;VARCHAR p1&#34;);
q.setClass(Customer.class);
Collection ans = (Collection)q.execute(&#34;ACME%&#34;);
for (Iterator i = ans.iterator(); i.hasNext(); ) {
    Customer cust = (Customer) it.next();
    ...
}</programlisting>

      <para>If the filter starts with SELECT (case insensitive) then it is
      assumed to be a normal SQL query and is invoked with <literal>PreparedStatement.executeQuery</literal>.
      If it starts with anything else it is assumed to be a stored procedure
      and a <literal>CallableStatement</literal> is used. Stored procedures
      must return a single <classname>ResultSet</classname> or have an
      <literal>OUT</literal> parameter that returns a ResultSet. The types of
      <literal>IN</literal> parameters are specified using the names from
      <classname>java.sql.Types</classname>.</para>

      <section>
        <title>Returning Persistent Instances</title>

        <para>The <classname>ResultSet</classname> returned by the SQL query
        or stored procedure must contain the primary key column(s) and
        discriminator column (if any). Extra columns with names the same as
        columns mapped to fields of the class (case insensitive) are used if
        present and others are ignored.</para>

        <para>Here is an example:</para>

        <programlisting>Query q = pm.newQuery(&#34;SQL&#34;,
    &#34;{call GCS_REACTIONS.OPN_REACTIONDUPLICATES(?)}&#34;);
q.declareParameters(&#34;NUMERIC p1&#34;);
q.setClass(Reaction.class);
Collection ans = (Collection)q.execute(rxnID);
for (Iterator i = ans.iterator(); i.hasNext(); ) {
    Reaction dup = (Reaction) it.next();
    ...
}</programlisting>

        <para>The class of the query is set to <classname>Reaction</classname>
        so Open Access will map the <classname>ResultSet</classname> to
        persistent <classname>Reaction</classname> instances.</para>
      </section>

      <section>
        <title>Returning Projections<indexterm><primary>SQL projections</primary></indexterm></title>

        <para>If no class is specified for the query using setClass then a
        <classname>Collection</classname> of <classname>Object[]</classname>
        is returned. Each position in each <classname>Object[]</classname>
        &#34;row&#34; corresponds to a column in the <classname>ResultSet</classname>.
        The individual positions are filled by calling <literal>ResultSet.getObject(index
        + 1)</literal>.</para>

        <para>Here is an example:</para>

        <programlisting>Query q = pm.newQuery(&#34;SQL&#34;, &#34;SELECT A, B FROM TAB WHERE A = ? AND B = ?&#34;);
q.declareParameters(&#34;VARCHAR p1, VARCHAR p2&#34;);
Collection ans = (Collection)q.execute(&#34;Bob&#34;, &#34;Fred&#34;);
for (Iterator i = ans.iterator(); i.hasNext(); ) {
    Object[] row = (Object[])i.next();
    String a = (String)row[0];
    String b = (String)row[1];
    ...
}</programlisting>
      </section>

      <section id="out_params">
        <title>OUT Parameters<indexterm><primary>OUT parameters</primary></indexterm><indexterm><primary>SQL
        OUT parameters</primary></indexterm><indexterm><primary>stored proc
        OUT parameters</primary></indexterm></title>

        <para>Stored procedures with a single OUT parameter returning a
        <classname>ResultSet</classname> are supported. If this mechanism is
        used then any other <classname>ResultSet</classname> returned by the
        stored procedure is ignored.</para>

        <para>Here is an example:</para>

        <programlisting>Query q = pm.newQuery(&#34;SQL&#34;,
    &#34;{call GCS_REACTIONS.OPN_REACTIONDUPLICATES(?,?)}&#34;);
q.declareParameters(&#34;NUMERIC p1, OUT.CURSOR p2&#34;);
q.setClass(Reaction.class);
Collection ans = (Collection)q.execute(rxnID, null);
for (Iterator i = ans.iterator(); i.hasNext(); ) {
    Reaction dup = (Reaction) it.next();
    ...
}</programlisting>

        <para>The OUT parameter type must be <literal>OUT.CURSOR</literal>.</para>
      </section>

      <section>
        <title>Caching SQL Query Results<indexterm><primary>caching SQL
        results</primary></indexterm><indexterm><primary>SQL query result
        caching</primary></indexterm><indexterm><primary>SQL query caching</primary></indexterm></title>

        <para>The results of direct SQL queries are not stored in the level 2
        cache by default. You can enable caching as follows:</para>

        <programlisting>Query q = pm.newQuery(&#34;SQL&#34;,...);
q.setClass(Reaction.class);
((VersantQuery)q).setCacheable(true);</programlisting>

        <para>The cached results will be evicted if instances of the class for
        the query or the class itself are evicted. If the query has no class
        (i.e. it is returning a projection) then the results will not be
        evicted automatically. You can specify additional eviction classes:</para>

        <programlisting>Query q = pm.newQuery(&#34;SQL&#34;,...);
q.setClass(Reaction.class);
((VersantQuery)q).setEvictionClasses(
    new Class[]{Atom.class, Compound.class}, true);
...</programlisting>

        <para>The results will be cached and automatically evicted of any
        instances of Reaction, Atom or Compound are evicted or those classes
        are evicted.</para>
      </section>
    </section>
  </chapter>

  <chapter id="transactions">
    <title>Transactions and Locking<indexterm><primary>transactions</primary></indexterm><indexterm><primary>locking</primary></indexterm></title>

    <para>Versant Open Access supports optimistic (optional JDO feature) and
    datastore (non-optimistic) transactions. When optimistic transactions are
    used each operation is executed with a separate JDBC transaction and data
    may be retrieved from the level 2 cache instead of the database. With
    datastore (non-optimistic) transactions the same JDBC connection is used
    for all operations and a commit is only done when the JDO transaction
    commits. Datastore transactions are useful when database locks must be
    maintained during the transaction but optimistic transactions offer better
    performance through caching and less database lock contention.</para>

    <para>The JDO transaction mode is selected at runtime as follows:<programlisting>PersistenceManager pm = ...
pm.currentTransaction().setOptimistic(true);
pm.currentTransaction().begin();
// optimistic transaction
pm.currentTransaction().commit();

pm.currentTransaction().setOptimistic(false);
pm.currentTransaction().begin();
// datastore (non-optimistic) transaction
pm.currentTransaction().commit();</programlisting></para>

    <para>The default transaction mode is controlled using the standard
    <literal>jdo.javax.jdo.option.Optimistic</literal> option in the
    properties file (<filename>.properties</filename> project) used to get the
    PersistenceManagerFactory. This can be configured in the Workbench using
    the Project Properties dialog (<command>File | Project Properties</command>).</para>

    <section id="optimistic_transactions">
      <title>Optimistic Transactions<indexterm><primary>optimistic
      transactions</primary></indexterm></title>

      <para>During an optimistic transaction each database operation is
      executed using a separate JDBC transaction using a (possibly) different
      JDBC connection. The JDBC connection is returned to the pool immediately
      after each operation. The the required data (instance or JDOQL results)
      is available in the level 2 cache (shared by all PMs) then no database
      access is required.</para>

      <para>Optimistic transactions are the best choice for most applications.
      The cache improves performance by reducing database access and there is
      less lock contention at the database level. Your application may be able
      to run with a smaller connection pool as each connection is used for a
      much shorter time. Applications using remote PersistenceManager&#39;s
      should always use optimistic transactions to avoid holding database
      locks for a long time. It is not a good idea to keep a real JDBC
      transaction open across a network call.</para>

      <para>There are some operations that will cause an optimistic
      transaction to degrade to a datastore transaction. When this happens a
      JDBC connection is pinned to the PM until commit or rollback.</para>

      <section id="flushing">
        <title>JDOQL Flushing<indexterm><primary>flushing</primary></indexterm></title>

        <para>If a JDOQL query is executed that involves dirty instances in
        the current transaction in some way (candidate class, navigated in the
        filter or used in the ordering) then the dirty instances are first
        flushed to the database. A JDBC connection is obtained and pinned to
        the PM and SQL inserts and updates are executed. The JDBC transaction
        is closed and the connection released on commit or rollback.</para>

        <para>This behaviour can be controlled at runtime as follows:<programlisting>Query q = pm.newQuery(...);
q.setIgnoreCache(true);
...
Collection ans = (Collection)q.execute(...);</programlisting></para>

        <para>The default behaviour can be controlled using the standard
        <literal>javax.jdo.option.IgnoreCache</literal> option in the
        properties file (<filename>.properties</filename> project) used to get
        the PersistenceManagerFactory. This can be configured in the Workbench
        using the Project Properties dialog (<command>File | Project
        Properties</command>). It is recommended to set <literal>javax.jdo.option.IgnoreCache=true</literal>
        for GUI and remote PersistenceManager applications.</para>

        <para>If ignoreCache is true and there are dirty instances in the
        transaction involved in the query in some way then the query may
        return incorrect results.</para>
      </section>

      <section id="flushing_keygen">
        <title>Key Generation Flushing<indexterm><primary>key generation
        flushing</primary></indexterm></title>

        <para>Calling <classname>PM.getObjectId(pc)</classname> on an instance
        made persistent in the current transaction will trigger a flush if the
        class of the instance uses a post-insert key generator (e.g. the
        AUTOINC key generator). This is because the primary key of the new
        instance cannot be discovered without inserting it into the database.
        The same thing will happen if you access the primary key field of a
        newly persistent instance of an application identity class using a
        post-insert key generator.</para>

        <programlisting>pm.currentTransaction().begin();
AutoIncClass pc = new AutoIncClass(); // AUTOINC key generator
pm.makePersistent(pc);
Object oid = pm.getObjectId(pc);
// this will trigger a flush to do the insert as the class
// is using the AUTOINC key generator (same for any other 
// post-insert key generator)
...
pm.currentTransaction().commit();</programlisting>

        <para>This flushing can be avoided by only getting the OID after the
        commit. This will improve performance even if a post-insert key
        generator is not being used as a call to the server to generate the PK
        is avoided. Here is an example:</para>

        <programlisting>pm.currentTransaction().begin();
AutoIncClass pc = new AutoIncClass();
pm.makePersistent(pc);
pm.currentTransaction().commit();
Object oid = pm.getObjectId(pc);</programlisting>
      </section>

      <section id="calling_flush">
        <title>Calling flush()<indexterm><primary>calling flush</primary></indexterm></title>

        <para>Versant Open Access provides a method to manually flush changes
        in the current transaction to the datastore. This method can be used
        in optimistic and datastore transactions to force a flush. A JDBC
        connection is obtained and pinned to the PM and SQL inserts and
        updates are executed. The JDBC transaction is closed and the
        connection released on commit or rollback. Here is an example:</para>

        <programlisting>import com.versant.core.jdo.VersantPersistenceManager;

PersistenceManager pm = ...
pm.currentTransaction().begin();
... business code changing instances ...
((VersantPersistenceManager)pm).flush();
// changes are now visible in the database and
// the JDBC connection is pinned
pm.currentTransaction().commit();
// the JDBC connection is released</programlisting>

        <para>You may need to do this if an external application or some JDBC
        code must be able to see changes prior to commit.</para>
      </section>

      <section id="using_jdbc_directly">
        <title>Using JDBC Directly<indexterm><primary>using JDBC directly</primary></indexterm></title>

        <para>Versant Open Access supports the use of JDBC calls in a JDO
        transaction by providing access to the JDBC connection used by Versant
        Open Access for the PersistenceManager. Because an optimistic
        transaction will potentially use a different JDBC connection for each
        operation using this feature will pin the connection to the PM until
        commit or rollback. Here is an example:</para>

        <programlisting>import com.versant.core.jdo.VersantPersistenceManager;
import java.sql.Connection;

PersistenceManager pm = ...
pm.currentTransaction().begin();
Connection con = ((VersantPersistenceManager)pm).getJdbcConnection(null);
... normal JDBC calls ...
pm.currentTransaction().commit();</programlisting>

        <para>An exception is thrown if any transaction related methods are
        called on the connection (commit, rollback, setAutoCommit). The JDO
        API must be used for transaction control
        (pm.currentTransation().commit() etc.). The returned connection has
        autoCommit set to false and is a proxy for the real connection. This
        method may only be called inside a JDO transaction.</para>

        <para>The connection is pinned to the PM until commit or rollback of
        the current JDO transaction. Once commit or rollback has been done it
        will be returned to the pool and the proxy is automatically closed.
        You can call close on the proxy but this does not close the underlying
        JDBC connection and it remains pinned to the PM. If you need a JDBC
        Connection that is not associated with any JDBC transaction or
        PersistenceManager than you can call getJdbcConnection on
        VersantPersistenceManagerFactory.</para>

        <para>If JDBC event logging is on then operations on the connection
        will be logged. This method is not available to remote clients and a
        JDOUserException is thrown if it is called by a remote client or if
        the datastore does not exist.</para>
      </section>
    </section>

    <section id="datastore_transactions">
      <title>Datastore Transactions<indexterm><primary>datastore transactions</primary></indexterm></title>

      <para>Datastore or pessimistic transactions use one JDBC connection for
      the duration of the transaction. The level 2 cache is never used so as
      to maintain database locks. Datastore transactions are useful when you
      want to make sure that a given transaction will not fail due to
      optimistic locking conflicts with another transaction. Versant Open
      Access provides methods to control how instances are locking in a
      datastore transaction and on the JDBC transaction isolation level used.</para>

      <section id="datastore_locking_mode">
        <title>Locking Mode<indexterm><primary>transaction locking mode</primary></indexterm><indexterm><primary>locking
        mode</primary></indexterm><indexterm><primary>datastore transaction
        locking mode</primary></indexterm></title>

        <para>Versant Open Access supports 3 locking modes for datastore
        transactions:</para>

        <informaltable>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Locking Mode</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>LOCKING_FIRST</entry>

                <entry>Obtain an exclusive lock on only the first (next)
                instance fetched in the transaction. This is the default
                locking mode.</entry>
              </row>

              <row>
                <entry>LOCKING_ALL</entry>

                <entry>Obtain exclusive locks on all instances fetched in the
                transaction.</entry>
              </row>

              <row>
                <entry>LOCKING_NONE</entry>

                <entry>Do not obtain any exclusive locks.</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>The default locking mode can changed using the Workbench (<command>File
        | Project Properties, General tab</command>) or by editing the
        <filename>.properties</filename> properties file directly (e.g.
        <literal>datastore.tx.locking=LOCKING_ALL</literal>). The mode can
        also be changed at runtime using the <methodname>setDatastoreTxLocking</methodname>
        method on <classname>VersantPersistenceManager</classname>. This can
        be done at any time outside or during a transaction. The mode set only
        takes effect inside a datastore transaction.</para>

        <para>How exclusive locks are obtained depends on the database as
        indicated in the following table:</para>

        <informaltable>
          <tgroup cols="3">
            <thead>
              <row>
                <entry>Database(s)</entry>

                <entry>Exclusive Locking</entry>

                <entry>JDOQL Locking</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>DB2, Cache, Firebird, Hypersonic, Informix SE,
                Informix, Interbase, Microsoft SQL Server, Pointbase and
                Sybase</entry>

                <entry>UPDATE table SET col=col WHERE pk=?</entry>

                <entry>NO</entry>
              </row>

              <row>
                <entry>Oracle</entry>

                <entry>SELECT ... FROM table ... FOR UPDATE</entry>

                <entry>YES (except DISTINCT)</entry>
              </row>

              <row>
                <entry>MySQL</entry>

                <entry>SELECT ... FROM table ... FOR UPDATE</entry>

                <entry>YES</entry>
              </row>

              <row>
                <entry>Postgres</entry>

                <entry>SELECT ... FROM table ... FOR UPDATE OF table</entry>

                <entry>YES (except DISTINCT)</entry>
              </row>

              <row>
                <entry>SAP DB</entry>

                <entry>SELECT ... FROM table ... WITH LOCK EXCLUSIVE</entry>

                <entry>YES</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>For databases without &#39;SELECT FOR UPDATE&#39; a dummy update
        statement is executed. Versant Open Access will select a simple
        non-indexed, non-foreign key column to update. Note that instances
        fetched using a JDOQL query are only locked on databases that support
        a variant of &#39;SELECT FOR UPDATE&#39; as indicated by the JDOQL
        Locking column on the table.</para>

        <para>Oracle and Postgres only support using FOR UPDATE for queries
        that do not include SELECT DISTINCT. Versant Open Access will generate
        DISTINCT queries on Oracle and Postgres for filters with
        <literal>contains()</literal> expressions under an <literal>||</literal>
        operator and in some other circumstances.</para>

        <para>For maximum portability between databases you should start
        datastore transactions with an instance lookup (getObjectById, refresh
        or touching an existing instance) as shown in the following example:</para>

        <programlisting>PersistenceManager pm = ...
pm.currentTransaction().setOptimistic(false);
pm.currentTransaction().begin();
Order order = pm.getObjectById(oid, true);
// obtain exclusive lock on order
Customer cust = order.getCustomer();
// cust is fetched without an exclusive lock
...
pm.currentTransaction().commit();
// lock is released</programlisting>

        <para>The default locking mode is LOCKING_FIRST which will only lock
        the first instance fetched in the transaction. On Oracle and MySQL
        this example will produce SQL similar to the following:</para>

        <programlisting>SELECT order_date, ..., cust_no FROM ordr WHERE order_no = ? FOR UPDATE
SELECT nme, ..., city FROM customer WHERE cust_no = ?</programlisting>

        <para>On Sybase, Microsoft SQL Server and other databases without
        &#39;SELECT FOR UPDATE&#39; the following SQL is generated:</para>

        <programlisting>UPDATE ordr SET jdo_version=jdo_version WHERE pk=?
SELECT order_date, ..., cust_no FROM ordr WHERE order_no = ?
SELECT nme, ..., city FROM customer WHERE cust_no = ?</programlisting>

        <para>Note that when the locking mode is changed during a datastore
        transaction it takes effect from that point onwards and will apply to
        the next datastore transaction as well. Setting the mode to
        LOCKING_FIRST in a datastore transaction will cause the next instance
        fetched to be locked. Any instances fetched with JDOQL before that
        time will be locked if the database supports &#39;SELECT FOR
        UPDATE&#39;.</para>
      </section>

      <section id="locking_instances">
        <title>Locking Instances<indexterm><primary>locking instances</primary></indexterm></title>

        <para>The locking modes described in <xref
        linkend="datastore_tx_locking" /> can be used to construct a static
        utility method to lock an instance:</para>

        <programlisting>/**
 * Obtain an exclusive lock on pc. Only locks inside a datastore
 * transaction.
 */
public static void lock(PersistenceManager pm, Object pc) {
    VersantPersistenceManager gpm = (VersantPersistenceManager)pm;
    int lockingMode = gpm.getDatastoreTxLocking();
    gpm.setDatastoreTxLocking(VersantPersistenceManager.LOCKING_FIRST);
    gpm.refresh(pc);
    if (lockingMode != VersantPersistenceManager.LOCKING_FIRST) {
        gpm.setDatastoreTxLocking(lockingMode);
    }
} </programlisting>

        <para>This method saves the current locking mode, changes it to
        LOCKING_FIRST which will lock the next instance fetched, does a
        refresh to lock the instance and then restores the original locking
        mode.</para>

        <para>The following method is similar but accepts an OID instead of a
        managed instance.</para>

        <programlisting>/**
 * Obtain an exclusive lock on the instance for oid and return it.
 * Only locks inside a datastore transaction.
 */
public static Object lockOID(PersistenceManager pm, Object oid) {
    VersantPersistenceManager gpm = (VersantPersistenceManager)pm;
    int lockingMode = gpm.getDatastoreTxLocking();
    gpm.setDatastoreTxLocking(VersantPersistenceManager.LOCKING_FIRST);
    Object ans = gpm.getObjectById(oid, true);
    if (lockingMode != VersantPersistenceManager.LOCKING_FIRST) {
        gpm.setDatastoreTxLocking(lockingMode);
    }
    return ans;
} </programlisting>
      </section>

      <section id="datastore_isolation_level">
        <title>Isolation Level<indexterm><primary>transaction isolation level</primary></indexterm><indexterm><primary>isolation
        level</primary></indexterm></title>

        <para>Versant Open Access supports configuring the default database
        transaction isolation level. This is only effective for datastore
        transactions. The default is <literal>READ_COMMITTED</literal> which
        is also the most common default for database servers and JDBC drivers.
        Note that some databases do not support changing the isolation level
        (e.g. Informix SE) and many may not support some isolation levels. All
        database servers currently supported by Versant Open Access support
        <literal>READ_COMMITTED</literal> so portable applications should not
        change this. Versant Open Access will silently ignore isolation levels
        not supported by the database server.</para>

        <para>To change the default isolation level for a datastore use the
        Workbench (<command>File | Datastore Properties, General Settings tab</command>)
        or edit the <filename>.properties</filename> properties file directly
        (<literal>versant.isolationLevel=REPEATABLE_READ</literal> or
        <literal>SERIALIZABLE</literal> or <literal>READ_COMMITTED</literal>).
        Note that <literal>READ_UNCOMMITTED</literal> is not supported.</para>
      </section>

      <section id="deadlocks">
        <title>Deadlocks<indexterm><primary>deadlocks</primary></indexterm></title>

        <para>Versant Open Access does not detect deadlocks. However the
        connection pool will timeout, close and discard connections that have
        been busy for a long time (default 2 minutes). This will recover your
        system from deadlocks not detected by the database server. See <xref
        linkend="active_con_timeout" /> for more information.</para>
      </section>
    </section>
  </chapter>

  <chapter id="cache_management">
    <title>Cache Management<indexterm><primary>cache management</primary></indexterm></title>

    <para>The JDO specification describes how to manage the cache of instances
    held by each PersistenceManager(PM). This cache is usually called the
    local cache as it is local to the PM. Versant Open Access (like most JDO
    implementations) also provides a cache shared by all PMs from the same
    PersistenceManagerFactory(PMF). This cache is generally called the
    &#34;level 2 cache&#34;. Versant Open Access provides API calls to manage
    the level 2 cache that are very similar to the APIs proposed for level 2
    cache management in JDO 2.</para>

    <para>This chapter explains how to work with each cache and the
    optimizations possible with Versant Open Access. Detailed knowledge of
    this chapter is not necessary especially if you are writing web
    applications without clustering. If you are writing a GUI application, an
    application with high performance requirements or any application with
    long lived PMs or need to use clustering then you should read this
    chapter.</para>

    <section id="local_cache">
      <title>Local PM Cache<indexterm><primary>local cache</primary></indexterm><indexterm><primary>PM
      cache</primary></indexterm></title>

      <para>The local cache contains all JDO managed instances for a
      PersistenceManager(PM). It is used to ensure that there is only one
      instance for a given class and primary key (object identity) per PM.
      Once an instance has been loaded into the local cache (by navigation
      from an instance already in the cache, by calling getObjectById or by
      executing a query) Versant Open Access keeps a reference to it to ensure
      that the same instance is always returned for the same OID (primary
      key). By default Versant Open Access uses soft references (see
      <classname>java.lang.ref.SoftReference</classname>) so instances will be
      garbage collected when they are no longer referenced by the application
      and the VM is low on memory. Strong and weak references can also be used
      (see <xref linkend="cache_ref_type" />).</para>

      <para>Some knowledge of JDO instance states and transactions is required
      to understand how the local cache works. Instances in the local cache
      are hollow (not filled with data), persistent (clean or not modified),
      dirty (modified) or deleted. They are also transactional (read in a
      datastore transaction) or non-transactional (read outside a transaction
      or in an optimistic transaction).</para>

      <para>The states and state transition rules in the JDO specification are
      more detailed than the description given here. The high level of detail
      in the specification is required for vendors to ensure the portability
      of JDO applications between implementations.</para>

      <para>JDO transactions are fully explained in <xref
      linkend="transactions" />. A brief summary is as follows: Datastore or
      pessimistic transactions use one JDBC connection for the duration of the
      transaction. Versant Open Access ensures that the state of each instance
      touched in the transaction is in sync with the database. During an
      optimistic transaction or outside of any transaction, each database
      operation is executed using a separate JDBC transaction using a
      (possibly) different JDBC connection. Therefore the data present in the
      instance may be out of sync with the database and are non-transactional.</para>

      <para>The following table explains the most important states of a JDO
      managed instance (instance in the local cache):</para>

      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>State</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>hollow</entry>

              <entry>Fields will be loaded next time the instance is touched.
              If touched in a datastore transaction the field values will come
              from the database (i.e. not from the level 2 cache). If touched
              in an optimistic transaction or outside of a transaction the
              field values may come from the level 2 cache or the database.</entry>
            </row>

            <row>
              <entry>persistent-clean</entry>

              <entry>Fields have been loaded in the current datastore
              transaction i.e. the state of the instance is in sync with the
              database.</entry>
            </row>

            <row>
              <entry>persistent-non-transactional</entry>

              <entry>Fields have been loaded outside of a transaction or in an
              optimistic transaction. Instance may be out of sync with the
              database.</entry>
            </row>

            <row>
              <entry>dirty/new</entry>

              <entry>Instance has been modified in the current transaction
              (datastore or optimistic) and updates/inserts will be executed
              on commit or flush.</entry>
            </row>

            <row>
              <entry>deleted</entry>

              <entry>Instance has been deleted in the current transaction
              (datastore or optimistic) and deletes will be executed on commit
              or flush.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <section id="cache_ref_type">
        <title>Soft, Weak and Strong References<indexterm><primary>local cache
        reference type</primary></indexterm><indexterm><primary>pm cache
        reference type</primary></indexterm><indexterm><primary>reference type</primary></indexterm><indexterm><primary>soft
        references</primary></indexterm><indexterm><primary>hard references</primary></indexterm><indexterm><primary>weak
        references</primary></indexterm></title>

        <para>The type of reference Versant Open Access uses to reference
        instances in the local PM cache is configurable at PMF (project) level
        and for each PM. The default reference type is SOFT which is a safe
        default. However many server side applications may obtain better
        performance by changing to WEAK or STRONG references as shown on the
        table below. The project default can be changed in the Workbench (<command>File
        | Project Properties</command>) or by casting the PMF to
        <classname>VersantPersistenceManagerFactory</classname> and calling
        <literal>setPmCacheRefType(int)</literal>.</para>

        <informaltable>
          <tgroup cols="3">
            <thead>
              <row>
                <entry>Reference type</entry>

                <entry>Description</entry>

                <entry>Useful for</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>SOFT (default)</entry>

                <entry>Unreferenced instances are garbage collected when VM is
                low on memory.</entry>

                <entry>Applications with long lived PMs that will benefit from
                the extra level of caching (e.g. Swing GUI apps).</entry>
              </row>

              <row>
                <entry>WEAK</entry>

                <entry>Unreferenced instances are garbage collected very
                quickly.</entry>

                <entry>Applications with generally short lived PMs and large
                heaps (e.g. web applications). Less objects on the heap will
                reduce garbage collection time.</entry>
              </row>

              <row>
                <entry>STRONG</entry>

                <entry>Unreferenced instances only garbage collected when
                manually evicted by the application or when the PM is closed.</entry>

                <entry>Applications that always have short lived PMs (e.g. web
                applications using the &#34;one PM per request&#34; model).
                Soft and weak references complicate garbage collection.</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>There are a number of methods on VersantPersistenceManager that
        provide fine grained control over how objects in the local PM cache
        are referenced:</para>

        <informaltable>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>VersantPersistenceManager method</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>void setPmCacheRefType(int type)</literal></entry>

                <entry>Change the reference type used for new objects entering
                the local PM cache. References to existing objects are not
                changed.</entry>
              </row>

              <row>
                <entry><literal>int getPmCacheRefType()</literal></entry>

                <entry>Get the reference type used for new objects entering
                the local PM cache.</entry>
              </row>

              <row>
                <entry><literal>void setPmCacheRefType(Object pc, int type)</literal></entry>

                <entry>Change the reference type for the object.</entry>
              </row>

              <row>
                <entry><literal>void setPmCacheRefType(Object[] pcs, int type)</literal></entry>

                <entry>Change the reference type for the array of objects.</entry>
              </row>

              <row>
                <entry><literal>void setPmCacheRefType(Collection col, int
                type)</literal></entry>

                <entry>Change the reference type for the collection of
                objects.</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Note that evicting an instance from the local PM cache using one
        of the standard PM evict methods (see <xref
        linkend="evicting_instances" />) will change its reference to WEAK. If
        there are no other references to it will be collected next time the
        garbage collector runs.</para>
      </section>

      <section id="cache_retain_values">
        <title>RetainValues Flag<indexterm><primary>retainValues</primary></indexterm></title>

        <para>This flag controls what happens to instances involved in a
        transaction after commit as shown by the following table:</para>

        <informaltable>
          <tgroup cols="3">
            <thead>
              <row>
                <entry>RetainValues</entry>

                <entry>Datastore Tx</entry>

                <entry>Optimistic</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>false</literal></entry>

                <entry>All instances touched in the transaction become hollow
                after commit.</entry>

                <entry>All instances modified in the transaction become hollow
                after commit.</entry>
              </row>

              <row>
                <entry><literal>true</literal></entry>

                <entry>Instances touched in the transaction become
                persistent-non-transactional after commit.</entry>

                <entry>All instances modified in the transaction become
                persistent-non-transactional after commit. Unmodified
                instances are already persistent-non-transactional.</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>This flag can be changed by calling <literal>PM.currentTransaction().setRetainValues(boolean)</literal>.
        The default value of the flag for a new PM is set by the
        <literal>javax.jdo.option.RetainValues</literal> property in the
        Properties instance orginally used to create the PMF. You can change
        this in the Workbench (<command>File | Project Properties | Project</command>).</para>
      </section>

      <section id="refreshing_instances">
        <title>Refreshing Instances<indexterm><primary>refreshing instances</primary></indexterm></title>

        <para>Any persistent-non-transactional or hollow instance touched in a
        datastore transaction will be automatically refreshed from the
        database and become persistent-clean (i.e. transactional).
        Persistent-non-transactional instances touched inside an optimistic
        transaction are not automatically refreshed. Call one of the following
        methods if you need to manually refresh:</para>

        <informaltable>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>PersistenceManager method</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>void refresh(Object)</literal></entry>

                <entry>Reload the fields from the database (or level 2 cache
                if in an optimistic transaction or outside of a transaction).</entry>
              </row>

              <row>
                <entry><literal>void refreshAll(Collection)</literal></entry>

                <entry>As above for all the instances in the Collection.</entry>
              </row>

              <row>
                <entry><literal>void refreshAll(Object[])</literal></entry>

                <entry>As above for all the instances in the array.</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Refreshing a dirty instance will discard any changes made to the
        instance.</para>

        <para>Normally when refreshAll(Collection) is called Versant Open
        Access must refresh each instance using a point query. However if the
        Collection parameter was obtained by executing a JDOQL query then
        Versant Open Access will refresh all of the instances using the SQL
        generated for the query (see <xref linkend="refresh_by_query" />).
        Note that the query is not executed twice as Versant Open Access
        defers query execution until the results are required. This is a very
        important optimization for applications using remote PMs or when the
        level 2 cache is disabled.</para>
      </section>

      <section id="evicting_instances">
        <title>Evicting Instances<indexterm><primary>evicting instances</primary></indexterm></title>

        <para>Evicting an instance outside of a transaction changes its state
        to hollow. Evicting an instance inside a transaction (datastore or
        optimistic) flags it for eviction after commit i.e. it will change to
        hollow after commit. Note that if retainValues is false (see <xref
        linkend="cache_retain_values" />) then all instances touched in a
        datastore transaction are automatically evicted on commit. In an
        optimistic transaction with retainValues false only instances modified
        in the transaction are evicted.</para>

        <para>Eviction is useful if you want to ensure that if an instance is
        touched again its state will be reloaded. This is more efficient than
        calling refresh if the instance is never used again as the extra fetch
        is avoided.</para>

        <para>IF you are using STRONG references to instances in the local PM
        cache (see <xref linkend="cache_ref_type" />) then you must manually
        evict instances no longer required by your application or they will
        not be garbage collected. Manually evicting an instance will change
        its reference type to WEAK and if there are no other references to it
        will be collected next time the garbage collector runs. Another way to
        control memory usage when using STRONG references is to close the PM
        and get a new one from the pool. This works very well for web
        applications that use one PM per request and have short transactions.</para>

        <para>If you are using the default SOFT or WEAK references in the
        local PM cache then you do not need to manually evict instances to
        manage memory. With SOFT references objects referenced only by the
        local cache will be automatically garbage collected when the VM is low
        on memory. Evicting an instance will change its reference type to WEAK
        and if there are no other references to it will be collected next time
        the garbage collector runs. So manual eviction can be used to fine
        tune the caching provided by the local PM cache when using SOFT
        references.</para>
      </section>

      <section id="field_access_interception">
        <title>Field Access Interception<indexterm><primary>field access
        interception</primary></indexterm></title>

        <para>Versant Open Access supports two different strategies for
        ensuring that instances touched in a datastore transaction become
        transactional (i.e. persistent clean) controlled by the
        <command>Intercept access to loaded fields</command> flag. You can
        change the value of this flag in the Workbench (<command>File |
        Project Properties | Project</command>) as shown in the following
        table:</para>

        <informaltable>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Intercept access to loaded fields</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>false</literal></entry>

                <entry>Intercept access to loaded fields only in datastore
                transactions. When a datastore transaction is started all
                persistent-non-transactional instances in the local cache are
                flagged so the access to their loaded fields inside the
                transaction will be intercepted and they will become
                persistent-clean.</entry>
              </row>

              <row>
                <entry><literal>true</literal></entry>

                <entry>Always intercept access to loaded fields. This avoids
                the need flag all persistent-non-transactional instances when
                starting a datastore transaction but imposes more overhead on
                non-transactional and optimistic field access.</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Note that access to non-default-fetch-group fields is always
        intercepted. This flag only applies to default-fetch-group field
        access.</para>

        <para>Most applications should leave this on <literal>default</literal>.
        Applications that mix datastore and optimisitic transactions on the
        same PM and that have a lot of instances in the local cache may get
        better performance by changing it to true. The flag can be changed for
        an individual PM at any time as shown in the following code fragment:</para>

        <programlisting>((VersantPersistenceManager)pm).setInterceptAccessToLoadedFields(true); // or false</programlisting>

        <para>Note that access to the default fetch group fields of
        persistent-non-transactional instances is possible after the PM has
        been closed if this flag is false. This is slightly out of spec as
        such access should result in a JDOUserException.</para>

        <para>If this flag is true then any field access after closing the PM
        will result in a JDOUserException as per spec.</para>
      </section>
    </section>

    <section id="level2_cache">
      <title>Level 2 Cache<indexterm><primary>level 2 cache</primary></indexterm><indexterm><primary>PMF
      wide cache</primary></indexterm><indexterm><primary>shared cache</primary></indexterm></title>

      <para>All PersistenceManagers from the same PersistenceManagerFactory
      share a secondary cache. This is called a level 2 cache to distinguish
      it from the local per PM cache defined in the JDO spec. The level 2
      cache is used to avoid database access for non-transactional reads and
      reads in optimistic transactions. It is bypassed for datastore
      transactions to ensure that database locks are obtained. Data for
      individual instances and the results of JDOQL queries (see <xref
      linkend="query_result_caching" />) are cached. Only data read in an
      optimistic transaction or outside of a transaction is stored.</para>

      <para>Caching can be controlled on a per class basis with the default
      for each class set on the datastore. The options for each class are no,
      yes and all. Classes set to &#34;no&#34; are not cached. This extends to
      not caching query results involving those classes in some way. Classes
      set to &#34;all&#34; have all of their instances read the first time an
      instance is required. This is useful if you know that most of the
      instances will be required as it avoids individual queries to fetch
      them. This is an alternative to prefetching instances using outer joins
      (something we also support).</para>

      <para>Versant Open Access will automatically evict modified instances
      and query results as needed. If other applications are modifying the
      database you can either disable caching for classes mapped to the tables
      being modified or manually evict when you know the data has changed.
      When the cache is full (has reached the maximum configured number of
      instances) the least recently used instance(s) are evicted.</para>

      <para>JDOQL query results are cached by storing the OIDs of all the
      instances returned by the query. If the same query is executed with the
      same parameters and options (see <xref linkend="query_result_caching" />)
      we avoid running a database query by accessing the cache. Cached query
      results are automatically evicted when any instance of any class
      involved in the query (filter, ordering etc.) is modified. If you are
      using SQL in your queries you may need to add extra eviction trigger
      classes to the query (see <xref linkend="inline_sql" />).</para>

      <para>All of this caching is transparent to the application using
      Versant Open Access. All evictions are done automatically. There are
      methods on VersantPersistenceManagerFactory to manually evict OIDs and
      classes from the level 2 cache. These are useful if your data is changed
      infrequently by an external system and you know when this happens. You
      can also use this after doing bulk SQL updates.</para>

      <para>The management console in the Workbench (Run|Management Console)
      can connect to a remote Versant Open Access server. This can be used to
      monitor the cache, change the size and to manually clear it.</para>

      <section id="eviction_level2_cache">
        <title>Manual Eviction<indexterm><primary>eviction from level 2 cache</primary></indexterm></title>

        <para>Versant Open Access will automatically evict modified instances
        and query results as changes are made. If other applications are
        modifying the database you can either disable caching for classes
        mapped to the tables being modified (see class properties form in the
        Workbench) or manually evict when you know the data has changed. The
        eviction methods on VersantPersistenceManagerFactory are as follows:</para>

        <informaltable>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Method</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>void evict(Object oid)</literal></entry>

                <entry>Evict data for the oid from the level 2 cache.</entry>
              </row>

              <row>
                <entry><literal>void evictAll(Collection oids)</literal></entry>

                <entry>Evict data for all of the oids in the Collection.</entry>
              </row>

              <row>
                <entry><literal>void evictAll(Object[] oids)</literal></entry>

                <entry>Evict data for all of the oids in the array.</entry>
              </row>

              <row>
                <entry><literal>void evictAll(Class cls, boolean subclasses)</literal></entry>

                <entry>Evict all data for cls and optionally its subclasses.
                This will also evict any associated query results.</entry>
              </row>

              <row>
                <entry><literal>void evictAll()</literal></entry>

                <entry>Evict all instance and query data from the level 2
                cache.</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </section>

      <section id="clustering">
        <title>Clustering<indexterm><primary>clustering</primary></indexterm></title>

        <para>In a clustered environment Versant Open Access generates
        messages with information on evictions that must be reliably sent to
        the other nodes in the cluster. This communication work is done by a
        pluggable transport class. We provide plugins for Tangosol Coherence
        and JGroups (formerly JavaGroups) and you can write your own. Only
        evictions are sent - never the actual data. Each node will re-read the
        data from the database next time it needs it.</para>

        <para>Enable clustering by selecting a cluster transport in the
        Workbench as shown below. The Workbench will introspect the cluster
        transport for JavaBean style properties and use these to provide for
        configuration.</para>

        <para><inlinemediaobject><imageobject><imagedata
        fileref="images/cluster_setup.png" /></imageobject></inlinemediaobject></para>

        <para>Tangosol Coherence is a comprehensive high performance
        clustering solution from Tangosol (<ulink
        url="http://www.tangosol.com">www.tangosol.com</ulink>).</para>

        <para>JGroups is a free open source toolkit for reliable multicast
        communication (<ulink url="http://www.jgroups.org">www.jgroups.org</ulink>).</para>
      </section>
    </section>
  </chapter>

  <chapter id="attach_detach">
    <title>Attach / Detach<indexterm><primary>attach detach</primary></indexterm><indexterm><primary>detach
    attach</primary></indexterm></title>

    <para>Versant Open Access supports a preview release of JDO 2 attach /
    detach functionality. You can detach a graph of JDO managed instances from
    a PersistenceManager(PM), serialize the graph somewhere (e.g. another
    tier), make changes to it, serialize it back again and then attach it to a
    (possibly) different PM and commit the changes to the datastore. The
    examples in this chapter come from the demo in <filename>demos/attachdetach</filename>.
    The model for this demo is shown below:</para>

    <para><inlinemediaobject><imageobject><imagedata
    fileref="images/aggregates_model.png" /></imageobject></inlinemediaobject></para>

    <para>The attach and detach methods are prefixed with jdoGenie to avoid
    possible conflicts with the final release of the JDO 2 specification. We
    will be able to implement support for the specification without breaking
    applications using our preview functionality.</para>

    <section id="detach">
      <title>Detaching a Graph</title>

      <para>Call <literal>VersantPersistenceManager.jdoGenieDetachCopy</literal>
      to detach a graph of instances as shown below:</para>

      <programlisting>VersantPersistenceManager pm = ...
Query q = pm.newQuery(Contact.class, &#34;name == p&#34;);
q.declareParameters(&#34;String p&#34;);
Collection ans = (Collection)q.execute(&#34;david&#34;);
Collection detached = pm.jdoGenieDetachCopy(ans, &#34;demo&#34;);
q.closeAll();</programlisting>

      <para>The Collection to be detached does not have to come from a query
      as in this example. The elements in the detached collection are in the
      same order as those in the input collection. Only fields in the
      specified fetch group are included in the detached instances. If the
      fetch group is null then the default fetch group is used. The
      &#39;demo&#39; fetch group includes all fields of Contact but only city
      from Address as shown in the meta data below:</para>

      <programlisting>&#60;jdo&#62;
    &#60;package name=&#34;attachdetach.model&#34;&#62;
        &#60;class name=&#34;Address&#34;&#62;
            &#60;extension vendor-name=&#34;versant&#34; key=&#34;fetch-group&#34; value=&#34;demo&#34;&#62;
                &#60;extension vendor-name=&#34;versant&#34; key=&#34;field-name&#34; value=&#34;city&#34; /&#62;
            &#60;/extension&#62;
        &#60;/class&#62;
        &#60;class name=&#34;Contact&#34;&#62;
            &#60;extension vendor-name=&#34;versant&#34; key=&#34;fetch-group&#34; value=&#34;demo&#34;&#62;
                &#60;extension vendor-name=&#34;versant&#34; key=&#34;field-name&#34; value=&#34;address&#34;&#62;
                    &#60;extension vendor-name=&#34;versant&#34; key=&#34;next-fetch-group&#34; value=&#34;demo&#34; /&#62;
                &#60;/extension&#62;
                &#60;extension vendor-name=&#34;versant&#34; key=&#34;field-name&#34; value=&#34;age&#34; /&#62;
                &#60;extension vendor-name=&#34;versant&#34; key=&#34;field-name&#34; value=&#34;email&#34; /&#62;
                &#60;extension vendor-name=&#34;versant&#34; key=&#34;field-name&#34; value=&#34;name&#34; /&#62;
                &#60;extension vendor-name=&#34;versant&#34; key=&#34;field-name&#34; value=&#34;phone&#34; /&#62;
            &#60;/extension&#62;
        &#60;/class&#62;
        &#60;class name=&#34;Country&#34; /&#62;
    &#60;/package&#62;
&#60;/jdo&#62;</programlisting>

      <para>All of the objects in the graph share a common
      <classname>StateManager</classname> instance that prevents navigation
      off the edge of the detached graph. So in this example navigating the
      <literal>country</literal> field on <classname>Address</classname> will
      trigger a <classname>JDOUserException</classname>.</para>

      <programlisting>Contact david = (Contact)detached.iterator().next();
try {
    System.out.println(&#34;david.getAddress().getCountry() = &#34; +
            david.getAddress().getCountry());
} catch (JDOUserException e) {
    System.out.println(e);
}</programlisting>
    </section>

    <section id="deleting_detached">
      <title>Deleting Detached Instances<indexterm><primary>deleting detached
      instances</primary></indexterm></title>

      <para>The common StateManager instance shared by all of the detached
      instances keeps track of which instances have been detached from the
      graph. Use <literal>VersantHelper.deletePersistent</literal> to delete a
      detached instance as shown below:</para>

      <programlisting>VersantHelper.deletePersistent(pc);</programlisting>

      <para>If the instance has been detached then it will be added to the
      deleted list on the common StateManager shared by the other instances
      detached in the same graph. Note that it will only be deleted from the
      datastore if the graph is reattached inside a transaction that is
      committed.</para>

      <para>If it is a normal managed instance then it is deleted normally.</para>
    </section>

    <section id="attach">
      <title>Attaching a Graph</title>

      <para>Call <literal>VersantPersistenceManager.jdoGenieAttachCopy</literal>
      to attach previously detached instances. Any changes made to the
      instances will be applied to instances in a local PM cache and committed
      if the transaction commits. Optimistic locking version numbers are
      checked and a <classname>JDOOptimisticVerificationException</classname>
      is thrown for conflicts.</para>

      <programlisting>// change the first Contact
  Contact con = (Contact)toAttach.iterator().next();
  con.setPhone(&#34;555-9999&#34;);

  // start a tx and attach the graph - the phone number change
  // will be persisted
  pm.currentTransaction().begin();
  pm.jdoGenieAttachCopy(toAttach, true);
  pm.currentTransaction().commit();</programlisting>
    </section>
  </chapter>

  <chapter id="remote_access">
    <title>Remote Access / PMs)<indexterm><primary>remote PersistenceManagers</primary></indexterm><indexterm><primary>remote
    acccess</primary></indexterm></title>

    <para>Any Versant Open Access PMF can be configured to act as a server for
    clients running in different VMs. The client application creates a
    PersistenceManagerFactory(PMF) and PersistenceManager&#39;s(PM&#39;s) in
    exactly the same way as server side code and all the communication is
    hidden by the Versant Open Access implementation. The clients communicates
    with the server using normal TCP sockets, HTTP or using a user written
    transport. All clients share a common level 2 cache and other resources.
    This is a much more scalable architecture than having each client connect
    to the database directly.</para>

    <para>Most applications will use either the TCP transport or the HTTP
    transport but it is possible to use both at the same time (e.g. external
    clients on the internet use HTTP and internal intranet clients use TCP).
    The TCP transport should be faster as it does not have any HTTP overhead.</para>

    <para>Remote clients can also use methods on
    VersantPersistenceManagerFactory to download performance metrics, events
    and other information from the server. The remote management console in
    the Workbench uses these methods.</para>

    <para>Remote clients must set the <literal>versant.host</literal> property
    to the URL of the remote PMF server (e.g. <literal>socket://127.0.0.1</literal>
    or <literal>http://127.0.0.1:8080/pmf</literal>) prior to obtaining the
    PMF. If no protocol is specified then <literal>socket://</literal> is
    assumed. Here is an example connecting to a PMF server on
    <literal>warthog</literal> using the default port:</para>

    <programlisting>Properties props = new Properties();
props.load(getClassLoader().getResourceAsStream(&#34;versant.properties&#34;));
props.setProperty(&#34;versant.host&#34;, &#34;warthog&#34;);
pmf = JDOHelper.getPersistenceManagerFactory(props);</programlisting>

    <para>It is recommended that remote clients only use optimistic locking
    and avoid flushing (see <xref linkend="flushing" />). Network failures may
    leave pessimistic transactions open and holding database locks until they
    time out. Set optimistic locking using the project properties dialog in
    the Versant Open Access Workbench. See <xref linkend="transactions" /> for
    more information.</para>

    <section id="tcp_pmf_server">
      <title>Standalone TCP PMF Server<indexterm><primary>standalone TCP PMF
      server</primary></indexterm><indexterm><primary>TCP PMF server</primary></indexterm><indexterm><primary>sockets
      PMF server</primary></indexterm></title>

      <para>The TCP PMF server is started automatically when the first PMF is
      created if the <literal>versant.remoteAccess</literal> property is
      <literal>socket</literal> or <literal>true</literal> or not set. To
      disable it set <literal>versant.remoteAccess</literal> to
      <literal>false</literal>. Here is an example:</para>

      <programlisting>Properties props = new Properties();
props.load(getClassLoader().getResourceAsStream(&#34;versant.properties&#34;));
props.setProperty(&#34;versant.remoteAccess&#34;, &#34;socket&#34;);
props.setProperty(&#34;versant.remote.tcp.port&#34;, &#34;12345&#34;);
pmf = JDOHelper.getPersistenceManagerFactory(props);
// TCP server will have started on port 12345</programlisting>

      <para>The tut1 demo (in <filename>demos/tut1</filename>) includes Ant
      targets to start a TCP PMF server and to run remotely.</para>

      <para>Use the following properties to configure the server:</para>

      <informaltable>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>versant.remote.tcp.</entry>

              <entry>Default</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>port</entry>

              <entry>8295</entry>

              <entry>Port to listen on.</entry>
            </row>

            <row>
              <entry>backlog</entry>

              <entry>(ServerSocket default)</entry>

              <entry>ServerSocket listen backlog.</entry>
            </row>

            <row>
              <entry>bindAddress</entry>

              <entry>(ServerSocket default)</entry>

              <entry>Address to bind on.</entry>
            </row>

            <row>
              <entry>compressionLevel</entry>

              <entry>0</entry>

              <entry>Compression level (0=none, 1=fast to 9=best).</entry>
            </row>

            <row>
              <entry>maxActiveThreads</entry>

              <entry>200</entry>

              <entry>Max threads to create for requests.</entry>
            </row>

            <row>
              <entry>maxIdleThreads</entry>

              <entry>5</entry>

              <entry>Max threads keep idle.</entry>
            </row>

            <row>
              <entry>busyTimeoutMs</entry>

              <entry>1000</entry>

              <entry>How long to wait for a thread before dropping request.</entry>
            </row>

            <row>
              <entry>username</entry>

              <entry></entry>

              <entry>Username clients must supply.</entry>
            </row>

            <row>
              <entry>password</entry>

              <entry></entry>

              <entry>Password clients must supply.</entry>
            </row>

            <row>
              <entry>remotePMs</entry>

              <entry>true</entry>

              <entry>Allow remote PMs.</entry>
            </row>

            <row>
              <entry>oneRequestPerConnection</entry>

              <entry>false</entry>

              <entry>Process only one request on each connection.</entry>
            </row>

            <row>
              <entry>outputBufferSize</entry>

              <entry>2048</entry>

              <entry>Size of stream output buffer in bytes.</entry>
            </row>

            <row>
              <entry>inputBufferSize</entry>

              <entry>2048</entry>

              <entry>Size of stream input buffer in bytes.</entry>
            </row>

            <row>
              <entry>readTimeoutMs</entry>

              <entry>60000</entry>

              <entry>Timeout that the server uses when reading data from the
              socket connected to the remote client.</entry>
            </row>

            <row>
              <entry>clientTimeoutSecs</entry>

              <entry>240</entry>

              <entry>Kill clients inactive for this many seconds. Idle clients
              will ping the server at half this interval to keep their
              connection alive. Each remote client uses resources on the
              server so we need to be able to cleanup after network failures
              and client crashes. Minimum is 10 seconds.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>Note that versant.remote.tcp.compressionLevel must be the same on
      the client and server.</para>
    </section>

    <section id="http_pmf_server">
      <title>HTTP PMF Server<indexterm><primary>servlet PMF server</primary></indexterm><indexterm><primary>http
      PMF server</primary></indexterm></title>

      <para>The HTTP PMF server is a servlet that is deployed as part of a web
      application. If your remote clients need to communicate with the server
      through proxies and firewalls then use HTTP. For other applications the
      TCP PMF Server is likely to be faster and is easier to deploy as no web
      application is involved.</para>

      <para>To deploy the HTTP PMF Server add entries to your applications
      <filename>web.xml</filename>:</para>

      <programlisting>&#60;servlet&#62;
    &#60;servlet-name&#62;PMFServerServlet&#60;/servlet-name&#62;
    &#60;servlet-class&#62;com.versant.core.jdo.remote.http.PMFServerServlet&#60;/servlet-class&#62;
    &#60;!-- Use init-param&#39;s to override properties from versant.properties.  --&#62;
    &#60;init-param&#62;
        &#60;param-name&#62;javax.jdo.option.ConnectionURL&#60;/param-name&#62;
        &#60;param-value&#62;jdbc:hsqldb:hsql://localhost/testcenter&#60;/param-value&#62;
    &#60;/init-param&#62;
    &#60;init-param&#62;
        &#60;param-name&#62;versant.remote.http.clientTimeoutSecs&#60;/param-name&#62;
        &#60;param-value&#62;600&#60;/param-value&#62;
    &#60;/init-param&#62;
    &#60;load-on-startup&#62;1&#60;/load-on-startup&#62;
&#60;/servlet&#62;

&#60;servlet-mapping&#62;
    &#60;servlet-name&#62;PMFServerServlet&#60;/servlet-name&#62;
    &#60;url-pattern&#62;/pmf&#60;/url-pattern&#62;
&#60;/servlet-mapping&#62;</programlisting>

      <para>If the web application was deployed under the URL
      <literal>/myapp</literal> on warthog listening on port
      <literal>8080</literal> then remote clients would need to set
      <literal>versant.host</literal> to <literal>http://warthog:8080/myapp/pmf</literal>
      to connect. Connecting to that URL using a browser (GET request) will
      return a simple web page listing all of the properties used to create
      the local PMF.</para>

      <para>The testcenter demo (in <literal>demos/testcenter</literal>) is a
      struts based web application with an additional standalone Swing GUI
      client. The GUI client connects to the PMFServerServlet deployed as part
      of the web app.</para>

      <para>The properties used to create the PMF and configure the servlet
      are loaded from the resource <literal>versant.properties</literal> (i.e.
      from <literal>WEB-INF/classes/versant.properties</literal> or a jar in
      <literal>WEB-INF/lib</literal>). You can change the name of this
      resource using the <literal>properties-resource</literal> servlet
      initialization parameter.</para>

      <para>Use the following properties to configure the PMFServerServlet:</para>

      <informaltable>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>versant.remote.http.</entry>

              <entry>Default</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>pmfAttribute</entry>

              <entry>pmf</entry>

              <entry>ServletContext attribute to get/set to the local PMF. If
              this attribute contains a PMF then this is used. If it does not
              contain a PMF then one is created and set on this attribute.</entry>
            </row>

            <row>
              <entry>compressionLevel</entry>

              <entry>9</entry>

              <entry>Compression level (0=none, 1=fast to 9=best).</entry>
            </row>

            <row>
              <entry>username</entry>

              <entry></entry>

              <entry>Username clients must supply.</entry>
            </row>

            <row>
              <entry>password</entry>

              <entry></entry>

              <entry>Password clients must supply.</entry>
            </row>

            <row>
              <entry>remotePMs</entry>

              <entry>true</entry>

              <entry>Allow remote PMs.</entry>
            </row>

            <row>
              <entry>outputBufferSize</entry>

              <entry>8192</entry>

              <entry>Size of stream output buffer in bytes.</entry>
            </row>

            <row>
              <entry>clientTimeoutSecs</entry>

              <entry>240</entry>

              <entry>Kill clients inactive for this many seconds. Idle clients
              will ping the server at half this interval to keep their
              connection alive. Each remote client uses resources on the
              server so we need to be able to cleanup after network failures
              and client crashes. Minimum is 10 seconds.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>Any property can be overridden using a servlet initialization
      parameter with the same name. Note that
      versant.remote.http.compressionLevel must be the same on the client and
      server.</para>

      <para>You can change the way the local PMF is discovered and/or created
      by extending <classname>com.versant.core.jdo.remote.http.PMFServerServlet</classname>
      and overriding the <methodname>findOrCreatePMF</methodname> and/or
      <methodname>createPMF</methodname> methods.</para>
    </section>

    <section id="remote_client_props">
      <title>Client Properties<indexterm><primary>remote client properties</primary></indexterm></title>

      <para>Use the following properties to configure the remote PMF on the
      client. Note that only <literal>versant.host</literal> is required.</para>

      <informaltable>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>Property</entry>

              <entry>Default</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>versant.host</entry>

              <entry></entry>

              <entry>URL of remote PMF server. If no protocol is specified
              then <literal>socket://</literal> is assumed.</entry>
            </row>

            <row>
              <entry>versant.remoteUsername</entry>

              <entry></entry>

              <entry>Username to supply to server.</entry>
            </row>

            <row>
              <entry>versant.remotePassword</entry>

              <entry></entry>

              <entry>Password to supply to server.</entry>
            </row>

            <row>
              <entry>versant.remoteMaxActive</entry>

              <entry>10</entry>

              <entry>Maximum number of connections to establish with the
              server.</entry>
            </row>

            <row>
              <entry>versant.remoteMaxIdle</entry>

              <entry>2</entry>

              <entry>Maximum number of idle connections to keep open.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>The pool of connections to the remote PMF server is shared by all
      PersistenceManager&#39;s created from the remote PMF. These connections
      are never associated with (or pinned to) a single PM so only
      applications that perform operations on several PMs simultaneously are
      likely to use more than one or two connections. Note than when using the
      HTTP PMF Server the real connection pooling is done by
      <classname>java.net.HttpUrlConnection</classname> and other related
      classes.</para>
    </section>

    <section id="remote_user_object">
      <title>Remote UserObject Support<indexterm><primary>remote UserObject
      support</primary></indexterm></title>

      <para>JDO provides for associating an object with a PersistenceManager
      using the UserObject property. For remote PMs this user object must be
      Serializable. The toString of the object for each PM is displayed on the
      Persistence Managers tab of the Workbench Management console. For remote
      PMs you can use this to provide simple user identification (e.g. who is
      using the PM) or even a stub to a remote object on the client.</para>

      <para>Versant Open Access adds two similar properties (UserObject and
      ServerUserObject) to VersantPersistenceManagerFactory. For local PMFs
      these access the same object while each remote PMF has its own
      UserObject. The Workbench Management console will display the toString
      of this object next to each remote PMF on the Remote Clients tab. You
      can use this to identify remote users or to provide access to a client
      side remote object so the server can make calls to the client. How the
      server calls the client is beyond the scope of this manual. In a local
      intranet sittuation you could just use RMI but this would not work on
      the internet.</para>

      <para>The ServerUserObject property provides access to the UserObject of
      the Versant Open Access server to remote PMFs. The server can use this
      to easily provide access to a remote object offering extended services
      to clients. There is no need to register the object in an RMI registry
      or other naming service if you are using this facility.</para>

      <para>All of the information on remote clients displayed by the
      Workbench Management console is available via methods on
      VersantPersistenceManagerFactory. This feature combined with the
      extended UserObject support makes it very easy to display a list of
      clients in your application and to communicate with them using RMI or
      other protocol.</para>
    </section>

    <section id="hyperdrive_and_remote">
      <title>Hyperdrive Classes<indexterm><primary>hyperdrive classes, remote</primary></indexterm><indexterm><primary>remote
      hyperdrive classes</primary></indexterm></title>

      <para>Versant Open Access generates a significant portion of the
      implementation at runtime to match the persistent classes - these
      generated classes are named <filename>HYPERDRIVE_*</filename>. The
      performance gain from this technology is very significant. When remote
      PMs are used these classes are automatically downloaded to the client.
      Startup time for remote clients can be improved by generating the
      hyperdrive classes at enhancement time and packaging them with your
      application (both client and server components).</para>

      <para>To generate the hyperdrive classes at enhancement time add the
      hyperdriveDir attribute to your <literal>jdo-enhance</literal> task (see
      <xref linkend="task_jdo_enhance" />) call:</para>

      <programlisting>&#60;jdo-enhance ... genhyper=&#34;true&#34; ...&#62;</programlisting>

      <para>You need to make sure that your build file deletes and regenerates
      these classes if any of your <filename>.jdo</filename> meta data files
      or <filename>.properties</filename> project file change. Note that this
      includes simple changes like selecting a different database type
      (oracle, mysql, sybase etc.). This also means that your deployed
      application will only be able to work with the database it was compiled
      for.</para>

      <para>You can also disable hyperdrive classes (<literal>versant.hyperdrive=false</literal>)
      in the .properties file or using <command>File | Project Properties</command>
      in the Workbench.</para>
    </section>
  </chapter>

  <chapter id="performance_monitoring">
    <title>Performance Monitoring and Logging<indexterm><primary>logging</primary></indexterm><indexterm><primary>performance
    monitoring</primary></indexterm><indexterm><primary>monitoring for
    performance</primary></indexterm><indexterm><primary>event logging</primary></indexterm></title>

    <para>Versant Open Access has strong event logging, performance monitoring
    and tuning features. Events can be generated for nearly all operations
    executed by the server depending on the configured event logging level.
    The server maintains more than 50 different performance metrics (counters)
    monitoring everything from the level 2 cache hit rate to the number of
    connections in the connection pool. Events and regular snapshots of all
    the metrics are stored in ring buffers.</para>

    <para>The server uses a background thread to dump events and snapshots to
    files (jdogenie.jdolog and jdogenie.jdoperf by default) for offline
    analysis. The Workbench Management Console can capture and display events
    and performance metric snapshots in real time from a remote Versant Open
    Access server. It can also open files of previously captured events and
    metric snapshots for analysis.</para>

    <para>You can configure your own performance metrics using the Workbench.
    You can get/set/increment their values and also log your own events by
    calling methods on <classname>VersantPersistenceManager</classname> and
    <classname>VersantPersistenceManagerFactory</classname>.</para>

    <para>The methods used to download events and metric snapshots are
    available through <classname>VersantPersistenceManagerFactory</classname>
    so you can write your own logging applications if necessary. A general
    purpose JavaBean (<classname>com.versant.core.jdo.LogDownloader</classname>)
    is supplied (with source) that you can embed in your own applications or
    cut and paste. An Ant task using this bean (<classname>jdo-log-download</classname>,
    see <xref linkend="task_jdo_log_download" />) is also available. The bean
    also has a command line interface.</para>

    <section id="configuring_logging">
      <title>Configuring Logging<indexterm><primary>configuring logging</primary></indexterm><indexterm><primary>logging</primary></indexterm></title>

      <para>You can configure logging and performance metric snapshots using
      the Event Logging tab of the Project Properties dialog (<command>File |
      Project Properties</command>) in the Workbench. The dialog is as
      follows:</para>

      <figure>
        <title>Configuring Event Logging</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/configure_event_logging.png" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The top grid controls which events are logged and how many events
      can fit in the event ring buffer.</para>

      <informaltable>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>Property</entry>

              <entry>Description</entry>

              <entry>Default</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>Events to log</entry>

              <entry>Control which events are logged. Note that selecting
              <literal>verbose</literal> or <literal>all</literal> will have a
              serious negative impact on performance.</entry>

              <entry><literal>normal</literal></entry>
            </row>

            <row>
              <entry>Write events to System.out</entry>

              <entry>Write events to System.out as they are logged. This has a
              large negative impact on performance but is useful as this
              output will be interleaved with other debugging output.</entry>

              <entry>true</entry>
            </row>

            <row>
              <entry>Max events</entry>

              <entry>Set the capacity of the ring buffer that holds the
              events. You may need to increase this if your server is very
              busy to avoid losing events. When it is full the oldest event is
              discarded.</entry>

              <entry>1000</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>The event logging levels for the <command>events to log</command>
      property are as follows:</para>

      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Logging Level</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>none</entry>

              <entry>Log no events. Only use this when doing benchmarking.</entry>
            </row>

            <row>
              <entry>errors</entry>

              <entry>Only log serious errors (connections timing out and so
              on).</entry>
            </row>

            <row>
              <entry>normal</entry>

              <entry>Log the most useful events that do not reduce performance
              much (e.g. SQL executed).</entry>
            </row>

            <row>
              <entry>verbose</entry>

              <entry>Log lots of events (SLOW - for debugging).</entry>
            </row>

            <row>
              <entry>all</entry>

              <entry>Log all possible events (VERY SLOW - for debugging).</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>The <command>metric snapshot interval</command> field sets the
      frequency of metric snapshots in milliseconds. All performance metrics
      (counters) are sampled at this rate and the snapshots added to a ring
      buffer. The <command>metric store capacity</command> field defines the
      capacity of this buffer. If it overflows the most recent snapshot is
      discarded. The default settings allow for 1 hour of data captured at 1
      second intervals. This uses approximately 800K of memory.</para>

      <para>The <command>event and metrics downloader</command> field sets the
      name of the class responsible for polling for new events and metric
      snapshots and storing this information in files on disk. The default is
      <classname>com.versant.core.jdo.LogDownloader</classname>. The bottom
      grid set properties for the configured downloader. The properties for
      the default are listed here:</para>

      <informaltable>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>Property</entry>

              <entry>Description</entry>

              <entry>Default</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>Filename</entry>

              <entry>Filename without extension to write events and snapshots
              to.</entry>

              <entry><filename>jdogenie_&#60;server name&#62;</filename></entry>
            </row>

            <row>
              <entry>Write event binary file</entry>

              <entry>Write events to binary file (<filename>&#60;filename&#62;.jdolog</filename>).</entry>

              <entry>true</entry>
            </row>

            <row>
              <entry>Write event text file</entry>

              <entry>Write events to text file (<filename>&#60;filename&#62;.txt</filename>).
              Note that the binary file contains very much more information.</entry>

              <entry>false</entry>
            </row>

            <row>
              <entry>Write metric binary file</entry>

              <entry>Write performance metric snapshots to binary file (<filename>&#60;filename&#62;.jdoperf</filename>).</entry>

              <entry>true</entry>
            </row>

            <row>
              <entry>Append</entry>

              <entry>Append to existing event log text file (if any). Note
              that the binary files are never appended.</entry>

              <entry>false</entry>
            </row>

            <row>
              <entry>Max file size in K</entry>

              <entry>The maximum size of any of the files written in K. When a
              file exceeds this size it rolls over to a series of numbered
              backups (<filename>&#60;filename&#62;.jdoperf.1</filename>,
              <filename>&#60;filename&#62;.jdoperf.2</filename>, ...). The
              oldest file has the highest backup number.</entry>

              <entry>1000</entry>
            </row>

            <row>
              <entry>Number of backups</entry>

              <entry>The number of backups to maintain for each file.</entry>

              <entry>1</entry>
            </row>

            <row>
              <entry>Event poll seconds</entry>

              <entry>The number of seconds between each poll of the remote
              server for new events. You may want to increase this if you are
              on a slow connection and have configured a big ring buffer on
              the server.</entry>

              <entry>1</entry>
            </row>

            <row>
              <entry>Metric poll seconds</entry>

              <entry>The number of seconds between each poll of the remote
              server for new performance metric snapshots.</entry>

              <entry>60</entry>
            </row>

            <row>
              <entry>Date format</entry>

              <entry>Set the format of dates written to the event text file.
              Use patterns from <classname>java.text.SimpleDateFormat</classname>.</entry>

              <entry><literal>HH:mm:ss.SSS</literal></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>

    <section id="performance_metric_snapshots">
      <title>Performance Metric Snapshots<indexterm><primary>performance
      metric snapshots</primary></indexterm><indexterm><primary>metric
      snapshots</primary></indexterm><indexterm><primary>jdogenie.jdoperf</primary></indexterm></title>

      <para>The performance metrics are based on simple counters and values
      that are set by the Versant Open Access server. At regular intervals a
      snapshot of all of the counters is captured into a buffer. This
      information is displayed by the Workbench Management Console. Right
      clicking on a chart or elsewhere on the layout invokes a popup menu.
      This has options to change the properties of a chart, move and resize
      charts, save and load the layout, save and load performance metric
      snapshots, choose metrics to display, export to CSV file and so on.</para>

      <para><inlinemediaobject><imageobject><imagedata
      fileref="images/management_console.png" /></imageobject></inlinemediaobject></para>

      <para>The available metrics are grouped into related categories and
      described in this section.</para>

      <section id="metrics_general">
        <title>General Metrics<indexterm><primary>general metrics</primary></indexterm></title>

        <para><command>Mem Free KB</command> and <command>Mem Total KB</command>
        are the most important metrics to monitor in this category. If the
        level 2 cache is too large you may eventually run out of memory.</para>

        <informaltable>
          <tgroup cols="3">
            <thead>
              <row>
                <entry>Category</entry>

                <entry>Metric</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>General</entry>

                <entry>Events</entry>

                <entry>Number of events logged.</entry>
              </row>

              <row>
                <entry>General</entry>

                <entry>Hits</entry>

                <entry>Server requests received.</entry>
              </row>

              <row>
                <entry>General</entry>

                <entry>Last Event ID</entry>

                <entry>Approximate ID of the last event logged.</entry>
              </row>

              <row>
                <entry>General</entry>

                <entry>Mem Free KB</entry>

                <entry>Available heap memory in KB.</entry>
              </row>

              <row>
                <entry>General</entry>

                <entry>Mem Total KB</entry>

                <entry>Total heap memory in KB.</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </section>

      <section id="metrics_con_pool">
        <title>Connection Pool Metrics<indexterm><primary>connection pool
        metrics</primary></indexterm></title>

        <para>The connection pool should be sized so that it is rarely full
        (watch <command>Pool % Full</command>). It is also important that
        there are enough idle connections to handle periods of increasing
        load. Watch <command>Pool Wait</command> and increase the minimum
        number of idle connections if necessary (see <xref
        linkend="pool_min_idle" />).</para>

        <informaltable>
          <tgroup cols="3">
            <thead>
              <row>
                <entry>Category</entry>

                <entry>Metric</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>Con Pool</entry>

                <entry>Con Allocate</entry>

                <entry>Number of connections given out by the pool.</entry>
              </row>

              <row>
                <entry>Con Pool</entry>

                <entry>Con Bad</entry>

                <entry>Number of connections that failed validation test.</entry>
              </row>

              <row>
                <entry>Con Pool</entry>

                <entry>Con Closed</entry>

                <entry>Number of connections closed.</entry>
              </row>

              <row>
                <entry>Con Pool</entry>

                <entry>Con Created</entry>

                <entry>Number of connections created.</entry>
              </row>

              <row>
                <entry>Con Pool</entry>

                <entry>Con Timed Out</entry>

                <entry>Number of active connections timed out and closed.</entry>
              </row>

              <row>
                <entry>Con Pool</entry>

                <entry>Con Expired</entry>

                <entry>Number of connections closed due to their age reaching
                the maximum connection lifespan.</entry>
              </row>

              <row>
                <entry>Con Pool</entry>

                <entry>Con Validated</entry>

                <entry>Number of connections validated.</entry>
              </row>

              <row>
                <entry>Con Pool</entry>

                <entry>Pool Active</entry>

                <entry>Number of active connections in pool.</entry>
              </row>

              <row>
                <entry>Con Pool</entry>

                <entry>Pool Full</entry>

                <entry>Number of times the pool was full and a connection was
                needed.</entry>
              </row>

              <row>
                <entry>Con Pool</entry>

                <entry>Pool Idle</entry>

                <entry>Number of idle connections in pool.</entry>
              </row>

              <row>
                <entry>Con Pool</entry>

                <entry>Pool Max Active</entry>

                <entry>Max number of connections allowed in pool.</entry>
              </row>

              <row>
                <entry>Con Pool</entry>

                <entry>Pool Wait</entry>

                <entry>Number of times that a caller had to wait for a
                connection.</entry>
              </row>

              <row>
                <entry>Con Pool</entry>

                <entry>Pool % Full</entry>

                <entry>Active connections as a percentage of the maximum.</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </section>

      <section id="metrics_level_2_cache">
        <title>Level 2 Cache Metrics<indexterm><primary>level 2 cache metrics</primary></indexterm><indexterm><primary>cache
        metrics</primary></indexterm><indexterm><primary>PMF wide cache
        metrics</primary></indexterm></title>

        <para>These metrics will tell you how effective the level 2 cache is
        for your application. If <command>Cache Hit %</command> is low then
        you may gain from increasing the maximum size of the cache. Be careful
        not to run out of memory (see <xref linkend="metrics_general" />).</para>

        <informaltable>
          <tgroup cols="3">
            <thead>
              <row>
                <entry>Category</entry>

                <entry>Metric</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>Level 2 Cache</entry>

                <entry>Cache Full %</entry>

                <entry>Number of objects in the cache as a percentage of the
                max.</entry>
              </row>

              <row>
                <entry>Level 2 Cache</entry>

                <entry>Cache Hit</entry>

                <entry>Number of times data was found in cache.</entry>
              </row>

              <row>
                <entry>Level 2 Cache</entry>

                <entry>Cache Hit %</entry>

                <entry>Cache hits as a percentage of hits and misses.</entry>
              </row>

              <row>
                <entry>Level 2 Cache</entry>

                <entry>Cache Max Size</entry>

                <entry>Max number of objects to store in level 2 cache.</entry>
              </row>

              <row>
                <entry>Level 2 Cache</entry>

                <entry>Cache Miss</entry>

                <entry>Number of times data was not found in cache.</entry>
              </row>

              <row>
                <entry>Level 2 Cache</entry>

                <entry>Cache Size</entry>

                <entry>Number of objects in the level 2 cache.</entry>
              </row>

              <row>
                <entry>Level 2 Cache</entry>

                <entry>Query Cache Full %</entry>

                <entry>Number of queries in the cache as a percentage of the
                max.</entry>
              </row>

              <row>
                <entry>Level 2 Cache</entry>

                <entry>Query Cache Hit</entry>

                <entry>Number of times query results were found in cache.</entry>
              </row>

              <row>
                <entry>Level 2 Cache</entry>

                <entry>Query Cache Hit %</entry>

                <entry>Query cache hits as a percentage of hits and misses.</entry>
              </row>

              <row>
                <entry>Level 2 Cache</entry>

                <entry>Query Cache Max Size</entry>

                <entry>Max number of queries to store in cache.</entry>
              </row>

              <row>
                <entry>Level 2 Cache</entry>

                <entry>Query Cache Miss</entry>

                <entry>Number of times query results were not found in cache.</entry>
              </row>

              <row>
                <entry>Level 2 Cache</entry>

                <entry>Query Cache Size</entry>

                <entry>Number of queries in the cache.</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </section>

      <section id="metrics_pm">
        <title>PM Metrics<indexterm><primary>PM metrics</primary></indexterm><indexterm><primary>persistence
        manager metrics</primary></indexterm></title>

        <para>This category provides information on how your application
        manages PersistenceManagers (PMs). Watch out for <command>PM Closed
        Auto</command> and <command>PM Closed Auto Tx</command> as these
        indicate that PMs are not being closed. This can cause database lock
        contention and reduce throughput. The <command>Local PM Allocated</command>
        metric is effectively a request counter for web applications that use
        the &#34;one PM per request&#34; model.</para>

        <informaltable>
          <tgroup cols="3">
            <thead>
              <row>
                <entry>Category</entry>

                <entry>Metric</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>PM</entry>

                <entry>Local PM Active</entry>

                <entry>Number of active PMs in local pool.</entry>
              </row>

              <row>
                <entry>PM</entry>

                <entry>Local PM Allocated</entry>

                <entry>Number of PMs given out by the local pool.</entry>
              </row>

              <row>
                <entry>PM</entry>

                <entry>Local PM Idle</entry>

                <entry>Number of idle PMs in the local pool.</entry>
              </row>

              <row>
                <entry>PM</entry>

                <entry>Local PM Out</entry>

                <entry>Number of PMs not yet returned to the pool (allocated -
                returned)</entry>
              </row>

              <row>
                <entry>PM</entry>

                <entry>Local PM Returned</entry>

                <entry>Number of PMs returned to the local pool.</entry>
              </row>

              <row>
                <entry>PM</entry>

                <entry>Local PM Created</entry>

                <entry>Number of local PMs created.</entry>
              </row>

              <row>
                <entry>PM</entry>

                <entry>PM Closed</entry>

                <entry>Number of PMs closed (local and remote).</entry>
              </row>

              <row>
                <entry>PM</entry>

                <entry>PM Closed Auto</entry>

                <entry>Number of PMs closed automatically (local and remote).</entry>
              </row>

              <row>
                <entry>PM</entry>

                <entry>PM Closed Auto Tx</entry>

                <entry>Number of PMs closed automatically with an active
                datastore transaction (BAD).</entry>
              </row>

              <row>
                <entry>PM</entry>

                <entry>PM Count</entry>

                <entry>Number of open PMs (local and remote).</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </section>

      <section id="metrics_tx">
        <title>Transaction Metrics<indexterm><primary>Tx metrics</primary></indexterm><indexterm><primary>transaction
        metrics</primary></indexterm><indexterm><primary>transactions per
        second</primary></indexterm></title>

        <para>This category provides information on JDO transactions.
        Applications using optimistic transactions should watch
        <command>Tx Flush Auto</command> as this indicates that the
        transaction was downgraded to a datastore transaction which will
        reduce performance (see <xref linkend="flushing" />). This is very
        important when using remote PMs as it is dangerous to maintain
        database locks across network calls to the server.</para>

        <informaltable>
          <tgroup cols="3">
            <thead>
              <row>
                <entry>Category</entry>

                <entry>Metric</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>Transaction</entry>

                <entry>Tx</entry>

                <entry>JDO transactions started.</entry>
              </row>

              <row>
                <entry>Transaction</entry>

                <entry>Tx Commit</entry>

                <entry>JDO transactions committed.</entry>
              </row>

              <row>
                <entry>Transaction</entry>

                <entry>Tx Datastore</entry>

                <entry>JDO datastore transactions started.</entry>
              </row>

              <row>
                <entry>Transaction</entry>

                <entry>Tx Datastore Commit</entry>

                <entry>JDO datastore transactions committed.</entry>
              </row>

              <row>
                <entry>Transaction</entry>

                <entry>Tx Datastore Rollback</entry>

                <entry>JDO datastore transactions rolled back.</entry>
              </row>

              <row>
                <entry>Transaction</entry>

                <entry>Tx Flush</entry>

                <entry>JDO manual flushes prior to transaction commit.</entry>
              </row>

              <row>
                <entry>Transaction</entry>

                <entry>Tx Flush Auto</entry>

                <entry>JDO automatic flushes prior to transaction commit.</entry>
              </row>

              <row>
                <entry>Transaction</entry>

                <entry>Tx Opt</entry>

                <entry>JDO optimistic transactions started.</entry>
              </row>

              <row>
                <entry>Transaction</entry>

                <entry>Tx Opt Commit</entry>

                <entry>JDO optimistic transactions committed.</entry>
              </row>

              <row>
                <entry>Transaction</entry>

                <entry>Tx Opt Rollback</entry>

                <entry>JDO optimistic transactions rolled back.</entry>
              </row>

              <row>
                <entry>Transaction</entry>

                <entry>Tx Rollback</entry>

                <entry>JDO transactions rolled back.</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </section>

      <section id="metrics_remote">
        <title>Remote Metrics<indexterm><primary>remote metrics</primary></indexterm></title>

        <para>This category provides information on remote clients (i.e.
        remote PMFs).</para>

        <informaltable>
          <tgroup cols="3">
            <thead>
              <row>
                <entry>Category</entry>

                <entry>Metric</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>Remote</entry>

                <entry>Remote Bad Auth</entry>

                <entry>Number of remote authentication failures.</entry>
              </row>

              <row>
                <entry>Remote</entry>

                <entry>Remote Bad Version</entry>

                <entry>Number of connections attempted with different version
                of Versant Open Access.</entry>
              </row>

              <row>
                <entry>Remote</entry>

                <entry>Remote Clients</entry>

                <entry>Number of remote clients (i.e. remote PMFs).</entry>
              </row>

              <row>
                <entry>Remote</entry>

                <entry>Remote Connect</entry>

                <entry>Number of remote connects.</entry>
              </row>

              <row>
                <entry>Remote</entry>

                <entry>Remote Disabled</entry>

                <entry>Number of remote connections disallowed.</entry>
              </row>

              <row>
                <entry>Remote</entry>

                <entry>Remote Disconnect</entry>

                <entry>Number of remote disconnections.</entry>
              </row>

              <row>
                <entry>Remote</entry>

                <entry>Remote PM Disabled</entry>

                <entry>Number of remote PM creations disallowed.</entry>
              </row>

              <row>
                <entry>Remote</entry>

                <entry>Remote PM Created</entry>

                <entry>Number of remote PMs created.</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </section>

      <section id="metrics_user">
        <title>User Defined Metrics<indexterm><primary>user defined metrics</primary></indexterm></title>

        <para>You can define your own performance metrics (counters) using the
        Project Properties dialog (<command>File | Project Properties</command>).
        These are included in snapshots with all the standard metrics.</para>

        <para><inlinemediaobject><imageobject><imagedata
        fileref="images/user_defined_metrics.png" /></imageobject></inlinemediaobject></para>

        <para>You can adjust the value of each user defined metric using
        methods on <classname>VersantPersistenceManagerFactory</classname> as
        shown in this example:</para>

        <programlisting>import com.versant.core.jdo.VersantPersistenceManagerFactory;

VersantPersistenceManagerFactory pmf = ...

// increment the metric by 10
pmf.incUserMetric(&#34;MessagesRec&#34;, 10);
// use inc instead of set(get+10) as it is thread safe

// set the metric to 5740
pmf.setUserMetric(&#34;DiskFreeM&#34;, 5740);

// get the current value of the metric
int v = pmf.getUserMetric(&#34;MessagesRec&#34;);</programlisting>

        <para>If you are using remote PMs remember that all of these methods
        involve a remote call to the server.</para>
      </section>
    </section>

    <section id="performance_events">
      <title>Performance Events<indexterm><primary>performance events</primary></indexterm><indexterm><primary>events</primary></indexterm></title>

      <para>Events can be generated for nearly all operations executed by the
      server depending on the configured event logging level. You can also log
      your own events by calling methods on <classname>VersantPersistenceManager</classname>
      and <classname>VersantPersistenceManagerFactory</classname>. Note that
      setting the logging level to &#39;all&#39; or &#39;verbose&#39; will
      seriously reduce performance. The events are instances of Java classes
      extending <classname>com.versant.core.server.perf.PerfEvent</classname>
      (source for all event classes is included under src in the Versant Open
      Access distribution). The .jdolog files written by the log downloader
      and the Workbench contain serialized PerfEvent[] arrays. The event
      objects contain much more information than what could be expressed with
      a text file event log. Creating and adding an object to a ring buffer is
      also a lot faster than formatting and writing a text String to a file.</para>

      <figure>
        <title>Management Console Event Log</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/event_log.png" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The events displayed can be sorted by clicking the grid column
      headers. The columns are as follows:</para>

      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Column</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>Start</entry>

              <entry>The start time of the event.</entry>
            </row>

            <row>
              <entry>Event</entry>

              <entry>The name of the event.</entry>
            </row>

            <row>
              <entry>Time</entry>

              <entry>The duration of the event in milliseconds. This may be -1
              if the event was still in progress when it was downloaded.</entry>
            </row>

            <row>
              <entry>Ok</entry>

              <entry>Did the operation complete without exceptions?</entry>
            </row>

            <row>
              <entry>Description</entry>

              <entry>Short description of the event. Double click to see
              details.</entry>
            </row>

            <row>
              <entry>Client</entry>

              <entry>The remote client (if any). Sort on this column to see
              all events for a given client.</entry>
            </row>

            <row>
              <entry>PM ID</entry>

              <entry>An ID for the PersistenceManager. Note that these are
              repeated as closed PMs are returned to a pool.</entry>
            </row>

            <row>
              <entry>DS Tx</entry>

              <entry>The datastore (i.e. JDBC) transaction ID. Sort on this
              column to see the events for a given JDBC transaction.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>The different events are grouped into related categories and
      described in the following sections.</para>

      <section id="events_pm">
        <title>PM Events<indexterm><primary>PM events</primary></indexterm><indexterm><primary>events
        PM</primary></indexterm></title>

        <para>These events are logged when PersistenceManager&#39;s are
        obtained (e.g. <classname>PMF.getPersistenceManager</classname>
        called) and released.</para>

        <informaltable>
          <tgroup cols="3">
            <thead>
              <row>
                <entry>Event</entry>

                <entry>Description</entry>

                <entry>Logged for level</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>pm.alloc</entry>

                <entry>PM allocated from pool (PMF.getPM called).</entry>

                <entry>normal</entry>
              </row>

              <row>
                <entry>pm.release</entry>

                <entry>PM released back to pool (PM.close called).</entry>

                <entry>normal</entry>
              </row>

              <row>
                <entry>pm.created</entry>

                <entry>New PM created.</entry>

                <entry>normal</entry>
              </row>

              <row>
                <entry>pm.closed</entry>

                <entry>PM closed.</entry>

                <entry>normal</entry>
              </row>

              <row>
                <entry>pm.closed.auto</entry>

                <entry>PM closed automatically by Versant Open Access.</entry>

                <entry>normal</entry>
              </row>

              <row>
                <entry>pm.closed.auto.tx</entry>

                <entry>PM closed automatically with open datastore transaction
                (BAD).</entry>

                <entry>errors</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>It is important to close all PMs. Versant Open Access will close
        PMs automatically when they are garbage collected but these PMs will
        not be put back in the PM pool. PMs left open with an active datastore
        transaction (<command>pm.closed.auto.tx</command>) will hold database
        locks.</para>
      </section>

      <section id="events_tx">
        <title>JDO Transaction Events<indexterm><primary>transaction events</primary></indexterm><indexterm><primary>events
        transaction</primary></indexterm></title>

        <para>These events are logged for transaction related operations on a
        PM. Note that these are JDO transactions and there is no direct
        relationship between a JDO transaction and a JDBC transaction (see
        <xref linkend="transactions" />).</para>

        <informaltable>
          <tgroup cols="3">
            <thead>
              <row>
                <entry>Event</entry>

                <entry>Description</entry>

                <entry>Logged for level</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>tx.begin</entry>

                <entry>Optimistic transaction started.</entry>

                <entry>normal</entry>
              </row>

              <row>
                <entry>tx.begin.datastore</entry>

                <entry>Datastore transaction started.</entry>

                <entry>normal</entry>
              </row>

              <row>
                <entry>tx.commit</entry>

                <entry>Transaction committed.</entry>

                <entry>normal</entry>
              </row>

              <row>
                <entry>tx.rollback</entry>

                <entry>Transaction rolled back.</entry>

                <entry>normal</entry>
              </row>

              <row>
                <entry>tx.flush</entry>

                <entry>Manual flush (see <xref linkend="calling_flush" />).</entry>

                <entry>normal</entry>
              </row>

              <row>
                <entry>tx.flush.auto</entry>

                <entry>Automatic flush (see <xref linkend="flushing" />).</entry>

                <entry>normal</entry>
              </row>

              <row>
                <entry>set.ds.tx.locking</entry>

                <entry>Datastore transaction locking mode changed (see <xref
                linkend="datastore_locking_mode" />).</entry>

                <entry>normal</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>If you are using remote PMs then it is important to only use
        optimistic transactions and to avoid flushing. Flushing may cause a
        JDBC transaction to span a remote call to the server.</para>
      </section>

      <section id="events_data_fetch">
        <title>Data Events<indexterm><primary>data events</primary></indexterm><indexterm><primary>events
        data</primary></indexterm><indexterm><primary>JDOQL events</primary></indexterm><indexterm><primary>events
        JDOQL</primary></indexterm></title>

        <para>These events are logged for server operations that return data,
        work with JDOQL queries and manipulate the level 2 cache.</para>

        <informaltable>
          <tgroup cols="3">
            <thead>
              <row>
                <entry>Event</entry>

                <entry>Description</entry>

                <entry>Logged for level</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>jdoql.compile</entry>

                <entry>JDOQL query compiled.</entry>

                <entry>verbose</entry>
              </row>

              <row>
                <entry>jdoql.exec</entry>

                <entry>JDOQL query executed.</entry>

                <entry>normal</entry>
              </row>

              <row>
                <entry>jdoql.exec.count</entry>

                <entry>JDOQL query executed for count only (see <xref
                linkend="count_on_size" />).</entry>

                <entry>normal</entry>
              </row>

              <row>
                <entry>jdoql.cache.hit</entry>

                <entry>Query results where found in query cache.</entry>

                <entry>all</entry>
              </row>

              <row>
                <entry>jdoql.cache.fail</entry>

                <entry>At least one OID in the cached query results was no
                longer in the level 2 cache.</entry>

                <entry>all</entry>
              </row>

              <row>
                <entry>jdoql.cache.evict</entry>

                <entry>Query results evicted from cache.</entry>

                <entry>all</entry>
              </row>

              <row>
                <entry>get.query.batch</entry>

                <entry>Batch of results fetched for a query.</entry>

                <entry>verbose</entry>
              </row>

              <row>
                <entry>get.query.all</entry>

                <entry>All results fetched for a query.</entry>

                <entry>verbose</entry>
              </row>

              <row>
                <entry>get.state</entry>

                <entry>Field data fetched for an instance.</entry>

                <entry>verbose</entry>
              </row>

              <row>
                <entry>get.state.multi</entry>

                <entry>Field data fetched for many instances.</entry>

                <entry>verbose</entry>
              </row>

              <row>
                <entry>pmf.evict</entry>

                <entry>Data for an instance manually evicted from the level 2
                cache.</entry>

                <entry>normal</entry>
              </row>

              <row>
                <entry>pmf.evict.all</entry>

                <entry>Data for all instances manually evicted from the level
                2 cache.</entry>

                <entry>normal</entry>
              </row>

              <row>
                <entry>pmf.evict.class</entry>

                <entry>Data for all instances of a class manually evicted from
                the level 2 cache.</entry>

                <entry>normal</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>The detail view for the <command>get.query.batch</command> and
        <command>get.query.all</command> events includes the OIDs of all the
        instances with data included in the result packet if event logging is
        <literal>all</literal>. In this example (from demos/tut1) the category
        field on Item was added to the default fetch group causing it to be
        fetched with an outer join and included with the items.</para>

        <para><inlinemediaobject><imageobject><imagedata
        fileref="images/get_query_batch.png" /></imageobject></inlinemediaobject></para>

        <para>The detail view for <command>get.state</command> also includes
        the OIDs for all of the instances with data in the result packet if
        event logging is <literal>all</literal>. The field that was navigated
        causing the data fetch is also included (if any). In this example the
        data for <classname>lines</classname> field on <classname>Order</classname>
        is being fetched.</para>

        <para><inlinemediaobject><imageobject><imagedata
        fileref="images/get_state.png" /></imageobject></inlinemediaobject></para>
      </section>

      <section id="events_jdbc">
        <title>JDBC Events<indexterm><primary>JDBC events</primary></indexterm><indexterm><primary>events
        JDBC</primary></indexterm></title>

        <para>These events are logged for JDBC related operations. Note that
        events are logged even for work done using direct JDBC on a connection
        returned by <classname>PM.getJdbcConnection</classname> or
        <classname>PMF.getJdbcConnection</classname>.</para>

        <informaltable>
          <tgroup cols="3">
            <thead>
              <row>
                <entry>Event</entry>

                <entry>Description</entry>

                <entry>Logged for level</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>jdbc.con.connect</entry>

                <entry>Connection created.</entry>

                <entry>normal</entry>
              </row>

              <row>
                <entry>jdbc.con.close</entry>

                <entry>Connection closed.</entry>

                <entry>normal</entry>
              </row>

              <row>
                <entry>jdbc.con.commit</entry>

                <entry>JDBC transaction commit.</entry>

                <entry>normal</entry>
              </row>

              <row>
                <entry>jdbc.con.rollback</entry>

                <entry>JDBC transaction rollback.</entry>

                <entry>normal</entry>
              </row>

              <row>
                <entry>jdbc.con.autoCommit</entry>

                <entry>Connection.setAutoCommit called.</entry>

                <entry>all</entry>
              </row>

              <row>
                <entry>jdbc.con.isolation</entry>

                <entry>Connection.setIsolationlevel called.</entry>

                <entry>verbose</entry>
              </row>

              <row>
                <entry>jdbc.con.createStat</entry>

                <entry>Statement created.</entry>

                <entry>all</entry>
              </row>

              <row>
                <entry>jdbc.con.prepareStat</entry>

                <entry>PreparedStatement created.</entry>

                <entry>all</entry>
              </row>

              <row>
                <entry>jdbc.con.prepareCall</entry>

                <entry>CallableStatement created.</entry>

                <entry>all</entry>
              </row>

              <row>
                <entry>jdbc.stat.execQuery</entry>

                <entry>Statement.executeQuery called.</entry>

                <entry>normal</entry>
              </row>

              <row>
                <entry>jdbc.stat.execUpdate</entry>

                <entry>Statement.executeUpdate called.</entry>

                <entry>normal</entry>
              </row>

              <row>
                <entry>jdbc.stat.exec</entry>

                <entry>Statement.execute called.</entry>

                <entry>normal</entry>
              </row>

              <row>
                <entry>jdbc.stat.close</entry>

                <entry>Statement closed.</entry>

                <entry>all</entry>
              </row>

              <row>
                <entry>jdbc.stat.addBatch</entry>

                <entry>Statement.addBatch called.</entry>

                <entry>verbose</entry>
              </row>

              <row>
                <entry>jdbc.stat.execBatch</entry>

                <entry>Statement.executeBatch called.</entry>

                <entry>normal</entry>
              </row>

              <row>
                <entry>jdbc.stat.maxrows</entry>

                <entry>Statement.setMaxRows called.</entry>

                <entry>all</entry>
              </row>

              <row>
                <entry>jdbc.rs.close</entry>

                <entry>ResultSet closed.</entry>

                <entry>all</entry>
              </row>

              <row>
                <entry>jdbc.rs.next</entry>

                <entry>ResultSet.next called.</entry>

                <entry>all</entry>
              </row>

              <row>
                <entry>jdbc.rs.relative</entry>

                <entry>ResultSet.relative called.</entry>

                <entry>all</entry>
              </row>

              <row>
                <entry>jdbc.rs.absolute</entry>

                <entry>ResultSet.absolute called.</entry>

                <entry>all</entry>
              </row>

              <row>
                <entry>jdbc.rs.last</entry>

                <entry>ResultSet.last called.</entry>

                <entry>all</entry>
              </row>

              <row>
                <entry>jdbc.rs.getrow</entry>

                <entry>ResultSet.getRow called.</entry>

                <entry>all</entry>
              </row>

              <row>
                <entry>jdbc.rs.fetchsize</entry>

                <entry>ResultSet.setFetchSize called.</entry>

                <entry>all</entry>
              </row>

              <row>
                <entry>jdbc.pool.alloc</entry>

                <entry>Connection allocated from pool.</entry>

                <entry>all</entry>
              </row>

              <row>
                <entry>jdbc.pool.release</entry>

                <entry>Connection returned to pool.</entry>

                <entry>all</entry>
              </row>

              <row>
                <entry>jdbc.pool.badcon</entry>

                <entry>Connection failed validation.</entry>

                <entry>errors</entry>
              </row>

              <row>
                <entry>jdbc.pool.confailed</entry>

                <entry>Attempt to create new connection failed.</entry>

                <entry>errors</entry>
              </row>

              <row>
                <entry>jdbc.pool.contimeout</entry>

                <entry>Active connection timed out and was closed.</entry>

                <entry>errors</entry>
              </row>

              <row>
                <entry>jdbc.pool.conexpired</entry>

                <entry>Connection was closed as age reached maximum.</entry>

                <entry>verbose</entry>
              </row>

              <row>
                <entry>jdbc.pool.full</entry>

                <entry>No connection available due to full pool.</entry>

                <entry>errors</entry>
              </row>

              <row>
                <entry>jdbc.pspool.alloc</entry>

                <entry>Cached PreparedStatement allocated.</entry>

                <entry>verbose</entry>
              </row>

              <row>
                <entry>jdbc.pspool.release</entry>

                <entry>Cached PreparedStatement released.</entry>

                <entry>verbose</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </section>

      <section id="events_remote">
        <title>Remote Events<indexterm><primary>remote events</primary></indexterm><indexterm><primary>events
        remote</primary></indexterm></title>

        <para>These events are logged when remote clients connect. Note that
        all events carry a remote client field with the IP address of the
        remote client associated with the operation (if any). This is
        displayed on the main event log grid. You can sort on this to quickly
        see all events for a given client (click the grid column headers to
        sort).</para>

        <informaltable>
          <tgroup cols="3">
            <thead>
              <row>
                <entry>Event</entry>

                <entry>Description</entry>

                <entry>Logged for level</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>remote.pmf.connect</entry>

                <entry>Remote client has connected to the server.</entry>

                <entry>normal</entry>
              </row>

              <row>
                <entry>remote.pmf.disconnect</entry>

                <entry>Remote client has disconnected from the server.</entry>

                <entry>normal</entry>
              </row>

              <row>
                <entry>remote.pmf.badauth</entry>

                <entry>Remote client failed authentication on connect.</entry>

                <entry>normal</entry>
              </row>

              <row>
                <entry>remote.pmf.disabled</entry>

                <entry>Remote client attempted to connect but remote access
                has been disabled.</entry>

                <entry>normal</entry>
              </row>

              <row>
                <entry>remote.pmf.bad.version</entry>

                <entry>Remote client attempted to connect with a different
                Versant Open Access version to the server.</entry>

                <entry>normal</entry>
              </row>

              <row>
                <entry>remote.pm.disabled</entry>

                <entry>Remote client attempted to create a PM but this has
                been disabled.</entry>

                <entry>normal</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </section>

      <section id="events_misc">
        <title>Miscellaneous Events<indexterm><primary>misc events</primary></indexterm><indexterm><primary>events
        misc</primary></indexterm></title>

        <informaltable>
          <tgroup cols="3">
            <thead>
              <row>
                <entry>Event</entry>

                <entry>Description</entry>

                <entry>Logged for level</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>set.property</entry>

                <entry>Server property changed.</entry>

                <entry>none (always logged)</entry>
              </row>

              <row>
                <entry>lock.cleanup</entry>

                <entry>Internal Versant Open Access data structures cleaned
                up.</entry>

                <entry>all</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </section>

      <section id="events_user">
        <title>User Defined Events<indexterm><primary>user defined events</primary></indexterm><indexterm><primary>events
        user defined</primary></indexterm></title>

        <para>You can log your own events to the event log using methods on
        <classname>VersantPersistenceManager</classname> and
        <classname>VersantPersistenceManagerFactory</classname> as shown in
        the following example:</para>

        <programlisting>import com.versant.core.jdo.VersantPersistenceManagerFactory;
import com.versant.core.jdo.VersantPersistenceManager;

VersantPersistenceManagerFactory pmf = ...
VersantPersistenceManager pm = 
    (VersantPersistenceManager)pmf.getPersistenceManager();

// log an event using the PMF
pmf.logEvent(VersantPersistenceManagerFactory.EVENT_NORMAL, 
    &#34;Processing message&#34;, 0);

// log an event using the PM
// this event will be flagged with the PM ID
long start = System.currentTimeMillis();
doProcessing();
int ms = (int)(System.currentTimeMillis() - start);
pm.lofEvent(VersantPersistenceManagerFactory.EVENT_ALL, 
    &#34;Processing complete&#34;, ms);</programlisting>

        <para>This feature can be used to associate business operations with
        JDO events in the event log to aid analysis. A future Versant Open
        Access release will have support for use-case based performance tuning
        using a similar mechanism. If you are using remote PMs remember that
        all of these methods require a remote call to the server.</para>
      </section>
    </section>
  </chapter>

  <chapter id="connection_pool">
    <title>Connection Pool Configuration<indexterm><primary>connection pool
    configuration</primary></indexterm></title>

    <para>The Versant Open Access JDBC connection pool supports statement
    pooling, testing of idle connections in the background, automatic closing
    of stuck or leaked connections, user configurable initialization and
    validation SQL and other features.</para>

    <section id="active_con_timeout">
      <title>Active Connection Timeout<indexterm><primary>active connection
      timeout</primary></indexterm><indexterm><primary>connection timeout</primary></indexterm></title>

      <para>The connection pool will close and discard active connections that
      have been busy or idle for a long time (default 2 minutes). This helps a
      server recover from stuck SQL, connection leaks and deadlocks not
      detected by the database server. If you have queries that take more than
      2 minutes to execute or obtain JDBC connections from the
      PersistenceManagerFactory and keep them idle you may need to disable
      this feature by setting the timeout to 0 (see <xref
      linkend="pool_con_timeout" /> or edit <literal>versant.conTimeout</literal>
      in the <filename>.properties</filename> file).</para>

      <para>A <literal>jdbc.pool.contimeout</literal> event is logged when
      connections are timed out if the event logging level is set to anything
      other than &#39;none&#39;. This should be considered a serious error.</para>
    </section>

    <section id="idle_connection_testing">
      <title>Idle Connection Testing<indexterm><primary>idle connection
      testing</primary></indexterm></title>

      <para>The oldest idle connection is tested every 2 minutes. If it fails
      validation it is closed and discarded and the next idle connection is
      tested. This gets rid of stale connections after a database server
      restart or network problem. This feature can be disabled (see <xref
      linkend="test_when_idle" /> or edit <literal>versant.testWhenIdle=false</literal>
      in the .properties file). The test interval in seconds can be changed (<xref
      linkend="pool_test_interval" /> or edit <literal>versant.testInterval</literal>
      in the <filename>.properties</filename> file).</para>
    </section>

    <section id="connection_lifespan">
      <title>Max Connection Age<indexterm><primary>connection lifespan</primary></indexterm><indexterm><primary>max
      connection age</primary></indexterm></title>

      <para>Each time a connection is returned to the pool its age is
      incremented by 1. Connections that are at least as old as the maximum
      connection age (default 1000) are closed instead of being put back in
      the pool. This helps to prevent server or database problems due to JDBC
      related resource leaks.</para>
    </section>

    <section id="pool_settings_tab">
      <title>Workbench Pool Settings Tab<indexterm><primary>pool settings tab</primary></indexterm></title>

      <para>Connection pool settings are easiest to configure using the
      Workbench (<command>File | Datastore Properties, Pool Settings tab</command>).</para>

      <formalpara id="pool_max_active">
        <title>Pool max active<indexterm><primary>pool max active</primary></indexterm></title>

        <para>The maximum number of connections to create for the connection
        pool. If you set this to 10 then Versant Open Access will not open
        more than 10 connections to the database. You need to use the event
        log to monitor your production system to decide how many connections
        you need. This depends on the transaction mode (optimistic or
        datastore), the length of your transactions and the number of users.</para>
      </formalpara>

      <formalpara id="pool_block_when_full">
        <title>Block when full<indexterm><primary>pool block when full</primary></indexterm></title>

        <para>Threads attempting to obtain a connection will wait until one is
        available if this property is true (the default). Otherwise a
        <classname>VersantConnectionPoolFullException</classname> is thrown. A
        <literal>jdbc.pool.full</literal> event is logged in either case.</para>
      </formalpara>

      <formalpara id="pool_max_idle">
        <title>Pool max idle<indexterm><primary>pool max idle</primary></indexterm></title>

        <para>The maximum number of idle connections to keep in the pool.
        Setting this to a number lower than &#34;Pool max active&#34; will
        cause the pool to shrink during idle periods.</para>
      </formalpara>

      <formalpara id="pool_min_idle">
        <title>Pool min idle<indexterm><primary>pool min idle</primary></indexterm></title>

        <para>New connections are created by a background thread if the number
        of idle connections in the pool is less than this setting. This
        improves response time when the load on the server is increasing.</para>
      </formalpara>

      <formalpara id="pool_reserved">
        <title>Pool reserved<indexterm><primary>pool reserved</primary></indexterm></title>

        <para>The number of connections to reserve for primary key generation.
        This prevents deadlocks on commit.</para>
      </formalpara>

      <formalpara id="ps_cache_max">
        <title>PS cache size limit<indexterm><primary>PreparedStatement cache
        size limit</primary></indexterm></title>

        <para>Set the maximum number of PreparedStatements to cache per
        connection. If left blank this defaults to a value reasonable for the
        database in use (currently only limited on Oracle to 30). Use 0 for
        unlimited.</para>
      </formalpara>

      <formalpara id="wait_for_con_on_startup">
        <title>Wait for con on startup<indexterm><primary>wait for con on
        startup</primary></indexterm></title>

        <para>If this is true then the Versant Open Access server will wait
        until it can successfully connect to the database before starting. If
        false it will fail to start. This is useful in production to avoid
        timing issues with database startup and application deployment.</para>
      </formalpara>

      <formalpara id="init_sql">
        <title>Connection init SQL<indexterm><primary>connection init SQL</primary></indexterm></title>

        <para>An SQL statement to be executed on each newly created
        connection. If blank Versant Open Access will supply suitable SQL for
        your database server (if required). If this ends with
        <literal>; commit</literal> or <literal>; COMMIT</literal> then a
        commit is done on the connection after executing the SQL.</para>
      </formalpara>

      <formalpara id="validate_sql">
        <title>Connection validation SQL<indexterm><primary>connection
        validation SQL</primary></indexterm></title>

        <para>An SQL query to be executed when a connection is validated. This
        must return at least one row. If blank a suitable query is supplied by
        Versant Open Access.</para>
      </formalpara>

      <formalpara id="test_on_alloc">
        <title>Test con on alloc<indexterm><primary>test con on alloc</primary></indexterm></title>

        <para>If true then each connection is validated before leaving the
        pool. This may have a serious negative impact on performance.</para>
      </formalpara>

      <formalpara id="test_on_release">
        <title>Test con on release<indexterm><primary>test con on release</primary></indexterm></title>

        <para>If true then each connection is validated before being returned
        to the pool. This may have a serious negative impact on performance.</para>
      </formalpara>

      <formalpara id="test_on_exception">
        <title>Test con on exception<indexterm><primary>test con on exception</primary></indexterm></title>

        <para>If true then connections involved in an exception thrown by the
        JDBC driver are validated before being returned to the pool.</para>
      </formalpara>

      <formalpara id="test_when_idle">
        <title>Test con when idle<indexterm><primary>test con when idle</primary></indexterm></title>

        <para>If true then idle connections are tested periodically by a
        background thread. Connections that fail validation are discarded.</para>
      </formalpara>

      <formalpara id="pool_test_interval">
        <title>Pool test interval<indexterm><primary>pool test interval</primary></indexterm></title>

        <para>The number of seconds between idle connection test runs and
        active connection timeout checks.</para>
      </formalpara>

      <formalpara id="pool_con_timeout">
        <title>Active con timeout<indexterm><primary>active con timeout</primary></indexterm></title>

        <para>Active connections that have been inactive or busy for this many
        seconds are closed. A <literal>jdbc.pool.contimeout</literal> event is
        logged if this happens.</para>
      </formalpara>

      <formalpara id="pool_max_con_age">
        <title>Max connection age<indexterm><primary>max connection age</primary></indexterm></title>

        <para>Active connections that have been inactive or busy for this many
        seconds are closed. A <literal>jdbc.pool.contimeout</literal> event is
        logged if this happens.</para>
      </formalpara>

      <formalpara id="retry_count">
        <title>Connect retry count<indexterm><primary>connect retry count</primary></indexterm></title>

        <para>If the JDBC driver throws an exception for a connect() call the
        operation will be retried this many times (0 for infinite, -1 for no
        retries). When the retries are exhausted the exception will propagate
        to the application.</para>
      </formalpara>

      <formalpara id="retry_interval">
        <title>Connect retry interval<indexterm><primary>connect retry
        interval</primary></indexterm></title>

        <para>The pool will sleep for this many milliseconds between retries
        for connect() exceptions.</para>
      </formalpara>

      <para></para>
    </section>
  </chapter>

  <chapter id="tips_and_tricks">
    <title>Tips and Tricks<indexterm><primary>tips and tricks</primary></indexterm></title>

    <para>This chapter contains information on various popular topics not
    covered in other chapters.</para>

    <section id="add_license_to_jar">
      <title>Add License to openaccess.jar<indexterm><primary>license file</primary></indexterm></title>

      <para>You can avoid having to make sure that your openaccess.license
      file is on the classpath of your applications by adding it to
      openaccess.jar. Execute the following commands from the directory where
      Versant Open Access is installed:</para>

      <programlisting>jar uf &#60;OPENACCESS_HOME&#62;/lib/openaccess.jar -C &#60;OPENACCESS_HOME&#62;/license openaccess.license</programlisting>
    </section>

    <section id="use_interfaces_for_collections">
      <title>Declare Collections using Interfaces<indexterm><primary>collections</primary></indexterm></title>

      <para>It is more efficient to declare persistent collection fields using
      the appropriate interface types (List, Collection, Map or Set) instead
      of the supported concrete implementations (ArrayList, HashSet or
      HashMap). Versant Open Access must supply a second class object (SCO)
      implementation for the field. If you use a concrete type (e.g.
      ArrayList) then this SCO must be a subclass of ArrayList. This is slower
      than the SCO implementation that only has to implement the List
      interface. However if you know that a LinkedList is a more efficient
      choice for your model then declare the field as &#39;LinkedList&#39;.
      Versant Open Access will use a LinkedList subclass as the SCO.</para>

      <programlisting>public class Bad {
    private ArrayList list = new ArrayList();
...
}

public class Good {
    private List list = new ArrayList();
...
}</programlisting>
    </section>

    <section id="nplus1_database_calls">
      <title>The N+1 Database Calls Problem<indexterm><primary>N+1 database
      calls problem</primary></indexterm></title>

      <para>JDO supports transparent fetching of referenced objects as they
      are navigated. This &#34;lazy loading&#34; of referenced objects works
      very well when working with individual objects as only the objects
      touched are fetched from the database. It becomes a performance problem
      when navigating the same reference for a collection of objects as each
      referenced instance is fetched individually with a separate SQL
      statement. Versant Open Access has two solutions to the N + 1 database
      calls problem:</para>

      <section id="nplus1_using_dfg">
        <title>Using the Default Fetch Group<indexterm><primary>SQL joins</primary></indexterm><indexterm><primary>default
        fetch group</primary></indexterm></title>

        <para>Versant Open Access will do outer joins to prefetch referenced
        instances placed into the default fetch group (eager fetching). It
        will also use parallel queries to fetch collections and maps in the
        default fetch group (<xref linkend="parallel_collection_fetch" />).
        Note that references, collections and maps are not in the default
        fetch group by default and you will need to use the Workbench to set
        default-fetch-group to true. You can also change the outer join to an
        inner join (see <xref linkend="md_jdbc_use_join" />) if you are sure
        of the referential integrity of your database and the reference does
        not allow nulls.</para>
      </section>

      <section id="nplus1_caching">
        <title>Using Cache-Strategy &#39;all&#39;<indexterm><primary>caching</primary></indexterm><indexterm><primary>cache-strategy
        all</primary></indexterm></title>

        <para>If the number of possible referenced instances is small (e.g. a
        Country reference on Address) and you are using optimistic
        transactions (see <xref linkend="optimistic_transactions" />) then you
        can use the cache to avoid the extra queries. Set the cache-strategy
        of the referenced class (e.g. Country) to &#39;all&#39; using the
        Workbench Class Properties window or by editing the meta data (see
        <xref linkend="md_cache_strategy" />). Versant Open Access will read
        and cache all instances of the class with a single SQL query the first
        time an instance is required. This &#34;warms up&#34; the cache and
        avoids the individual queries.</para>
      </section>
    </section>

    <section id="slow_sql_queries">
      <title>SQL Query Performance<indexterm><primary>SQL query performance</primary></indexterm><indexterm><primary>indexes</primary></indexterm></title>

      <para>You can use the Versant Open Access Workbench Management Console
      to connect to a remote Versant Open Access server and analyse its
      performance (see <xref linkend="performance_monitoring" />). The console
      filter all queries onto a tab sorted from slowest to fastest. Often all
      that is needed to improve performance is to add indexes on the fields
      used in the where clauses of the slowest queries. Use the Class
      Properties window in the Workbench to add them or edit the meta data
      directly (see <xref linkend="md_jdbc_index" />).</para>
    </section>

    <section id="need_bulk_updates">
      <title>Bulk Updates and SQL Aggregates<indexterm><primary>bulk updates</primary></indexterm><indexterm><primary>aggregate
      functions</primary></indexterm></title>

      <para>If you need to do a COUNT(*) query you can use the countStarOnSize
      JDOQL extension (see <xref linkend="count_on_size" />).</para>

      <para>The JDO specification version 1.0.1 does not provide for
      projections in JDOQL queries (aggregates e.g. SUM) or for bulk updates.
      This is planned for JDO 2.0. Versant Open Access supports direct use of
      SQL for the small percentage of cases where the set based power of SQL
      is required. You can obtain a JDBC Connection from a
      <classname>VersantPersistenceManager</classname> (PM) or a
      <classname>VersantPersistenceManagerFactory</classname> (PMF). Please
      look at the source for this interfaces under the <filename>src</filename>
      directory of the Versant Open Access distribution for more information.</para>

      <para>Once you have a JDBC connection you can use it to execute any SQL
      required. If you modify any tables mapped to persistent classes you must
      evict all instances of those classes from the level 2 PMF wide cache.
      There are methods on VersantPersistenceManagerFactory to do this. You
      may also need to refresh instances in the local PM cache using
      pm.refresh().</para>

      <para>If the SQL you need to run must see uncommitted changes from the
      current JDO transaction then you can cast your pm to a
      VersantPersistenceManager and call flush(). This will generate inserts
      and updates for all dirty instances in the PM but will not commit the
      JDBC transaction.</para>
    </section>

    <section id="junit_and_jdo">
      <title>JUnit and JDO<indexterm><primary>JUnit and JDO</primary></indexterm></title>

      <para>JUnit is a popular unit testing framework available from <ulink
      url="http://www.junit.org">www.junit.org</ulink>. This section assumes
      you have some knowledge of how JUnit works and provides solutions to
      some JDO specific issues with JUnit. The code samples are taken from the
      JUnit demo in <filename>demos/junit</filename>.</para>

      <para>JUnit tests are typically grouped into TestSuite&#39;s. A
      TestSuite provides a good place to start the Versant Open Access server
      before running the tests and to stop it when the tests complete. Note
      how the code snippet (from <filename>demos/junit/src/tests/TestContact.java</filename>)
      below calls setContextClassLoader. This makes it possible to use the
      &#34;reload classes&#34; option in the JUnit gui test runner.</para>

      <programlisting>/**
 * Create a TestSuite that starts up and shuts down the Versant Open Access server.
 * This must set the contextClassLoader for the current thread to the
 * ClassLoader that loaded us or the JUnit GUI will not be able to
 * reload the classes.
 */
public static Test suite() {
    return new TestSuite(TestContact.class) {
        public void run(TestResult result) {
            // this makes the reload option of the JUnit GUI work
            Thread.currentThread().setContextClassLoader(
                    getClass().getClassLoader());
            JDOSupport.init();
            super.run(result);
            JDOSupport.shutdown();
        }
    };
}</programlisting>
    </section>

    <section id="create_oid_null_class">
      <title>Create OID from String w/o Class<indexterm><primary>create OID
      from String w/o Class</primary></indexterm></title>

      <para>Normally you must supply a Class when using
      PersistenceManager.newObjectIdInstance(Class,String) to convert an OID
      String into an OID. Versant Open Access accepts a null class for
      datastore identity classes. This is convenient when you do not know the
      Class the String is for. If the String is invalid a JDOUserException is
      thrown.</para>

      <programlisting>String oidString = ...
Object oid = pm.newObjectIdInstance(null, oidString);
// this works for any datastore identity class
Object jdoInstance = pm.getObjectById(oid, true);
...</programlisting>
    </section>

    <section id="disable_batching_for_dev">
      <title>Disable JDBC Batching in Development<indexterm><primary>disable
      JDBC batching for dev</primary></indexterm></title>

      <para>Versant Open Access will use JDBC statement batching on supported
      JDBC drivers and databases for improved performance. However it is often
      difficult to find the underlying cause of an SQLException in a batch.
      The error message might be &#34;batch update failed&#34; instead of
      &#34;unique constraint xxx violated&#34; making it difficult to debug
      problems. You can disable batching using the General Settings tab of the
      <command>File | Datastore Properties</command> dialog:</para>

      <para><inlinemediaobject><imageobject><imagedata
      fileref="images/datastore_disable_batching.png" /></imageobject></inlinemediaobject></para>
    </section>

    <section id="avoid_oid_before_commit">
      <title>Avoid getObjectId Before Commit<indexterm><primary>getObjectId
      before commit</primary></indexterm></title>

      <para>You can improve performance by not calling <classname>PM.getObjectId(pc)</classname>
      on an instance made persistent in the current transaction. This will
      trigger a flush if you are using a post-insert key generator (e.g.
      AUTOINC, see <xref linkend="flushing_keygen" />). Even if you are using
      the HIGHLOW key generator a server call is still required to generate
      the new primary key.</para>

      <para>Here is an example:</para>

      <programlisting>pm.currentTransaction().begin();
AutoIncClass pc = new AutoIncClass();
pm.makePersistent(pc);
pm.currentTransaction().commit();
Object oid = pm.getObjectId(pc); // call after commit()</programlisting>
    </section>
  </chapter>

  <chapter id="web_apps">
    <title>Web Applications<indexterm><primary>web applications</primary></indexterm></title>

    <para>This chapter describes how to use JDO in a web (servlets and JSPs)
    application. It refers to the Struts demo in <filename>demos/testcenter</filename>.</para>

    <section id="web_starting_server">
      <title>Starting the Versant Open Access Server</title>

      <para>If your application is running inside an application server then
      Versant Open Access should be deployed as a JCA adapter. In this case
      the PersistenceManagerFactory(PMF) should be looked up using JNDI in the
      same way as done by session beans (see <xref
      linkend="jdo_tutorial_session_bean" />for details).</para>

      <para>If the application only uses a web tier (i.e. no session beans)
      then a singleton Java class should be used to create the PMF using
      JDOHelper.getPersistenceManagerFactory(...). All servlets, JSPs and
      other classes can create PersistenceManager&#39;s using the singleton.
      One of your servlets should be configured to load-on-startup in web.xml
      and it must initialize the singleton. The order index should be lower
      than any other servlets also set to load-on-startup to ensure that it is
      loaded first. Here is the JDOSupport class from the Struts demo (<filename>demos/testcenter</filename>).
      This class is initialized using a Struts plugin.</para>

      <programlisting>package za.co.hemtech.testcenter.service;

import com.versant.core.jdo.VersantPersistenceManagerFactory;
import za.co.hemtech.testcenter.model.JDOUtil;

import javax.jdo.PersistenceManager;
import javax.jdo.PersistenceManagerFactory;
import javax.jdo.JDOHelper;
import java.util.HashMap;
import java.util.Properties;

/**
 * Context associated with current thread. Used to provide current thread&#39;s
 * {@link PersistenceManager instance} using static refence to application&#39;s
 * {@link PersistenceManagerFactory}.
 * &#60;p&#62;
 * This code is not web-application specific, but can be used in
 * any environment.
 */
public class Context {

    private static PersistenceManagerFactory pmf;
    private static ThreadLocal contextHolder = new ThreadLocal();

    private PersistenceManager persistenceManager;

    private Context() {
    }

    /**
     * Creates and configures {@link PersistenceManagerFactory}.
     */
    public static void initialize(Properties props) {
        pmf = JDOHelper.getPersistenceManagerFactory(props);
    }

    /**
     * Shut down JDO engine
     */
    public static void shutdown() {
        pmf.close();
    }

    /**
     * Obtain instance of the Context for current thread.
     */
    public static Context getContext() {
        Context ctx = (Context) contextHolder.get();
        if (ctx == null) {
            ctx = new Context();
        }
        contextHolder.set(ctx);
        return ctx;
    }

    /**
     * Obtain this context&#39;s JDO persistence manager.
     */
    public PersistenceManager getPersistenceManager() {
        if (persistenceManager == null) {
            persistenceManager = pmf.getPersistenceManager();
        }
        return persistenceManager;
    }

    /**
     * Close Context&#39;s instance. Closes its instance of {@link PersistenceManager}
     * and removes reference to this instance from current thread.
     */
    public void close() {
        contextHolder.set(null);
        JDOUtil.close(persistenceManager);
    }

    protected void finalize() throws Throwable {
        close();
    }
}</programlisting>
    </section>

    <section id="web_pm">
      <title>PersistenceManager Lifespan<indexterm><primary>web app PM
      lifespan</primary></indexterm></title>

      <para>A PersistenceManager(PM) should be obtained for each request and
      closed at the end. This ensures that transactions are never left open
      from one web request to the next. This is often best done by wrapping
      the service method of your controller servlet. In a Struts application
      this is done by extending the RequestProcessor (see
      <filename>demos/testcenter/src/za/co/hemtech/testcenter/web/MyRequestProcessor.java</filename>).
      Versant Open Access pools PMs so there is no performance cost for using
      a &#39;new&#39; PM for each request.</para>

      <para>Versant Open Access will automatically close and discard PMs that
      are garbage collected. However you should not rely on this behaviour as
      other JDO implementations may not behave this way. This is also very
      dangerous if you are using datastore transactions as the JDBC connection
      and database locks will be held until the PM is garbage collected.
      Versant Open Access logs a pm.closed.auto event when an open PM is
      garbage collected. A pm.closed.auto.tx event is logged when one with an
      open datastore transaction is GCed. This should be considered a serious
      error in your application. See <xref linkend="performance_monitoring" />
      for information on how to monitor a running Versant Open Access
      application.</para>
    </section>

    <section id="web_opt_tx">
      <title>Transactions<indexterm><primary>web app transactions</primary></indexterm></title>

      <para>Versant Open Access supports datastore and optimistic transactions
      (see <xref linkend="transactions" /> for details). With datastore
      transactions a JDBC connection and transaction are associated with each
      JDO transaction for the life of the JDO transaction. Database locks are
      maintained for the duration of the JDO transaction. Versant Open Access
      cannot access the PMF wide level 2 cache as it needs to touch every row
      to obtain database locks.</para>

      <para>With optimistic transactions the JDBC connection and transaction
      are disconnected from the JDO transaction. Each operation in the
      transaction may be done on a different JDBC connection. Database locks
      are not held during the transaction. This makes it possible to use the
      level 2 PMF wide cache to improve performance. For this reason you
      should use optimistic transactions if possible.</para>

      <para>If you are using optimistic transactions you should probably also
      use non-transactional reads. This means that you only have to start a
      JDO transaction when you need update one or more instances (e.g. from
      form submit). Reads (e.g. when rendering the HTML) do not have to be
      done inside a transaction. For example a Struts action can start a
      transaction, modify an instance, commit the transaction and forward to
      the view. The view does non-transactional reads as it renders the HTML.</para>

      <para>The testcenter demo stores OIDs in the session and in hidden
      fields on forms. These are used to retrieve instances using
      pm.getObjectById(oid) for each request. This is more scalable than
      storing JDO instances in the session but Versant Open Access cannot
      automatically detect concurrent updates.</para>
    </section>

    <section id="jdo_and_http_sessions">
      <title>JDO and HttpSessions<indexterm><primary>HttpSession and JDO</primary></indexterm></title>

      <para>Recent servlet API specifications introduced HttpSession
      passivation. This feature makes it possible to create highly scalable
      web applications. Since user sessions can be swapped out after a period
      of inactivity, a much larger number of concurrent connections can be
      supported. Service availability can also be dramatically improved
      through session replication and distributed application support. However
      care should be taken when storing non-serializable entities, such as JDO
      instances or PersistenceManager&#39;s in an HttpSession.</para>

      <para>JDO managed instances lose their association with the
      PersistenceManager when they are Serialized. For this reason only the
      object ID&#39;s (OIDs) of JDO instances should be stored in the session.
      The instance should be retrieved using PM.getObjectById(oid, true) for
      each request. With optimistic transactions the instances are retrieved
      from the shared level 2 cache without any database access.</para>

      <para>An alternative approach is to store the String form of OIDs as a
      hidden fields on forms or as part of the URL. Versant Open Access OID
      Strings for datastore identity classes can be used as is in forms and
      URLs. They do not need to be encoded as they only contain digits and the
      hyphen character (e.g. 514584405-975). This approach is the most
      scalable and the application can be designed to be completely stateless.</para>
    </section>
  </chapter>

  <chapter id="gui_apps">
    <title>GUI Applications<indexterm><primary>GUI applications</primary></indexterm></title>

    <para>This chapter describes how to use JDO in a GUI (e.g. Swing or other
    rich client) application. You need to know how to get a simple Versant
    Open Access application up and running before reading this chapter (see
    <xref linkend="jdo_tutorial" />). More advanced topics around refreshing
    of JDO instances are covered here.</para>

    <section id="gui_pm">
      <title>PersistenceManager Lifespan<indexterm><primary>GUI app PM
      lifespan</primary></indexterm></title>

      <para>There are two main approaches to managing PMs in a GUI
      application. The first is to use one PM for the life of the application.
      The second is to use a different PM for each window or task.</para>

      <section id="gui_one_pm">
        <title>One PM for Life of Application<indexterm><primary>GUI app one
        PM</primary></indexterm></title>

        <para>With this approach you keep one PM open for the lifetime of the
        application. The principle advantage of this approach is that all your
        model instances are always managed by JDO. This avoids the problems of
        trying to access managed JDO instances after their owning PM has been
        closed and of dealing with transient instances. The disadvantage of
        this approach is that you can only have one transaction per PM. You
        will not be able to commit changes made in one part of your
        application on their own.</para>

        <para>When you close a PM all JDO managed instances created from that
        PM (i.e. managed by it) become inaccessible. This is not a problem in
        a web app as you try and maintain as little state as possible between
        requests. All instances retrieved during the request are thrown away
        after it is complete. In a GUI environment if you close the PM you
        must either get rid of any references to objects created from that PM
        or make all the instances transient. In either case you will need to
        get new instances when you get a new PM. You cannot continue using the
        old instances. So if you are displaying data (JDO instances) somewhere
        in your GUI (e.g. on a table) and you close the PM you will get errors
        at repaint.</para>

        <para>You can keep references to JDO instances for the lifetime of
        your application across many transactions. Different parts of your
        application may share references freely. This simplifies GUI
        programming as you do not have to propagate new references everywhere.</para>

        <para>Versant Open Access does not support multithreaded access to a
        PM or managed JDO instances (this is an optional and not widely
        implemented JDO feature) for performance reasons. You must take care
        to do all your work on the PM or instances created from it on the
        <classname>EventDispatchThread</classname>. If you need to perform a
        long running task using a background thread you must obtain another PM
        for that task and close it when done. Remember that you cannot share
        objects between PMs. If you need to access an instance belonging to
        one PM (pm1) with another (pm2), get its ID using
        <classname>pm1.getObjectId(pc)</classname> and look it up again using
        <classname>pm2.getObjectById(oid, true)</classname>.</para>

        <para>It is convenient to store the PM for the GUI application using a
        ThreadLocal managed by a singleton (see <xref
        linkend="web_starting_server" />). This makes the PM accessible from
        any code in your application without having to pass it around.
        <emphasis>The same code can be used without change in a multithreaded
        environment (e.g. in a web or EJB application)</emphasis>. The
        Testcenter demo in <filename>demos/testcenter</filename> uses this
        approach. The business operations are implemented by a service layer
        shared by the GUI and web implementations. The service layer uses the
        singleton <classname>Context</classname> class to obtain the PM for
        the current thread (i.e. the <classname>Thread</classname> for the
        request in the web app and the <classname>EventDispatchThread</classname>
        in the GUI app).</para>

        <para>It is important to remember that your applications main method
        is invoked on the &#34;main&#34; Thread and not the
        EventDispatchThread. Normally it is best to use
        <classname>SwingUtilities.invokeAndWait</classname> to switch to the
        <classname>EventDispatchThread</classname> before creating your main
        frame or other GUI elements. The following example is edited from
        <filename>demos/testcenter/src/za/co/hemtech/testcenter/gui/Main.java</filename>.<programlisting>public class Main implements Runnable {

    public static void main(String[] args) {
        try {
            Properties props = Context.loadJDOProperties();
            Context.initialize(props); <co id="tc_main1" />
            Main main = new Main();
            SwingUtilities.invokeAndWait(main); <co id="tc_main2" />
            if (main.error != null) throw main.error;
        } catch (Throwable e) {
            e.printStackTrace(System.out);
            System.exit(1);
        }
    }

    private Throwable error;

    public void run() { <co id="tc_main3" />
        try {
            MainFrame f = new MainFrame();
            f.setSize(400, 400);
            Dimension sz = f.getToolkit().getScreenSize();
            f.setLocation((sz.width - f.getWidth()) / 2,
                    (sz.height - f.getHeight()) / 2);
            f.setVisible(true);
            f.login();
        } catch (Throwable e) {
            error = e;
        }
    }

}</programlisting><calloutlist><callout arearefs="tc_main1"><para>Call
        Context.initialize to start the Versant Open Access server. This class
        uses JDOHelper.getPersistenceManagerFactory(Properties) to do this.</para></callout><callout
        arearefs="tc_main2"><para>Transfer to the EventDispatchThread and wait
        for the work to complete. This ensures that no JDO work is done on the
        main Thread.</para></callout><callout arearefs="tc_main3"><para>This
        method is invoked on the EventDispatchThread. It can safely use JDO
        APIs and work with managed JDO instances.</para></callout></calloutlist></para>
      </section>

      <section id="gui_many_pms">
        <title>One PM per Window or Task<indexterm><primary>GUI app many PMs</primary></indexterm></title>

        <para>This approach uses on PM per window or task. This is more
        difficult to work with and should be used with caution. The advantage
        is that changes made in different parts of your application can be
        committed or rolled back on their own. There are some disadvantages:</para>

        <orderedlist>
          <listitem>
            <para>Different windows cannot share data (JDO instances). They
            must exchange OIDs and relookup the instances.</para>
          </listitem>

          <listitem>
            <para>If different windows(PMs) are displaying the same data
            (instances for the same JDO identity) then they will not reflect
            each others changes. You will need to refresh (see <xref
            linkend="gui_local_cache" />) and may get concurrent update
            exceptions on commit.</para>
          </listitem>
        </orderedlist>

        <para>The recommended approach is to use one PM for the life of the
        application (<xref linkend="gui_one_pm" />) and only use extra PMs for
        special cases (e.g. a long running background task).</para>
      </section>
    </section>

    <section id="gui_local_cache">
      <title>PersistenceManager Settings<indexterm><primary>GUI app PM
      settings</primary></indexterm></title>

      <para>The JDO specification defines how instances managed by a single PM
      are cached. Versant Open Access and some other JDO implementations
      support an additional cache shared by all PMs created from the same PMF.
      This is often called a level 2 cache to distinguish it from the per PM
      or local cache. The local cache makes it possible to keep references to
      the same JDO instances across transaction boundaries. You can obtain a
      reference to a JDO instance (e.g. by navigating a reference, running a
      JDOQL query or by calling PM.getObjectById) and keep it for the life of
      the PM. The JDO runtime makes sure that the same Java instance is
      returned for the life of the PM.</para>

      <para>The level 2 cache can be thought of as a shared layer in front of
      the database to avoid database access. It does not have any effect on
      the lifecycle of JDO instances managed by a PM. However it does make
      some strategies more efficient as refreshing instances managed by a PM
      need not result in database access.</para>

      <para>The local cache feature of JDO is most useful when writing GUI
      applications as web and EJB applications typically carry as little state
      as possible between requests. However the local cache can be configured
      in various ways and some require that you manually refresh JDO instances
      to see changes committed by other PMs or by external applications.</para>

      <para>There are methods on PM to evict instances from the local cache to
      control memory usage. Versant Open Access keeps only soft references to
      instances in the local cache so it is not normally necessary to manually
      evict. Instances referenced only by Versant Open Access will be
      automatically released if memory is needed.</para>

      <para>The default settings for PMs created from a PMF can be set using
      the Project Properties dialog in the Workbench (<command>File | Project
      Properties</command>):</para>

      <para><inlinemediaobject><imageobject><imagedata
      fileref="images/local_cache_options.png" /></imageobject></inlinemediaobject></para>

      <para>You can also edit these options directly in the
      <filename>.properties</filename> project file (look for a block of
      <literal>javax.jdo.option.XXX</literal> entries) or control them on a
      per PM basis by calling <literal>PM.currentTransaction().setXXX</literal>
      methods.</para>

      <para>There are several different ways to configure and use a PM in a
      GUI application. The ones we have had most success with are described
      here. A full treatment of these options is beyond the scope of this
      manual. Please refer to one of the published JDO books or the
      specification itself. The main difference is in how JDO instances are
      refreshed to show changes made by other transactions. If a modified JDO
      instance is stale (i.e. has been changed since it was read) a
      <classname>VersantConcurrentUpdateException</classname> is thrown on
      commit.</para>

      <section id="gui_opt_tx_always">
        <title>Always Open Optimistic Tx<indexterm><primary>gui app always
        open opt tx</primary></indexterm></title>

        <para>The PM settings for this approach are as follows:</para>

        <para><programlisting>javax.jdo.option.Optimistic=true
javax.jdo.option.IgnoreCache=true
.. all others false ...</programlisting></para>

        <para>The application must ensure that the PM always has an open
        optimistic transaction (see <xref linkend="optimistic_transactions" />).
        After every commit or rollback a new transaction must be started
        immediately. All managed JDO instances will be made hollow (fields not
        loaded) at each commit and rollback and will be refreshed when first
        touched after that. You should design your application so that commit
        (i.e. saving) is done often. One strategy to do this is to use modal
        dialogs with OK and cancel for editing. If the user hits OK do a
        commit. If they hit cancel do a rollback.</para>

        <para>You can still refresh JDO instances manually before editing by
        calling one of the PM.refresh methods.</para>

        <para>The Optimistic=true option means that no particular JDBC
        connection is associated with the PM. A (different) JDBC connection is
        obtained from the pool for each operation (e.g. JDOQL query or object
        lookup) and returned as soon as possible. No database locks are
        accumulated and the level 2 cache can be used.</para>

        <para>The IgnoreCache=true option indicates that uncommitted changes
        in the local cache can be ignored when running JDOQL queries. If this
        option is false then Versant Open Access must flush uncommitted
        changes to instances of classes involved in the query to the database
        before running the query. This is very undesirable as the JDBC
        connection used is pinned to the PM and accumulates database locks
        until commit or rollback. This option can also be set on a per query
        basis (Query.setIgnoreCache).</para>

        <para>This strategy is the easiest to implement as refresh happens
        automatically. However manually controlling refreshing as described in
        the next section may offer better performance.</para>
      </section>

      <section id="gui_non_tx_read">
        <title>Non-transactional reads<indexterm><primary>gui app
        non-transactional reads</primary></indexterm></title>

        <para>The PM settings for this approach are as follows:</para>

        <para><programlisting>javax.jdo.option.Optimistic=true
javax.jdo.option.IgnoreCache=true
javax.jdo.option.NontransactionalRead=true
.. all others false ...</programlisting></para>

        <para>With this approach a transaction is only started when an
        instance is about to be edited. All other data is read outside of a
        transaction. Instances must be manually refreshed using PM.refresh or
        PM.refreshAll to see changes made by other PMs and applications. In
        particular you will most likely want to refresh instances that are
        about to be edited after starting the tx.</para>

        <para>Note that doing a commit or rollback will only make
        transactional instances hollow. Instances read outside of the
        transaction and not modified in it will not become hollow and must be
        manually refreshed if needed.</para>

        <para>The Optimistic and IgnoreCache options function in the same way
        as described in <xref linkend="gui_opt_tx_always" />.</para>

        <para>This strategy may provide better performance as only modified
        and manually refreshed instances are updated from the database (or
        level 2 cache). However it increases the burden on the developer. The
        Testcenter demo (<filename>demos/testcenter</filename>) uses this
        approach.</para>
      </section>
    </section>

    <section id="gui_app_multiple_clients">
      <title>Multiple Clients<indexterm><primary>gui app multiple clients</primary></indexterm></title>

      <para>Running multiple instances of your GUI application against the
      same database is supported. However you must either disable the level 2
      cache or use remote persistence managers against a shared Versant Open
      Access server (and level 2 cache).</para>

      <section id="gui_app_disabling_caching">
        <title>Disabling Caching<indexterm><primary>gui app disabling caching</primary></indexterm></title>

        <para>With this model each client application runs its own Versant
        Open Access server connecting directly to the database using JDBC. The
        level 2 cache should be disabled (<command>File | Project Properties,
        Cache Tab</command>). If you leave it enabled you must turn off
        caching for the classes that may change or you must manually evict
        from the level 2 cache using the methods on <classname>VersantPersistenceManagerFactory</classname>.
        The manual eviction approach may be useful if you know when the data
        is changed (e.g. it is loaded at midnight from a mainframe).</para>

        <para>Normally the connection pool for each client must have max
        connections set to 2 or more. The max idle connections value can be
        set to 1. If the client is read only then only one connection will be
        used (assuming only one PM active at a time). Clients inserting new
        instances will normally need an extra connection for primary key
        generation. This extra released after the commit and will be closed if
        max idle connections is 1.</para>
      </section>

      <section id="gui_app_remote_pms">
        <title>Using Remote PMs<indexterm><primary>gui app remote PMs</primary></indexterm></title>

        <para>With this model each client connects to a shared Versant Open
        Access server running in another VM with its own level 2 cache. The VM
        running the Versant Open Access server is the only one with JDBC
        connections. There are no problems with using the level 2 cache. The
        remote <classname>PersistenceManagerFactory</classname>&#39;s used by
        the clients use RMI to communicate with the Versant Open Access
        server. This is all hidden from the client application which uses the
        normal JDO API (no code changes required).</para>

        <para>Note that the shared Versant Open Access server is just a normal
        <classname>PersistenceManagerFactory</classname> with remote access
        enabled. It does not have to be in a standalone application. The
        Testcenter demo in <filename>demos/testcenter</filename> uses a GUI
        client to connect to the same Versant Open Access server being used by
        the Struts web application. The same approach can be used with a
        Versant Open Access server running in an application server.</para>

        <para>There is more information on remote PMs elsewhere in this
        manual:</para>

        <itemizedlist>
          <listitem>
            <para>Remote Access: <xref linkend="remote_access" /></para>
          </listitem>

          <listitem>
            <para>Value Object Transfers: <xref linkend="using_remote_pm" /></para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section id="java_web_start">
      <title>Java Web Start<indexterm><primary>java web start</primary></indexterm><indexterm><primary>web
      start</primary></indexterm></title>

      <para>Versant Open Access applications deployed using Java Web Start
      must be signed. In addition hyperdrive classes must be generated at
      enhancement time (or disabled). Versant Open Access generates a
      significant portion of the implementation at runtime to match the
      persistent classes - these generated classes are named
      <filename>HYPERDRIVE_*</filename>. The performance gain from this
      technology is very significant. To create the classes at runtime Versant
      Open Access must create and use a ClassLoader and this causes security
      problems with Web Start.</para>

      <para>To generate the hyperdrive classes at enhancement time add the
      genhyper attribute to your <literal>jdo-enhance</literal> task (see
      <xref linkend="task_jdo_enhance" />) call:</para>

      <programlisting>&#60;jdo-enhance ... genhyper=&#34;true&#34; ...&#62;</programlisting>

      <para>You need to make sure that your build file deletes and regenerates
      these classes if any of your <filename>.jdo</filename> meta data files
      or <filename>.properties</filename> project file change. Note that this
      includes simple changes like selecting a different database type
      (oracle, mysql, sybase etc.). This also means that your deployed Web
      Start application will only be able to work with the database it was
      compiled for.</para>

      <para>You can also disable hyperdrive classes (hyperdrive=false) in the
      .properties file or using <command>File | Project Properties</command>
      in the Workbench.</para>
    </section>
  </chapter>

  <chapter id="ejb_applications">
    <title>EJB Applications<indexterm><primary>session beans</primary></indexterm><indexterm><primary>message
    driven beans</primary></indexterm><indexterm><primary>stateful session
    beans</primary></indexterm><indexterm><primary>EJB applications</primary></indexterm></title>

    <para>This chapter describes how to use JDO in a J2EE application server
    from session and message driven beans (see <xref
    linkend="jdo_tutorial_session_bean" /> for an example).</para>

    <section id="j2ee_deployment">
      <title>Deploying the JCA adapter<indexterm><primary>JCA adapter
      deployment</primary></indexterm></title>

      <para>Versant Open Access integrates into application servers using a
      JCA adapter. This is in the &#60;OPENACCESS_HOME&#62;/jca directory of
      the distribution:</para>

      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>File</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>openaccess.rar</entry>

              <entry>JCA adapter.</entry>
            </row>

            <row>
              <entry>openaccess-ds.xml</entry>

              <entry>JBoss deployment descriptor.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>The openaccess.rar file contains the following files:</para>

      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>File</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>META-INF/ra.xml</entry>

              <entry>Deployment descriptor.</entry>
            </row>

            <row>
              <entry>META-INF/weblogic-ra.xml</entry>

              <entry>WebLogic deployment descriptor.</entry>
            </row>

            <row>
              <entry>META-INF/ra-borland.xml</entry>

              <entry>Borland deployment descriptor.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>You need to add your license file to <filename>lib/openaccess.jar</filename>
      by executing the following command in the &#60;OPENACCESS_HOME&#62;
      directory:</para>

      <programlisting>jar uf lib/openaccess.jar -C license openaccess.license</programlisting>

      <para>The Versant Open Access runtime file (<filename>lib/openaccess.jar</filename>)
      should be on the system classpath of the application server. This has
      the least potential for frustrating application server classloader
      problems.</para>

      <para>Versant Open Access will start automatically the first time a
      component of your application looks up a PersistenceManagerFactory(PMF)
      using JNDI. The default JNDI name is <literal>versant</literal>. This
      can be changed by editing the deployment descriptors of the specific
      application server file.</para>

      <para>The PersistanceManagerFactory is created from properties loaded
      from a resource deployed in one of your application jar files with the
      name <filename>versant.properties</filename>. The name of this resource
      can be changed by setting the propertiesResource property in the
      <filename>ra.xml</filename> or in the application server specific
      descriptor file. You can also override properties from the resource in
      <filename>ra.xml</filename> or the application server specific
      descriptor file.</para>

      <para>If you have more than one application using Versant Open Access
      deployed to your application server then you will need to deploy
      multiple rar files each configured with a different JNDI name.</para>

      <para>Hot-redeployment is supported on application servers with that
      feature. The Open Access server is automatically shut down and restarted
      when the application is redeployed.</para>

      <section id="jboss_deployment">
        <title>JBoss 3.2.x<indexterm><primary>JBoss deployment</primary></indexterm><indexterm><primary>deployment
        on JBoss</primary></indexterm></title>

        <para>A JBoss service configuration file for the JCA adapter called
        <filename>openaccess-ds.xml</filename> is supplied in the jca
        directory of the distribution. Edit this to suit your application. You
        may want to change the JNDI name of the adapter or the pool settings.
        Copy it and <filename>openaccess.rar</filename> to the deploy
        directory (eg <filename>jboss-3.2.5/server/default/deploy</filename>)
        of the server to deploy the JCA adapter.</para>

        <para>Copy your JDBC driver jar(s) and <filename>lib/openaccess.jar</filename>
        to the lib directory of the server (e.g. <filename>jboss-3.2.5/server/default/lib</filename>).</para>
      </section>

      <section id="weblogic_deployment">
        <title>WebLogic 8.1<indexterm><primary>WebLogic deployment</primary></indexterm><indexterm><primary>deployment
        on WebLogic</primary></indexterm></title>

        <para>A WebLogic specific deployment descriptor is included in the
        <filename>&#60;OPENACCESS_HOME&#62;/jca/openaccess.rar</filename> file
        (<filename>META-INF/weblogic-ra.xml</filename>). Unjar the rar file
        and edit this to suit your application. You may want to change the
        JNDI name of the adapter or the pool settings. Edit other settings
        such as the name of the properties resource in <filename>ra.xml</filename>.</para>

        <para>Add your JDBC driver jar(s) and <filename>lib/openaccess.jar</filename>
        to the classpath of the server. You can do this by editing the
        start-up script for the server (e.g. <filename>startExampleServer.sh</filename>
        or <filename>startExampleServer.bat</filename>).</para>

        <para>The connector can be deployed in a extracted form or archived
        form. The WebLogic console (e.g. <literal>http://localhost:7001/console</literal>)
        will allow runtime updates of the descriptor file if the connector is
        deployed in extracted form. To deploy in extracted form unjar the rar
        to a directory with the name as the rar file in the deployment
        directory of the server (e.g. <filename>weblogic81/samples/domains/examples/applications/openaccess.rar/</filename>).
        To deploy unextracted just copy the rar file to the deployment
        directory ( e.g. <filename>weblogic81/samples/domains/examples/applications/</filename>).</para>
      </section>

      <section id="borland65_deployment">
        <title>Borland 6.5<indexterm><primary>Borland deployment</primary></indexterm><indexterm><primary>deployment
        on Borland</primary></indexterm></title>

        <para>A Borland specific deployment descriptor is included in the
        <filename>&#60;OPENACCESS_HOME&#62;/jca/openaccess.rar</filename> file
        (<filename>META-INF/ra-borland.xml</filename>). Unjar the
        <filename>&#60;OPENACCESS_HOME&#62;/jca/openaccess.rar</filename> file
        and edit this to suit your application. You may want to change the
        JNDI name of the adapter or the pool settings. Edit other settings
        such as the name of the properties resource in <filename>META-INF/ra.xml</filename>.</para>

        <para>Add your JDBC driver jar(s) and <filename>&#60;OPENACCESS_HOME&#62;/lib/openaccess.jar</filename>
        into the rar file or add it to the classpath of the server.</para>

        <para>The connector rar file can be deployed to the server by using
        the Borland Management Console tool, Before deployment make sure that
        the Connector Service is running on the partition where you are
        deploying to.</para>

        <para>Starting the Connector service from the Console:</para>

        <orderedlist>
          <listitem>
            <para>Expand the partition where connector rar will be deployed.</para>
          </listitem>

          <listitem>
            <para>Right-click on Connector Service and select Enable.</para>
          </listitem>

          <listitem>
            <para>Click Yes when prompted to restart the partition.</para>
          </listitem>
        </orderedlist>

        <para>The connector rar file can be deployed alone or as part of a
        application ear file.</para>

        <para>Deploying from the Console:</para>

        <orderedlist>
          <listitem>
            <para>Right-click on the partition where the connector rar or ear
            file will be deployed.</para>
          </listitem>

          <listitem>
            <para>Select (Deploy modules...) from the menu.</para>
          </listitem>

          <listitem>
            <para>In the Deployment Wizard select add.</para>
          </listitem>

          <listitem>
            <para>Select the rar or ear file that you want to deploy.</para>
          </listitem>

          <listitem>
            <para>Under Additional Options select Restart partitions on deploy
            (cold deploy).</para>

            <para>The rest of the options will vary on your specific
            circumstances.</para>
          </listitem>

          <listitem>
            <para>Select Next and Finish.</para>
          </listitem>
        </orderedlist>
      </section>

      <section id="websphere5_deployment">
        <title>WebSphere Application Studio Developer 5.1<indexterm><primary>WebSphere
        deployment</primary></indexterm><indexterm><primary>deployment on
        WebSphere</primary></indexterm></title>

        <para>Unjar the <filename>&#60;OPENACCESS_HOME&#62;/jca/openaccess.rar</filename>
        and delete the <filename>META-INF/ra-borland.xml</filename> and
        <filename>META-INF/weblogic-ra.xml</filename> files, these file are
        not required for WebSphere.</para>

        <para>Edit the <filename>META-INF/ra.xml</filename> file, Set the
        <filename>ForceConnectionMatching</filename> property to
        <filename>true</filename> for WebSphere.</para>

        <para>Copy the <filename>&#60;OPENACCESS_HOME&#62;/lib/openaccess.jar</filename>
        and your JDBC driver jar(s) to the rar file base directory.</para>

        <para>Jar up the directory structure.</para>

        <para>The openaccess.rar file virtual directory tree should now look
        like this:</para>

        <programlisting>&#60;openaccess.rar&#62;/
                META-INF/
                        /MANIFEST.MF
                        /ra.xml
                 openaccess.jar
                 &#60;JDBC_DRIVER&#62;.jar</programlisting>

        <para>Your openaccess.rar file is now ready to be imported into WASD:</para>

        <orderedlist>
          <listitem>
            <para>In WASD select the <command>J2EE</command> perspective.</para>
          </listitem>

          <listitem>
            <para>Right Click on <command>Connector Modules</command>.</para>
          </listitem>

          <listitem>
            <para>Select <command>Import | Import Connector Module...
            </command></para>
          </listitem>

          <listitem>
            <para>On the <command>Connector Import</command> pop up screen.
            Browse to the newly created openaccess.rar.</para>
          </listitem>

          <listitem>
            <para>Select the openaccess.rar and click <command>Finish</command>.</para>
          </listitem>
        </orderedlist>

        <para>The next step is to configure the server to use the connector:</para>

        <orderedlist>
          <listitem>
            <para>In WASD select the <command>J2EE</command> perspective.</para>
          </listitem>

          <listitem>
            <para>Under <command>Servers</command>, double click the server
            that you want the Connector to run on. If there are no servers
            configured create a new server, and then double click it.</para>
          </listitem>

          <listitem>
            <para>Select the <command>J2C</command> tab.</para>
          </listitem>

          <listitem>
            <para>Move down to the <command>Server Settings </command>
            section, and click <command>Add</command> at the
            <command>J2C Resource Adapters </command>.</para>
          </listitem>

          <listitem>
            <para>Select openaccess as the <command>Resource Adapter Name</command>.
            And click <command>OK </command>.</para>
          </listitem>

          <listitem>
            <para>Select openaccess in the <command>J2C Resource Adapters</command>
            view. And move to the <command>J2C Connection Factories</command>
            section.</para>
          </listitem>

          <listitem>
            <para>In the <command>J2C Connection Factories</command> section
            select <command>Add</command>.</para>
          </listitem>

          <listitem>
            <para>On the <command>Create Connection Factory</command> pop up
            screen, enter the <command>Name</command> property, and the
            <command>JNDI Name</command> (this will be the name that you will
            use to lookup OpenAccess). The rest of the settings can be
            configured as required.</para>
          </listitem>

          <listitem>
            <para>Move down to the <command>Resource Properties</command>
            section, and change the <command>ForceConnectionMatching</command>
            property to true.</para>
          </listitem>

          <listitem>
            <para>Save the server settings and close the tab.</para>
          </listitem>
        </orderedlist>
      </section>
    </section>

    <section id="sb_starting_server">
      <title>Obtaining the PMF<indexterm><primary>getting PMF in session bean</primary></indexterm><indexterm><primary>lookup
      PMF in session bean</primary></indexterm></title>

      <para>You should obtain a reference to the PMF in the setSessionContext
      or setMessageDrivenContext method of each EJB as shown in the following
      fragment from <filename>demos/tut1sb/src/tut1/Tut1EJB.java</filename>:</para>

      <programlisting>private SessionContext ctx;
private PersistenceManagerFactory pmf;

public void setSessionContext(SessionContext ctx) throws EJBException {
    this.ctx = ctx;
    try {
        Context ic = new InitialContext();
        pmf = (PersistenceManagerFactory) ic.lookup(&#34;versant&#34;);
    } catch (NamingException e) {
        throw new EJBException(e);
    }
}</programlisting>

      <para>The JNDI name used must match the configuration of the JCA
      adapter. The default is <literal>versant</literal>.</para>
    </section>

    <section id="sb_pm">
      <title>Working with PersistenceManager&#39;s<indexterm><primary>using PM
      in session bean</primary></indexterm></title>

      <para>You should obtain a PersistenceManager(PM) in each method that
      needs one and it must be closed at the end of the method in a finally
      block. The PMs are pooled by Versant Open Access much like JDBC
      connections are pooled. Here is an example of a remote method in a
      stateless session bean using container managed transactions. The PM is
      automatically enlisted in the transaction.</para>

      <programlisting>/**
 * Return all items in the catalog in description order.
 */
public List listItems() {
    Query q = null;
    PersistenceManager pm = pmf.getPersistenceManager();
    try {
        q = pm.newQuery(Item.class);
        q.setOrdering(&#34;description ascending&#34;);
        ArrayList ans = new ArrayList((Collection)q.execute());
        pm.retrieveAll(ans);        // make sure all fields are filled in
        pm.makeTransientAll(ans);   // must be done prior to serialization
        return ans;
    } catch (RuntimeException x) {
        x.printStackTrace();
        throw x;
    } finally {
        if (q != null) q.closeAll();
        pm.close();
    }
}</programlisting>

      <para>You can use datastore or optimistic transactions (see <xref
      linkend="optimistic" />). Optimistic transactions provide better
      concurrency and support the use of the PMF wide cache. Datastore
      transactions always bypass the cache as they must obtain database locks.
      Use optimistic transactions unless you cannot add a version or timestamp
      optimistic locking column to your tables or other applications may be
      modifying the same rows.</para>

      <section id="container_managed_tx">
        <title>Container Managed Transactions<indexterm><primary>container
        managed transactions</primary></indexterm></title>

        <para>The PersistenceManager(PM) is automatically enlisted in the
        transaction. The methods on PM.currentTransaction() will throw an
        exception if called. Each call to PMF.getPersistenceManager in the
        same transaction will return a handle to the same PM.</para>
      </section>

      <section id="bean_managed_tx">
        <title>Bean Managed Transactions<indexterm><primary>bean managed
        transactions</primary></indexterm></title>

        <para>If you call PMF.getPersistenceManager with no J2EE transaction
        active you will receive a handle for a PM that is not enlisted in any
        J2EE transaction. <emphasis>Each call outside of the J2EE transaction
        will return a handle to a different PM</emphasis>. You must use
        methods on PM.currentTransaction for transaction control and these
        transactions will be local transactions.</para>

        <para>If you call PMF.getPersistenceManager with a J2EE transaction
        active you will receive a handle to a PM that is enlisted in the
        transaction. <emphasis>Each call within the transaction will return a
        handle to the same PM</emphasis>. You should use the normal J2EE
        javax.transaction.UserTransaction (from the SessionContext) to mark
        transaction boundaries. If you call any methods on
        PM.currentTransaction for a PM enlisted in the J2EE transaction an
        exception is thrown.</para>
      </section>

      <section id="stateful_sb_bean_managed_tx">
        <title>Stateful Session Beans<indexterm><primary>stateful session
        beans</primary></indexterm></title>

        <para>The PersistenceManager(PM) may be used across business methods
        and may be stored in an instance variable of the bean. JDO instances
        may also be stored in instance variables and used across business
        methods. You should only use optimistic transactions (see <xref
        linkend="optimistic" />) as datastore transactions may hold database
        locks for a long time if a client disappears halfway through a
        transaction.</para>
      </section>
    </section>

    <section id="value_object_transfers">
      <title>Value Object Transfers<indexterm><primary>data transfer objects</primary></indexterm><indexterm><primary>value
      object transfers</primary></indexterm></title>

      <para>It is common practise in J2EE systems for a client to call a
      business method and receive a graph of value objects. These are modified
      and another business method is called to make changes to the model. This
      section describes the JDO standard way to do this and how Versant Open
      Access&#39;s remote persistence managers make this process much easier
      and more efficient.</para>

      <section id="returning_jdo_value_objects">
        <title>Returning JDO Instances as Value Objects<indexterm><primary>serialization</primary></indexterm><indexterm><primary>returning
        JDO instances</primary></indexterm></title>

        <para>Serializing and deserializing a JDO instance results in a graph
        of transient instances (value objects) i.e. JDO instances lose their
        association with the PersistenceManager(PM) when serialized. During
        serialization all non-transient persistent fields must be filled from
        the database. This may result in non-transactional reads if you return
        a JDO instance from a remote method without first making it transient.
        This is not recommended.</para>

        <para>If your model is highly connected, returning a JDO instance
        might bring in a large part of the database. This can be controlled by
        making some of your fields transient. However as transient fields are
        not persistent by default you will have to explicitly make them
        persistent in the meta data
        (persistence-modifier=&#34;persistent&#34;). You can also make the
        instance transient before serializing it by calling
        pm.makeTransientAll(pc). Only the fields filled at the time of the
        makeTransient call will be Serialized. You can navigate to individual
        fields to ensure they are fetched or use pm.retrieve(pc) to populate
        specific instances.</para>
      </section>

      <section id="updating_jdo_value_objects">
        <title>Updating JDO Instances from Value Objects<indexterm><primary>updating
        JDO instances</primary></indexterm></title>

        <para>You may need to update a JDO instance from a transient instance
        (value object) passed as a parameter to a remote method. The portable
        way to do this is to retrieve the JDO instance using a
        PersistenceManager(PM) and manually update its fields from the value
        object. The database will be updated when the transaction commits. It
        is best to use PM.getObjectById(oid) to get the JDO instance as this
        will check the PMF wide cache before going to the database. If you do
        not have an OID and cannot construct one you need to execute a query
        to retrieve the JDO instance based on a unique field. This is much
        slower than a simple OID lookup.</para>

        <para>If you are using datastore identity (see <xref
        linkend="object_identity" />) you will need to pass the OID back with
        the transient JDO instance. You can use a data transfer object or you
        can add it to a custom value object class along with the fields you
        need from the JDO instance. Using a layer of custom value objects
        decreases the coupling between the client side and server side at the
        cost of additional complexity and code.</para>

        <para>If you are using application identity (see <xref
        linkend="object_identity" />) you can construct an OID instance using
        your objectid-class and the primary key fields of the value object.
        Versant Open Access supports automatic key generation for application
        identity classes making this an attractive option. You get the ease of
        use of datastore identity but still have primary key fields in your
        classes for value object use.</para>

        <para>If your application only changes a few objects at a time then
        this process works well. If your application makes many changes across
        a large graph of objects, the code to retrieve and update all the
        corresponding JDO instances is very complex. The next section
        describes how you can use the JDO API on the remote client to avoid
        this problem.</para>
      </section>

      <section id="using_remote_pm">
        <title>Using Remote PersistenceManager&#39;s<indexterm><primary>remote
        PersistenceManager&#39;s</primary></indexterm></title>

        <para>Versant Open Access supports PersistenceManager&#39;s that are
        not in the same VM as the Versant Open Access server (see <xref
        linkend="remote_access" />). This feature can be used instead of doing
        value object transfers to make client-server communication much more
        efficient. The clients can use the full JDO API to retrieve and modify
        JDO instances. There is no need to serialize graphs of value objects
        between the client and the server. If loose coupling is required
        business logic classes and adapters can be used to manipulate the JDO
        instances instead of giving the client direct access. This is still
        much more efficient that serializing and diffing object graphs as JDO
        automatically tracks changes to JDO instances.</para>
      </section>
    </section>
  </chapter>

  <chapter id="architecture">
    <title>JDO Application Architecture<indexterm><primary>architecture</primary></indexterm></title>

    <para>This chapter describes traditional application architecture, how
    this can be simplified and improved using JDO and how to use Versant Open
    Access&#39;s remote persistence managers.</para>

    <section id="non_jdo_arch">
      <title>Non-JDO Architecture<indexterm><primary>non-JDO architecture</primary></indexterm></title>

      <para>Typical non-JDO applications using J2EE use an architecture
      similar to that shown below. The web tier and remote GUI clients use
      business delegate classes to perform business operations. These delegate
      to the session bean facade to do the work. The session beans interact
      with the data model through entity beans and/or data access objects.
      Normally, for performance reasons, a lot of data access is done through
      data access objects. These use hand coded JDBC calls or a proprietary
      object relational mapping framework to communicate with the database. In
      applications not using EJB the web tier uses the business delegate
      classes to directly implement the business logic using the data access
      objects.</para>

      <figure>
        <title>Non-JDO Architecture</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/arch_without_jdo.png" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>Correctly implemented this architecture provides good performance
      and cleanly separates business and presentation logic. However there is
      a great deal of complexity behind this simple diagram. A large number of
      extra classes and deployment descriptors have to be written and
      maintained just to support the environment. Each entity bean has a home
      interface, local interface, bean class and deployment descriptor
      information. In addition 10 EJB callback methods have to be written in
      the bean class. Each session bean involves developing a similar
      collection of interfaces, callbacks and deployment descriptors. Non of
      these classes can be tested outside of the container.</para>

      <para>Often many data access objects are used instead of the entity
      beans to improve performance. This adds more complexity to the
      application as either the developer must write tedious, error prone,
      JDBC code or a proprietary object relational mapping framework must be
      used. All of this complexity provides scope for costly mistakes.</para>
    </section>

    <section id="jdo_genie_architecture">
      <title>JDO Architecture<indexterm><primary>JDO architecture</primary></indexterm></title>

      <para>You can implement a very similar architecture using JDO as shown
      in the diagram below. The architecture retains most of the advantages of
      the traditional architecture but reduces the complexity and improves
      performance.</para>

      <figure>
        <title>Versant Open Access Architecture</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/arch_with_jdo_genie.png" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The business logic classes used by the web and gui tier implement
      business operations instead of delegating to session beans. They use the
      JDO API to query and ordinary Java code to manipulate JDO instances and
      the JDO runtime handles the persistence. They implement the logic
      required and do not delegate to session beans. The session bean facade
      is used to communicate only with loosely coupled external applications
      and should use the same business logic classes where possible. It should
      use its own data transfer objects (DTOs) and not expose model classes to
      external applications.</para>

      <para>Developer productivity is improved:</para>

      <itemizedlist>
        <listitem>
          <para>There are fewer classes and interfaces to write and maintain.</para>
        </listitem>

        <listitem>
          <para>There are no deployment descriptors.</para>
        </listitem>

        <listitem>
          <para>There is no JDBC code.</para>
        </listitem>

        <listitem>
          <para>It is easy to write unit tests for business logic and model
          classes as they are usable outside of an application server.</para>
        </listitem>

        <listitem>
          <para>JDO supports inheritance and handles primary key generation
          for you (unlike EJB 2.0).</para>
        </listitem>

        <listitem>
          <para>Client and server side code is written in exactly the same
          way. The business logic classes can run on the client and server
          side.</para>
        </listitem>

        <listitem>
          <para>The granularity of communication between the client and server
          VMs can be controlled without using data transfer objects.</para>
        </listitem>
      </itemizedlist>

      <para>Performance is improved:</para>

      <itemizedlist>
        <listitem>
          <para>All persistence managers share a common cache.</para>
        </listitem>

        <listitem>
          <para>There are no developer written SQL queries to debug and tune.</para>
        </listitem>

        <listitem>
          <para>You can monitor your application in real time using the
          Management Console in the Versant Open Access Workbench. This will
          tell you which are the slowest and most popular queries and you can
          create indexes and fetch groups to optimise your application.</para>
        </listitem>

        <listitem>
          <para>Only data required is fetched from the database and only
          fields modified in a transaction are updated (JDO transparent
          persistence). In addition Versant Open Access supports creation of
          extra fetch groups to fetch whole slices of your model in one go.
          These are especially useful for remote clients.</para>
        </listitem>

        <listitem>
          <para>The remote clients (e.g. Swing GUIs) use Versant Open
          Access&#39;s remote persistence managers (see <xref
          linkend="remote_access" />) to access the model. There is not need
          to do value object transfers between the VMs and diff object graphs.
          Exactly the same code runs on the client and the server.</para>
        </listitem>
      </itemizedlist>

      <para>The main disadvantage of this approach is that you lose the
      declarative security and transaction control offered by session beans.
      If this is an issue in your application then you can put the business
      logic classes behind session beans and use business delegates. The
      business logic classes can still be tested and debugged outside of the
      container. This can be transparent to the client if the business
      delegate and business logic classes implement a common business
      interface. You can also use the EJB command pattern<footnote><para>Page
      18 of &#34;EJB Design Patterns&#34; by Floyd Marinescu (ISBN:
      0-471-20831-0).</para></footnote>by using your business logic classes as
      commands and sending them to a command processor session bean to
      execute.</para>

      <para>On very large projects you may want to have a more loosely coupled
      interface between your domain model and the web and GUI tiers. This can
      be achieved by using value objects to communicate with the business
      logic classes instead of JDO instances (i.e. Instances of your model
      classes). The important thing is that this decision is not forced on you
      by the environment and you can still test everything outside of the
      container.</para>
    </section>
  </chapter>

  <chapter userlevel="versant" id="vds">
    <title>Versant ODBMS<indexterm><primary>Versant ODBMS</primary></indexterm><indexterm><primary>VDS</primary></indexterm></title>

    <para>If using Versant Open Access with the Versant object database then
    Versant Open Access communicates directly with the database over network
    socket connections. In this respect Versant Open Access is quite different
    from Versant&#39;s standard Java interface (JVI) that used JNI to
    interface to Versant&#39;s &#39;C&#39; client libraries. Versant Open
    Access is 100% Java and can be run anywhere that a JDK 1.4 or above JVM is
    available, there is no need to install any additional software other than
    Versant Open Access. This chapter provides details on using JDO with the
    Versant object database.</para>

    <section id="vds_connections">
      <title>Managing Connections</title>

      <para>The Database connections can be configured via standard JDO
      properties. As a minimum, the <literal>javax.jdo.option.ConnectionURL</literal>
      property must be specified to indicate the name of the database to be
      connected to. Additional properties can be specified, but are not
      required.</para>

      <para>Required properties:</para>

      <itemizedlist>
        <listitem>
          <para><literal>javax.jdo.option.ConnectionURL</literal>: The name of
          the database to connect to.</para>

          <para>The URL should be of the form: <literal>versant:database[@host][:port]</literal></para>

          <para>Where <literal>host</literal> and <literal>port</literal> are
          optional.</para>

          <itemizedlist>
            <listitem>
              <para><literal>database</literal>: This is the name of the
              database.</para>
            </listitem>

            <listitem>
              <para><literal>host</literal>: This is the host name of the
              database server. If not specified then it is assumed to be
              <literal>localhost</literal>.</para>
            </listitem>

            <listitem>
              <para><literal>port</literal>: This is the port to be used to
              establish a connection to the database. If not specified it
              defaults to <literal>5019</literal>, which is the port typically
              used by Versant.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <para>Optional properties:</para>

      <itemizedlist>
        <listitem>
          <para><literal>javax.jdo.option.ConnectionUserName</literal>: This
          is the user name used when connecting to the database. If no user
          name is specified then the OS user name is used.</para>
        </listitem>

        <listitem>
          <para><literal>javax.jdo.option.ConnectionPassword</literal>: This
          is the password for the above user. If no password is specified then
          it is assumed a password has not been set for the user.</para>
        </listitem>

        <listitem>
          <para><literal>versant.maxActive</literal>: an integer number
          denotes maximum number of active connections to backend datastore
          server. Default value is <literal>10</literal></para>
        </listitem>

        <listitem>
          <para><literal>versant.maxIdle</literal>: an integer number<firstterm>
          </firstterm>denotes maximum number of idle connections to backend
          datastore server. Default value is <literal>3</literal></para>
        </listitem>

        <listitem>
          <para><literal>versant.retryCount</literal>: an integer number
          denotes maximum number of attempts to obtain a connection from the
          pool when all other connections are busy. Default value is
          <literal>30</literal></para>
        </listitem>

        <listitem>
          <para><literal>versant.retryIntervalMs</literal>: an integer number
          denotes time interval in milisecond between attempts to obtain a
          connection from the pool when all other connections are busy.
          Default value is <literal>1000</literal></para>
        </listitem>

        <listitem>
          <para><literal>versant.vdsOidBatchSize</literal>: This property
          configures the number of logical object ids (LOIDs) reserved by the
          database when requesting LOIDs. Every transaction consumes a LOID,
          every new object requires a LOID. LOIDs are reserved in batches and
          when consumed a new batch is automatically requested. A large batch
          size may result in LOIDs being wasted if they are not ultimately
          used whilst a small batch size will result in lots of network
          requests if many LOIDs are required. The default value is 1024.</para>
        </listitem>

        <listitem>
          <para><literal>versant.vdsSchemaDefine</literal>: a boolean flag (<literal>true</literal>
          or <literal>false</literal>) denotes whether new schema classes will
          be defined if needed at runtime. Default value for the flag is
          <literal>true</literal> i.e. new schema will be defined at runtime
          for Java classes if required.</para>
        </listitem>

        <listitem>
          <para><literal>versant.vdsSchemaEvolve</literal>: a boolean flag (<literal>true</literal>
          or <literal>false</literal>) denotes whether datastore schema be
          evolved if required. The datastore schema for all known persistence
          capable Java classes are defined or verified against the datastore
          at initialization. If Java class definitions have changed then
          datastore schema needs to be evolved. Default value for the flag is
          <literal>false</literal> i.e. schema will not be evolved in case of
          mismatch.</para>
        </listitem>
      </itemizedlist>

      <example id="vds_builtin_ex">
        <title>Properties File for the Versant Object Database</title>

        <programlisting>
javax.jdo.option.ConnectionUserName=username
javax.jdo.option.ConnectionPassword=password
javax.jdo.option.ConnectionURL=versant:db2@host2:5026 </programlisting>
      </example>
    </section>

    <section id="vds_namingpolicy">
      <title>Naming Policy</title>

      <para>Using Open Access, classes/fields in the database can be named
      differently than their Java names. How the schema classes/fields are
      named is based on</para>

      <itemizedlist>
        <listitem>
          <para><literal>versant.vdsNamingPolicy</literal> : name of a policy
          that determines the name mapping. A policy name is effectively name
          of a class that implements <literal>com.versant.core.vds.NamingPolicy</literal>
          interface.</para>

          <para>Following policies have been pre-built.</para>

          <itemizedlist>
            <listitem>
              <para><literal>brief</literal>: This default policy strips of
              the package name from Java class names e.g. com.acme.org.Person
              class will be stored in the database as Person. This is the
              deafult behaviour.</para>

              <para></para>
            </listitem>

            <listitem>
              <para><literal>none</literal>: This policy retains fully
              qualified Java names in the database schema.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <para></para>
    </section>

    <section id="vds_locking">
      <title>Locking</title>

      <section id="vds_locking_p">
        <title>Pessimistic Locking Protocol</title>

        <para>The pessimistic locking protocol uses shared and exclusive locks
        to control concurrent access to objects. The shared lock is often
        referred to as a &#34;read lock&#34; and the exclusive lock is often
        referred to as a &#34;write lock&#34;. A pessimistic locking protocol
        guarantees that only one transaction can be modifying a particular
        object at a given point in time and that whilst it is being modified
        that no other transaction may access it.</para>

        <para>When an object is first retrieved from the database within a
        datastore transaction then a read lock is taken out on the object.
        This shared lock allows other transactions to also read the object but
        will block a transaction that tries to get an exclusive lock on the
        object. The request for the exclusive lock will be queued waiting for
        any read locks to be released.</para>

        <para>When an object is dirtied the read lock on the object is
        upgraded to a write lock. If there are other transactions that have
        also have read locks on the object then this upgrade request will be
        queued waiting for the read locks to be released. Once a transaction
        has a write lock on an object it will block any other transactions
        from reading the object until the transaction commits or rolls back.</para>

        <para>The Versant object database automatically detects deadlock
        conditions within a database (where two transactions are each blocked
        waiting for the other to release a lock) and will also time out lock
        requests after the configured period of time. See the Versant
        documentation for more details on this.</para>
      </section>

      <section id="vds_locking_o">
        <title>Optimistic Locking Protocol</title>

        <para>The optimistic locking protocol uses the same shared and
        exclusive locks as the pessimistic locking protocol but it holds them
        for much shorter periods of time. This has the benefit that it can
        improve the concurrency of an application because there will be less
        blocking waiting for locks to be released. However, because locks are
        not held for the duration of an application it is possible for
        multiple transactions to be modifying the same object at the same
        time. It is therefore necessary to additionally check if an object has
        been modified by another transaction prior to committing any changes
        to a database.</para>

        <para>If using optimistic transactions then when an object is first
        retrieved within a transaction a read lock is used but is released
        once the object has been read. This ensures that the object being read
        is transactionally consistent at the time it was read (sometimes
        referred to as a snapshot read). Unlike the pessimistic locking
        protocol, when an object is dirtied there is no lock upgrade request.
        This means that once read, an object can be modified by multiple
        optimistic transactions at the same time (or even by another datastore
        transaction).</para>

        <para>To ensure transactional consistency, when an optimistic
        transaction is committed any dirtied objects are checked to ensure
        that another transaction hasn&#39;t modified them since they were
        first read. If not then the transaction completes successfully. If
        there have been conflicting updates then an exception is thrown and
        the transaction is rolled back. The Versant object database uses a
        timestamp mechanism to determine if an object has been modified by
        another transaction.</para>
      </section>
    </section>

    <section id="vds_schema">
      <title>Schema Information</title>

      <para>Before the instances of a persistence capable class can be stored
      in a database, a schema for the persistence capable class must first be
      defined in the database. This can be done in the following ways:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis role="strong">Static Schema Definitition</emphasis>:</para>

          <para>Schema Tool is a command line utility that can define database
          schema for a given set of enhanced Java classes. This is the
          recommended approach when deploying an application. The usage of
          this Schema Tool is described later in this chapter.</para>
        </listitem>

        <listitem>
          <para><emphasis role="strong">Dynamic Schema Definition</emphasis></para>

          <para>As an instance enters JDO managed runtime environment (for
          example, as an argument of <literal>makePersistent()</literal>), the
          datastore schema for the class of this instance must be available.
          If the schema is not defined already then it will be defined at
          runtime. This dynamic schema definition at runtime can be controlled
          by a boolean in property <literal>versant.vdsSchemaDefine</literal>.
          It is <literal>true</literal> by default.</para>

          <para>This is great when developing an application but recommended
          to be set to <literal>false</literal> during application deployment.</para>

          <note>
            <para>Dynamic Schema Definition process is not thread-safe. So
            please make sure that multiple user threads are not trying to
            define the schema for the same classes simultaneously.</para>
          </note>

          <para></para>

          <note>
            <para>Of course it is not possible to execute a query or get an
            extent for a class until a class has been defined. If an
            application first tries to perform one of these operations before
            having persisted any instances it will get an exception. In this
            case classes should be explicitly defined in the database
            beforehand.</para>

            <para></para>
          </note>
        </listitem>

        <listitem>
          <para><emphasis>Dynamic Schema Evolution</emphasis></para>

          <para>If the Java class definitions have changed for classes that
          are already defined in the database then the schema must be evolved
          before the Java classes can be used by the application. A boolean
          property <literal>versant.vdsSchemaEvolve</literal> controls this
          behaviour at runtime. This feature is set to <literal>false</literal>
          by default. Again, the recommended approach to evolve the schema is
          using Schema Tool with the modified Java classes.</para>
        </listitem>
      </itemizedlist>

      <section id="vds_defineschema">
        <title>Schema Tool</title>

        <para>Schema Tool is a command-line based utility program to define,
        compare or modify Versant schema given one or more enhanced Java
        classes with their metadata resources.</para>

        <para>Schema Tool is invoked through the <literal>schematool</literal>
        shell/bat script included in the Open Access distribution, or by
        executing a Java class, <classname>com.versant.core.vds.tools.jdo.SchemaTool</classname>.</para>

        <para>The tool is invoked as <programlisting>
              java com.versant.core.vds.tools.jdo.SchemaTool [options]
              </programlisting></para>

        <para>where <literal>mandatory options</literal> are:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis role="strong"> <literal>-a or -action</literal>
            </emphasis></para>

            <para>specifies the action to be performed. Allowed values are
            <literal>define</literal> or <literal>compare</literal> or
            <literal>evolve</literal>.</para>

            <para><literal>define</literal> will define all the domain classes
            found in the metadata and verify if the classes exist. In case of
            any mismatch between the specified classes and existing classes in
            the database, no changes will be made to the database schmea. A
            report is printed for all the differences found between domain
            classes as defined by the metadata and existing database schema.</para>

            <para><literal>compare</literal> will simply report any
            differences between domain classes as defined by the metadata and
            existing database schema. No database changes are made.</para>

            <para><literal>evolve</literal> will modify the database schema
            according to the domain classes as defined in the metadata. This
            evolution may incur renaming fields, changing field types,
            readjusting inheritance hierarchy etc.</para>
          </listitem>

          <listitem>
            <para><literal>-p or -properties</literal>:</para>

            <para>Specifies a Open Access project properties file. The
            <literal>*.jdo</literal> metadata files specified in this project
            file will be used to locate all the persistence capable domain
            classes to defined, compared or evolved according to the
            <literal>-action</literal> flag settings.</para>
          </listitem>

          <listitem>
            <para><literal>-cp or -classpath</literal></para>

            <para>Specifies the classpath to load domain classes. The tool
            requires the domain classes to be enhanced a priori. If no
            classpath is specified, then the enhanced domain classes are
            looked in the classpath used to invoke the tool itself. Otherwise
            settings of this flag is appended to the existing classpath for
            loading the enhanced domain classes.</para>
          </listitem>

          <listitem>
            <para><literal>-out</literal>:</para>

            <para>Specifies an output file. Defaults to standard output.</para>
          </listitem>

          <listitem>
            <para><literal>-v or -verbose</literal>:</para>

            <para>Prints additional information about the classes being
            defined.</para>
          </listitem>

          <listitem>
            <para><literal>-h or -? or -help</literal>:</para>

            <para>Prints the help message on the standard output.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section id="usage_examples">
        <title>Usage Example</title>

        <para>The following are some examples of the usage of Schema Tool.</para>

        <example id="vds_defineschema_create">
          <title>Schema Creation</title>

          <para></para>

          <programlisting>schematool -action define -p versant.properties</programlisting>

          <para>This property file will be loaded as a resource, i.e. if it is
          not located in current directory, classpath will be searched. All
          the classes specified in .jdo resources (jdo meta data) of this
          property file will be defined in the datastore, which is specified
          as <literal>javax.jdo.option.ConnectionURL</literal> in the
          properties file.</para>
        </example>

        <example id="vds_evolve">
          <title>Schema Evolution</title>

          <para>The Versant object database has the ability to evolve schema
          definitions and migrate instances of an existing class version using
          the <literal>-action evolve</literal> option of the SchemaTool.</para>

          <para>The following are the Schema Evolution operations :</para>

          <itemizedlist>
            <listitem>
              <para>Addition of an attribute to a class and all subclasses.</para>
            </listitem>

            <listitem>
              <para>Removal of an attribute from a class and all subclasses.</para>
            </listitem>

            <listitem>
              <para>Changing the field type of an attribute in a class.</para>
            </listitem>

            <listitem>
              <para>Addition of a subclass to a class.</para>
            </listitem>

            <listitem>
              <para>Addition of a superclass to an inheritance tree.</para>
            </listitem>

            <listitem>
              <para>Removal of a superclass from an inheritance tree.</para>
            </listitem>
          </itemizedlist>

          <para><emphasis role="strong">I) The actions which modify the class
          signature are Adding, Deleting fields or Changing field types.</emphasis></para>

          <para>Let us take <literal>modelA</literal> with classes Person,
          Employee and Address with definitions as :</para>

          <programlisting>
                      class Person {
                         String name;
                       }
                       class Employee {
                         float salary;
                       }
                       class Address {
                         String street;
                         String city;
                         String zip;
                        }

              // This is the metadata for <literal>modelA</literal> &#60;jdo&#62;
               &#60;package name=&#34; modelA&#34;&#62;
               &#60;class name=&#34;Address&#34;/&#62;
               &#60;class name=&#34;Person&#34;/&#62;
               &#60;class name=&#34;Employee&#34;/&#62;
               &#60;/package&#62;
               &#60;/jdo&#62;

      </programlisting>

          <para>Assume that this jdo package is captured as a resource in a
          properties file called, &#34;versant.properties&#34;.</para>

          <para>To define this model <literal> <literal>modelA</literal>
          </literal>, invoke the SchemaTool with <literal>-action define</literal>
          option as follows:</para>

          <programlisting> schematool -action define -p versant.properties </programlisting>

          <para>This will pickup all the .jdo resources(metadata file
          locations) from the the properties file and define their
          corresponding classes.</para>

          <para><note><para>The db2tty tool is used to view the contents of
          the database specified. You can verify the class definitions using</para></note></para>

          <programlisting>
                      <literal>db2tty -D &#60;database&#62; -s</literal>
                  </programlisting>

          <para><emphasis role="strong">A) Adding an attribute:</emphasis></para>

          <para>Let us now change <literal>modelA</literal> defined above to
          <literal>modelB</literal> where a new field <literal>age</literal>
          is added to Person and new field <literal>address</literal> of type
          <literal>Address</literal> is added to Employee. This will result in
          the following definition:</para>

          <programlisting>
                      class Person {
                         String name;
                         int    age;   // New field added
                       }
                        class Employee  {
                          float salary;
                          Address address; // New field added
                       }
                       class Address {
                         String street;
                         String city;
                         String zip;
                       }


                // This will be the metadata for <literal>modelB</literal> &#60;jdo&#62;
                   &#60;package name=&#34; modelB&#34;&#62;
                    &#60;class name=&#34;Address&#34;/&#62;
                    &#60;class name=&#34;Person&#34;/&#62;
                    &#60;class name=&#34;Employee&#34;/&#62;
                    &#60;/package&#62;
                    &#60;/jdo&#62;</programlisting>

          <para>The original class definition and instances in
          <literal>modelA</literal> can now be evolved according to the
          modified definition as in <literal>modelB</literal>.</para>

          <para>To evolve the schema invoke the SchemaTool as:</para>

          <programlisting> schematool -action evolve <literal>-p versant.properties</literal></programlisting>

          <para>This command will add a new field <literal>age</literal> to
          <literal>Person</literal>. It will also add a new field
          <literal>address</literal> to <literal>Employee</literal>.</para>

          <para>Invoke <literal>db2tty -D &#60;database&#62; -s</literal> to
          see the fields added in the schema definition</para>

          <programlisting>

                  ====== CLASS `Person&#39; ======
                      [no superclasses]
                      attributes:
                        o_ts_timestamp                 :  o_4b
                        name                           :  char[]
                        name#null                      :  o_bool
                        age                            :  o_4b


                  ====== CLASS `Employee&#39; ======
                      [no superclasses]
                      attributes:
                        o_ts_timestamp                 :  o_4b
                        salary                         :  o_float
                        address                        -&#62; Address
                  </programlisting>

          <para><note><para>Adding a field to a superclass will add it to all
          its subclasses</para></note></para>

          <para><emphasis role="strong">B) Removing an attribute:</emphasis></para>

          <para>Let us now change the original model <literal>modelA</literal>
          defined above in I to <literal>modelB</literal> where an existing
          attribute <literal>zip</literal> is removed from Address. This will
          result in the following definition:</para>

          <programlisting>
                      class Person {
                         String name;
                       }
                        class Employee  {
                          float salary;
                       }
                       class Address {
                         String street;
                         String city;
                         // remove field String zip;
                       }

              //The metadata will be same as above
              </programlisting>

          <para>The original class definition and instances in
          <literal>modelA</literal> can now be evolved according to the
          modified definition as in <literal>modelB</literal>.</para>

          <para>To evolve the schema invoke the SchemaTool as:</para>

          <programlisting> schematool -action evolve <literal>-p versant.properties</literal></programlisting>

          <para>This command will remove the field <literal>zip</literal> from
          <literal>Address</literal>. Invoke <literal>db2tty -D
          &#60;database&#62; -s</literal> to see the field removed in the
          schema definition.</para>

          <para><note><para>Removing a field from a superclass will remove it
          from all its subclasses.</para></note></para>

          <para><emphasis role="strong">C) Changing the data type of an
          attribute</emphasis></para>

          <para>Let us now change the original model <literal>modelA</literal>
          to <literal>modelB</literal> where we change the data type of an
          existing <literal>salary</literal> field in <literal>Employee</literal>
          to from <literal>float</literal> to <literal>int</literal><literal></literal>.
          This will result in the following definition:</para>

          <programlisting>

                   class Person {
                         String name;
                        }
                        class Employee {
                          int salary; // data  type changed for this field
                       }
                       class Address {
                         String street;
                         String city;
                         String zip;
                       }


                    // The metadata will be same as above

              </programlisting>

          <para>The original class definition and instances in
          <literal>modelA</literal> can now be evolved according to the
          modified definition as in <literal>modelB</literal>.</para>

          <para>To evolve the schema invoke the SchemaTool as:</para>

          <programlisting> schematool -action evolve <literal>-p versant.properties</literal></programlisting>

          <para>This command will change the data type of field
          <literal>salary</literal> from float to int in <literal>Employee</literal>.
          Invoke <literal>db2tty -D &#60;database&#62; -s</literal> to see the
          changed field in the schema definition.</para>

          <programlisting>

                      ====== CLASS `Employee&#39; ======
                      [no superclasses]
                      attributes:
                        o_ts_timestamp                 :  o_4b
                        salary                         :  o_4b
                  </programlisting>

          <para><warning><para>The values for the attributes with the old data
          type would be lost permanently and the same attribute will now show
          the default values for the new data type.</para></warning></para>

          <para><emphasis role="strong">II) The actions which modify the
          inheritance hierarchy of a class are adding, removing or changing
          the superclass. </emphasis></para>

          <para>Let us redefine <literal>modelA</literal> :</para>

          <programlisting>

               class Person {
                 String name;
               }

              // This is the metadata for <literal>modelA</literal> &#60;jdo&#62;
               &#60;package name=&#34; modelA&#34;&#62;
                &#60;class name=&#34;Person&#34;/&#62;
                &#60;/package&#62;
               &#60;/jdo&#62;</programlisting>

          <para>To define this model <literal> <literal>modelA</literal>
          </literal>, invoke the SchemaTool with <literal>-action define</literal>
          option as follows:</para>

          <programlisting> schematool -action define <literal>-p versant.properties</literal> </programlisting>

          <para>This will define all classes mentioned in <literal>
          <literal>modelA</literal>\package.jdo</literal> to the database.</para>

          <para>You can verify the definitions using <literal>db2tty -D
          &#60;database&#62; -s</literal></para>

          <para><emphasis role="strong">A) Adding a Subclass:</emphasis></para>

          <para>Let us now change the <literal>modelA</literal> defined above
          in II to <literal>modelB</literal>, where we add a subclass Employee
          to Person. This will result in the following definition:</para>

          <programlisting>

                  class Person {
                       String name;
                     }

                     class Employee extends Person { // new subclass added
                      float salary;
                     }
                // This will be the metadata for <literal>modelB</literal> &#60;jdo&#62;
                   &#60;package name=&#34; modelB &#34;&#62;
                    &#60;class name=&#34;Person&#34;/&#62;
                      &#60;class name=&#34;Employee&#34;
                     persistence-capable-superclass=&#34;Person&#34;&#62;
                   &#60;/class&#62;
                      &#60;/package&#62;
                              &#60;/jdo&#62;</programlisting>

          <para>The original class definition and instances in
          <literal>modelA</literal> can now be evolved according to the
          modified definition as in <literal>modelB</literal>.</para>

          <para>To evolve the schema invoke the SchemaTool as:</para>

          <programlisting> schematool -action evolve -p versant.properties<literal></literal></programlisting>

          <para>This command will add the subclass Employee to the class
          Person. Invoke <literal>db2tty -D &#60;database&#62; -s</literal> to
          see the subclass added in the schema definition.</para>

          <programlisting>
                  ====== CLASS `Person&#39; ======
                  [no superclasses]
                  attributes:
                    o_ts_timestamp                 :  o_4b
                    name                           :  char[]
                    name#null                      :  o_bool


                  ====== CLASS `Employee&#39; ======
                  superclasses:
                      `Person&#39;
                  attributes:
                    o_ts_timestamp                 :  o_4b
                    name                           :  char[]
                    name#null                      :  o_bool
                    salary                         :  o_4b

                  </programlisting>

          <para><emphasis role="strong">B) Adding a Superclass:</emphasis></para>

          <para>Let us now change the <literal>modelA</literal> defined in II
          above to <literal>modelB</literal> where we add a superclass
          AbstractPerson to Person. This will result in the following
          definition:</para>

          <programlisting>
                       class AbstractPerson {
                             char gender;
                             Date dateOfBirth;
                           }

                         class Person extends AbstractPerson {
                           String name;
                         }


                //This will be the metadata for <literal>modelB</literal> &#60;jdo&#62;
                &#60;package name=&#34; modelB &#34;&#62;
                  &#60;class name=&#34;AbstractPerson&#34;/&#62;
                  &#60;class name=&#34;Person&#34;
                     persistence-capable-superclass=&#34;AbstractPerson&#34;&#62;
                   &#60;/class&#62;
                &#60;/package&#62;
                &#60;/jdo&#62;	</programlisting>

          <para>The original class definition and instances in
          <literal>modelA</literal> can now be evolved according to the
          modified definition as in <literal>modelB</literal>.</para>

          <para>To evolve the schema invoke the SchemaTool as:</para>

          <programlisting> schematool -action evolve <literal>-p versant.properties</literal></programlisting>

          <para>This command will add the superclass AbstractPerson to the
          class Person. Invoke <literal>db2tty -D &#60;database&#62; -s</literal>
          to see the superclass added in the schema definition.</para>

          <programlisting>
                  ====== CLASS `Person&#39; ======
                  superclasses:
                      `AbstractPerson&#39;
                  attributes:
                    o_ts_timestamp                 :  o_4b
                    dateOfBirth                    :  o_timestamp
                    dateOfBirth#null               :  o_bool
                    gender                         :  o_u2b
                    name                           :  char[]
                    name#null                      :  o_bool


                  ====== CLASS `AbstractPerson&#39; ======
                  [no superclasses]
                  attributes:
                    o_ts_timestamp                 :  o_4b
                    dateOfBirth                    :  o_timestamp
                    dateOfBirth#null               :  o_bool
                    gender                         :  o_u2b

                  </programlisting>

          <para><note><para>The superclass fields in <literal>AbstractPerson</literal>
          will be inherited in <literal>Person</literal> and all its
          subclasses.</para></note></para>

          <para><emphasis role="strong">C) Removing a Superclass</emphasis></para>

          <para>Let us redefine <literal>modelA</literal> to consist of
          classes Person and Employee</para>

          <programlisting>
                  class Person {
                       String name;
                     }

                     class Employee extends Person {
                      float salary;
                     }

                    // This will be the metadata for <literal>modelA</literal> &#60;jdo&#62;
                           &#60;package name=&#34; modelA &#34;&#62;
                            &#60;class name=&#34;Person&#34;/&#62;
                      &#60;class name=&#34;Employee&#34;
                         persistence-capable-superclass=&#34;Person&#34;&#62;
                       &#60;/class&#62;
                            &#60;/package&#62;
                            &#60;/jdo&#62;</programlisting>

          <para>Let us now change the modelA defined above to
          <literal>modelB</literal> where we remove the superclass Person.
          This will result in the following definition:</para>

          <programlisting>
                     class Employee  {
                      float salary;
                     }

                  //This is the metadata for <literal>modelB</literal>&#60;jdo&#62;
                  &#60;package name=&#34; modelB &#34;&#62;
                  &#60;class name=&#34;Employee&#34;/&#62;
                  &#60;/package&#62;
                  &#60;/jdo&#62;
                  </programlisting>

          <para>The original class definition and instances in
          <literal>modelA</literal> can now be evolved according to the
          modified definition as in <literal>modelB</literal>.</para>

          <para>To evolve the schema invoke the SchemaTool as:</para>

          <programlisting> schematool -action evolve <literal>-p versant.properties</literal></programlisting>

          <para>This command will remove the superclass Person from Employee.</para>

          <para>Invoke <literal>db2tty -D &#60;database&#62; -s</literal> to
          see the changed schema definition.</para>

          <programlisting>

                 ====== CLASS `Person&#39; ======
                  [no superclasses]
                  attributes:
                    o_ts_timestamp                 :  o_4b
                    name                           :  char[]
                    name#null                      :  o_bool


                  ====== CLASS `Employee&#39; ======
                  [no superclasses]
                  attributes:
                    o_ts_timestamp                 :  o_4b
                    salary                         :  o_4b

                  </programlisting>

          <para></para>
        </example>

        <example id="vds_schema_compare">
          <title>Schema Compare</title>

          <para>Use the <literal>-action compare</literal> option of the
          Schema Tool to view the requisite changes in the database schema.
          Hwever, these changes will <emphasis>not</emphasis> be committed to
          the database.</para>

          <programlisting> schematool -action compare <literal>-p versant.properties</literal></programlisting>
        </example>
      </section>
    </section>

    <section>
      <title>Versant Schema Mapping</title>

      <para>Open Access with the Versant OODBMS does not require any
      object-relational mapping. Because there is a direct correlation between
      the Java classes and the schema that is defined in the database.<emphasis>
      <emphasis>I<emphasis>n addition, when using Open Access with the Versant
      object database, the schema for Java classes can be defined dynamically
      in the runtime. This is great during development, however for production
      the schema should be explicitly defined in the database using the Open
      Access schema definition tool</emphasis></emphasis><emphasis>.</emphasis></emphasis></para>

      <para>Although by default there is a direct correlation between the Java
      classes and the schema defined in the database, it is possible to change
      this direct mapping and customize how your classes are stored. This is
      primarily useful for advanced users who are looking to optimize the
      database schema. This customization is controlled via the JDO metadata
      file using both standard JDO metadata elements as well as specific
      vendor extension elements. This chapter aims to provide a detailed
      understanding of how Java classes are stored in the Versant object
      database and how a user can customize this storage.</para>

      <section id="vds_classmapping">
        <title>Class Mapping</title>

        <para>Persistence capable Java classes are mapped directly to classes
        of the same name without their package name in the database. If a
        persistence capable class has a persistence capable superclass, then
        this superclass (and all persistence capable superclasses) will also
        be defined in the database since the Versant object database has a
        direct representation for inheritance. A database class will have a
        field for each persistent field of its associated persistent capable
        class, transient fields have no representation in the database.
        Database class will inherit any of the fields declared by its
        superclass as one would expect. There is no special representation in
        the database for the public, package, package protected or private
        classes or fields.</para>

        <section id="vds_fieldmapping">
          <title>Field Mapping</title>

          <para>Persistent fields of persistent capable classes are defined in
          the database by mapping the field&#39;s type to an appropriate
          database type. The Versant object database supports all Java
          primitive types as atomic types in the database. It also supports
          object references as atomic types since every object in the Versant
          database is automatically assigned a unique logical object identity
          (often referred to as a <literal>LOID</literal>). A reference in the
          database is simply the LOID of the referenced object. In Open Access
          with Versant object database these LOIDs are mapped to JDO concept
          of datastore identity.</para>

          <para>The Versant database can also store arrays of these atomic
          types, so a Java <literal>int[]</literal> is stored as an array of
          integer values in the database. Likewise for one-to-many
          relationships, these are stored simply as an array of LOIDs. This
          natural support for Java field types makes mapping Java classes into
          the Versant database very straightforward. There are some Java field
          types that have no direct representation in the Versant database
          (ex:<classname>BigInteger</classname>), these are converted to an
          appropriate database type instead.</para>

          <para>This section outlines how the supported Java types, as
          mandated by the JDO specification, are represented in the Versant
          object database by Open Access and how the standard JDO metadata as
          well as specific vendor extensions can be used to customize this
          representation.</para>

          <para>This section concludes with a discussion of externalization, a
          Open Access feature that allows you to persist many field types that
          are not supported directly by JDO without a custom field mapping,
          and without resorting to serialization.</para>

          <section id="basic">
            <title>Basic Types</title>

            <para>Fields of primitive Java types, primitive wrapper types (ex:<classname>java.lang.Boolean</classname>),
            <classname>java.lang.String</classname> and
            <classname>java.util.Date</classname> are automatically mapped to
            their equivalent database types.</para>

            <section>
              <title>Primitive Types</title>

              <para>The table below shows the mapping for primitive Java types
              to their equivalent database types. When using Versant tools to
              inspect the database these are the types you are likely to see
              displayed. The Versant object database refers to the type of a
              field as the field&#39;s <literal>domain</literal>.</para>

              <table tocentry="1">
                <title>Primitive Types</title>

                <tgroup rowsep="1" colsep="1" cols="2" align="left">
                  <colspec colname="java" />

                  <colspec colname="versant" />

                  <thead>
                    <row>
                      <entry colname="java">Java PrimitiveType</entry>

                      <entry colname="versant">Database Type</entry>
                    </row>
                  </thead>

                  <tbody>
                    <row>
                      <entry colname="java"><literal>boolean</literal></entry>

                      <entry colname="versant"><literal>o_bool</literal></entry>
                    </row>

                    <row>
                      <entry colname="java"><literal>byte</literal></entry>

                      <entry colname="versant"><literal>o_1b</literal></entry>
                    </row>

                    <row>
                      <entry colname="java"><literal>char</literal></entry>

                      <entry colname="versant"><literal>o_u2b</literal></entry>
                    </row>

                    <row>
                      <entry colname="java"><literal>double</literal></entry>

                      <entry colname="versant"><literal>o_double</literal></entry>
                    </row>

                    <row>
                      <entry colname="java"><literal>float</literal></entry>

                      <entry colname="versant"><literal>o_float</literal></entry>
                    </row>

                    <row>
                      <entry colname="java"><literal>int</literal></entry>

                      <entry colname="versant"><literal>o_4b</literal></entry>
                    </row>

                    <row>
                      <entry colname="java"><literal>long</literal></entry>

                      <entry colname="versant"><literal>o_8b</literal></entry>
                    </row>

                    <row>
                      <entry colname="java"><literal>short</literal></entry>

                      <entry colname="versant"><literal>o_2b</literal></entry>
                    </row>
                  </tbody>
                </tgroup>
              </table>
            </section>

            <section>
              <title>Primitive Wrapper Types</title>

              <para>The fields of primitive wrapper types are stored in the
              database using their equivalent primitive type for efficiency
              reasons. Instances of these wrapper classes not themselves
              mapped to actual objects in the database. However, fields of
              primitive wrapper types can be <literal>null</literal> and it
              maybe important to your application to preserve this null value.
              For this reason, Open Access defines an additional field
              <literal>x#null</literal> (referred to as a <literal><literal><replaceable>synthetic
              field</replaceable></literal></literal>) in the database that is
              used to indicate that the Java field <literal>x</literal> is
              <literal>null</literal>. <note><para>This additional field is
              required because there is no possible way to represent a
              <literal>null</literal> value for an Integer type, in the
              database.</para></note>If you declare fields using primitive
              wrapper types then the database class will have two fields, one
              to store the actual value of the field (if it has one, otherwise
              a default value, typically <literal>0</literal> or
              <literal>false</literal> for booleans is used) and the other to
              store if the field doesn&#39;t have a value and is in fact
              <literal>null</literal>. This additional field&#39;s type is
              <literal>o_bool</literal>. If you use the Versant tools to look
              at the contents of the database then you will see these
              additional fields defined with a <literal>#null</literal>
              appended to the field name.</para>
            </section>

            <section>
              <title>String Types</title>

              <para>Fields of type <classname>java.lang.String</classname> are
              stored in the database as UTF-8 encoded dynamic arrays of bytes.
              This conversion allows strings using internationalized character
              sets to be stored in the Versant database. A <literal>String</literal>
              field will be stored in the database as a <literal>char[]</literal>.
              <note><para>This <literal>char</literal> type should not be
              confused with Java&#39;s <literal>char</literal> type, they have
              the same name but Versant&#39;s <literal>char</literal> type is
              a traditional ASCII single byte character type, whereas
              Java&#39;s <literal>char</literal> type is a two byte unicode
              character. This is why Java&#39;s <literal>char</literal> type
              is mapped to Versant&#39;s two byte unsigned type
              <literal>o_u2b</literal>.</para></note>Similar to the case for
              primitive wrapper types, fields of type <literal>String</literal>
              will have an additional field defined in the database to store
              whether the field is <literal>null</literal>.</para>
            </section>

            <section>
              <title>Date Types</title>

              <para>Fields of type <classname>java.util.Date</classname> are
              stored in the database using Versant&#39;s 8 byte signed type
              <literal>o_timestamp</literal>. Whilst Java&#39;s
              <literal>Date</literal> type stores times since epoch to
              millisecond precision, Versant&#39;s <literal>o_timestamp</literal>
              type is able to store times to nanosecond precision and
              therefore <literal>Date</literal> fields are converted to and
              from nanoseconds since epoch. The only implication of this is
              that Versant is unable to store the full range of dates
              representable in Java since there will be a loss of precision
              when a <literal>Date</literal> is converted from milliseconds to
              nanoseconds and stored as an 8 byte signed quantity in the
              database. Similar to the case for primitive wrapper types,
              fields of type <literal>Date</literal> will have an additional
              field defined in the database to store whether the field is
              <literal>null</literal>.</para>
            </section>

            <section>
              <title>Locale, BigInteger and BigDecimal Types</title>

              <para>Open Access also supports fields of type
              <classname>java.util.Locale</classname>, <classname>java.math.BigInteger</classname>
              and <classname>java.math.BigDecimal</classname>. Since these
              have no direct equivalent primitive representation in the
              Versant database, fields of these types are converted to and
              from strings and stored in the database as strings. This has the
              benefit that they are human readable in the database and can be
              queried on, at least on equality/inequality (range queries are
              not supported). Similar to the case for primitive wrapper types,
              fields of these types will have an additional field defined in
              the database to store whether the field is <literal>null</literal>.</para>
            </section>

            <section>
              <title>Arrays</title>

              <para>Arrays is the last area to consider for basic types. As
              previously explained the Versant object database supports
              dynamic arrays of primitive values. For the primitive Java types
              this simply means that a <literal>int[]</literal>, for example,
              is stored in the database as a <literal>o_4b[]</literal>. It
              doesn&#39;t matter what size the array is or if a new array is
              allocated of a different size, as Versant supports dynamic
              arrays. Similar to the case for primitive wrapper types, array
              fields will have an additional <literal>#null</literal> field
              defined in the database to store whether the field is
              <literal>null</literal>.</para>

              <para>If the array is of a primitive wrapper type or
              <literal>java.util.Date</literal>, where not only can the array
              be null but also an element within the array can be null then
              Open Access adds an additional synthetic field to the datastore
              class. This synthetic field is an array of boolean values, where
              each boolean indicates if the positionally equivalent element in
              the array field is <literal>null</literal>. This synthetic field
              has a postfix of <literal>#nulls</literal>. <note><para>Open
              Access optimizes the use of this additional synthetic field, if
              there are no <literal>null</literal> values then the synthetic
              field will be an empty array.</para></note></para>

              <para>Arrays of <literal>String</literal> types are handled
              slightly differently since, from the earlier section, you can
              see that a <literal>String</literal> is already mapped to a
              dynamic array of bytes in the database. A <literal>String[]</literal>
              is stored in the database using Versant&#39;s
              <literal>list</literal> type. A <literal>list</literal> is
              essentially a 2 dimensional array. So a <literal>String[]</literal>
              is stored in the database as a <literal>char[list]</literal>,
              where each element in the <literal>list</literal> is a
              <literal>char[]</literal>. As with arrays of primitive wrapper
              types, an additional synthetic field is used to indicate if a
              <literal>String</literal> in the <literal>list</literal> is
              <literal>null</literal>.</para>

              <para>Since <classname>java.util.Locale</classname>,
              <classname>java.math.BigInteger</classname> and
              <classname>java.math.BigDecimal</classname> types are converted
              to strings, arrays of these types are converted to arrays of
              strings as discussed above.</para>
            </section>
          </section>

          <section id="refs">
            <title>Object References</title>

            <para>Fields that reference an object are stored in the database
            in a variety of ways depending on what is being referenced. The
            previous section on basic types explained about references to
            certain Java system classes that are managed (e.g. collections),
            this section will explain how references to all other classes are
            handled.</para>

            <para>A reference to a Java object can be categorized as one of
            the following: <itemizedlist><listitem><para>Reference to a
            Persistence Capable Class</para></listitem><listitem><para>Reference
            to an Object</para></listitem><listitem><para>Reference to an
            Interface</para></listitem><listitem><para>Reference to a
            Non-Persistence Capable Class</para></listitem><listitem><para>Arrays
            of References</para></listitem></itemizedlist></para>

            <para>The following sections explain how each of the above
            categories are handled.</para>

            <section>
              <title>Reference to a Persistence Capable Class</title>

              <para>If a field is a reference to another persistence capable
              class, then Open Access creates a field in the database whose
              domain is the equivalent database class. The LOID of the
              referenced object is then stored in the field. A
              <literal>{0.0.0}</literal> LOID is used to represent a
              <literal>null</literal> reference.</para>

              <para>A field of this type will be persistent by default and no
              additional JDO metadata is required.</para>
            </section>

            <section>
              <title>Reference to an Object</title>

              <para>If a field is a reference to <classname>java.lang.Object</classname>
              then the field could reference any Java object, that is of the
              type unknown. By default Open Access assumes that the field will
              reference an instance of a persistence capable class and will
              create a field in the database whose domain is unknown, or
              <literal>NULL_DOMAIN</literal>. When stored the LOID of the
              referenced persistent object is then stored in the field. A
              <literal>{0.0.0}</literal> LOID is used to represent a
              <literal>null</literal> reference.</para>

              <para>If the persistence capable class is actually known for a
              field of this type then additional metadata can be used to let
              Open Access know the class. In this case the field will be
              defined in the database as if it was a reference to the
              specified persistence capable class.</para>

              <para>If a field is known not to reference a persistence capable
              class then additional metadata is necessary to let Open Access
              know this scenario. In this situation these fields are treated
              the same as references to non-persistence capable classes.</para>

              <para>A field of this type will not be persistent by default,
              the field must be explicitly marked as being persistent in the
              JDO metadata.</para>
            </section>

            <section>
              <title>Reference to an Interface</title>

              <para>If a field is a reference to a Java Interface then the
              field could be a reference to any Java class that implements
              that Interface. In essence this is the same field that is a
              reference to <classname>java.lang.Object</classname> and in fact
              Open Access treats a reference to an Interface in exactly the
              same way as a reference to <classname>java.lang.Object</classname>.</para>

              <para>A field of this type will not be persistent by default
              (unless it is the <classname>PersistenceCapable</classname>
              interface), the field must be explicitly marked as being
              persistent in the JDO metadata.</para>
            </section>

            <section>
              <title>Reference to a Non-Persistence Capable Class</title>

              <para>If a field is a reference to a non-persistence capable
              class or additional metadata is used to indicate a field
              references a non-persistence capable class then the referenced
              object itself can not be directly represented in the database.
              Open Access will define a field in the database that references
              the automatically defined and templated <classname>external</classname>
              database class. This database class simply stores the
              exterialized values of the field.</para>

              <para>Open Access automatically manages the instances of this
              pre-defined database class, ensuring that if the referencing
              object is deleted then the <classname>external</classname>
              instance is also deleted.</para>
            </section>

            <section>
              <title>Arrays of References</title>

              <para>An array of references to a persistence capable class,
              <classname>java.lang.Object</classname> or a Java Interface are
              treated the same as an array of a primitive type. Open Access
              defines a field in the database that is a dynamic array and
              whose domain is the equivalent persistence capable class in the
              database. The LOIDs of all the referenced persistent objects are
              stored in this array. If an reference in the array is
              <literal>null</literal> then the LOID <literal>{0.0.0}</literal>
              is used. As per arrays of primitive types a field that is an
              array of a persistence capable class will have an additional
              synthetic <literal>#null</literal> field defined in the database
              to store whether the array itself is <literal>null</literal>.</para>
            </section>
          </section>

          <section id="colls">
            <title>Collections and Maps</title>

            <para>A field that references a Java collection or map can be
            stored in the database in a variety of ways depending on what the
            collection or map contains. Open Access supports fields that
            reference all the standard Java collections Interfaces:
            <itemizedlist><listitem><para><classname>java.util.Collection</classname></para></listitem><listitem><para><classname>java.util.List</classname></para></listitem><listitem><para><classname>java.util.Map</classname></para></listitem><listitem><para><classname>java.util.Set</classname></para></listitem><listitem><para><classname>java.util.SortedMap</classname></para></listitem><listitem><para><classname>java.util.SortedSet</classname></para></listitem></itemizedlist>
            And the standard concrete Java collection classes:
            <itemizedlist><listitem><para><classname>java.util.ArrayList</classname></para></listitem><listitem><para><classname>java.util.HashMap</classname></para></listitem><listitem><para><classname>java.util.HashSet</classname></para></listitem><listitem><para><classname>java.util.Hashtable</classname></para></listitem><listitem><para><classname>java.util.LinkedList</classname></para></listitem><listitem><para><classname>java.util.LinkedHashMap</classname></para></listitem><listitem><para><classname>java.util.LinkedHashSet</classname></para></listitem><listitem><para><classname>java.util.Stack</classname></para></listitem><listitem><para><classname>java.util.TreeMap</classname></para></listitem><listitem><para><classname>java.util.TreeSet</classname></para></listitem><listitem><para><classname>java.util.Vector</classname></para></listitem></itemizedlist></para>

            <para>By default it is assumed that any collection or map contains
            references to instances of one or more unknown persistence capable
            classes. Since a collection or map is untyped in Java it is
            possible to use the standard JDO metadata <literal>element-type</literal>,
            <literal>value-type</literal> and <literal>key-type</literal> to
            denote the contained classes. This additional information allows
            Open Access to create appropriately typed fields in the database
            and it is strongly recommended that this additional information be
            provided.</para>

            <para>Open Access automatically creates database classes for the
            supported Java collections. These classes are templated (similar
            to the forthcoming Java generics support in JDK 1.5) based on what
            the collection or map supports. Open Access creates templated
            database classes based on the <classname>List</classname>,
            <classname>Map</classname> and <classname>Set</classname> Java
            Interfaces.</para>

            <para>A reference to a Java collection or map can be categorized
            as one of the following: <itemizedlist><listitem><para>Collection
            or Map of a Persistence Capable Class</para></listitem><listitem><para>Collection
            or Map of Object</para></listitem><listitem><para>Collection or
            Map of an Interface</para></listitem><listitem><para>Collection or
            Map of Supported System Classes</para></listitem><listitem><para>Collection
            or Map of a Non-Persistence Capable Class</para></listitem></itemizedlist></para>

            <para>The following sections explain how each of the above
            categories are handled.</para>

            <section>
              <title>Collection or Map of a Persistence Capable Class</title>

              <para>If type of the elements in a collection or value and keys
              in a map is a persistence capable class, then Open Access
              creates a database container class templated on that class. For
              example, if the Java field is a <classname>java.util.List</classname>
              and the JDO metadata is used to denote that the
              <literal>element-type</literal> of the collection is
              <classname>Employee</classname>, which is a persistent capable
              class, then Open Access will create a database class called
              <classname>List&#60;Employee&#62;</classname>. This container
              class will have an array field whose domain is
              <classname>Employee</classname> and is called
              <literal>elements</literal>. In addition to this field an
              additional string field is defined called <literal>runtimeclass</literal>
              which is used to store the actual class name of the Java
              collection. This is done so that Open Access can recreate a
              collection of the correct type when retrieved from the database.</para>

              <para>The same approach is used for <classname>java.util.Set</classname>
              collections. For <classname>java.util.Map</classname> a
              templated database class is created that has two template
              arguments. For example, if the field is a
              <classname>java.util.Map</classname> and the JDO metadata is
              used to denote that the <literal>key-type</literal> of the map
              is <classname>String</classname> and the <literal>value-type</literal>
              of the map is <classname>Employee</classname> then Open Access
              will create a database class called <classname>Map&#60;String,Employee&#62;</classname>.
              In this case the templated class has two fields
              <literal>keys</literal> and <literal>values</literal> which are
              arrays of the appropriate types. It also has the
              <literal>runtimeclass</literal> field to store the name of the
              actual Java map class.</para>
            </section>

            <section>
              <title>Collection or Map of Object</title>

              <para>As references to <classname>java.lang.Object</classname>
              are assumed to be a reference to a persistence capable class,
              similarly, the collections or maps are by default assumed to
              contain references to one or more persistent capable classes. If
              no additional metadata is provided then Open Access will create
              <literal>Object</literal> templated database classes</para>
            </section>

            <section>
              <title>Collection or Map of Interface</title>

              <para>If the JDO metadata identifies that a collection or map
              contains references to a Java Interface, then the same way the
              references to Java Interfaces are assumed to be a reference to a
              persistence capable class. Collections or maps will be assumed
              to contain references to one or more persistent capable classes.
              In this case Open Access will create <literal>Object</literal>
              templated database classes.</para>
            </section>

            <section>
              <title>Collection or Map of Supported System Classes</title>

              <para>If the JDO metadata identifies that a collection or map
              contains instances of a supported system class (primitive
              wrapper classes, <classname>java.lang.String</classname>,
              <classname>java.util.Date</classname>, and so on) then Open
              Access will create templated database classes based on the
              equivalent primitive type.</para>

              <para>For example, if the Java field is a
              <classname>java.util.List</classname> and the JDO metadata is
              used to denote that the <literal>element-type</literal> of the
              collection is <classname>java.lang.Integer</classname> then Open
              Access will create a database class called
              <classname>List&#60;Integer&#62;</classname> whose
              <literal>elements</literal> field will be a <literal>o_4b[]</literal>.
              As per arrays of primitive wrapper classes an additional field
              will be defined to store if any elements on the collection are
              <literal>null</literal>.</para>
            </section>

            <section>
              <title>Collection or Map of a Non-Persistence Capable Class</title>

              <para>If the JDO metadata identifies that a collection or map
              contains instances of a non-persistence capable class then as
              per arrays of a non-persistence capable class, the collection or
              map is itself serialized in the database.</para>
            </section>

            <section>
              <title>Embedded Collection Storage</title>

              <para>Whilst the default is to store instances of Java
              collections or maps as objects in the database, it is possible
              to specify that the database container classes be embedded
              instead. This can be indicated using the <literal>embedded=&#34;true&#34;</literal>
              metadata for the field. In this situation Open Access will
              define the container&#39;s fields as aggregated fields in the
              referencing database class. An aggregated field&#39;s name is
              the name of the field appended to the name of the field in the
              referencing class, separated by a <literal>&#39;.&#39;</literal>.
              In addition to the aggregated fields Open Access will also
              create a <literal>#null</literal> synthetic field to indicate if
              the collection or map itself is <literal>null</literal>.</para>
            </section>
          </section>

          <section id="vds_fieldmapping_extern">
            <title>Externalization</title>

            <para>Object fields that are neither instances of
            <classname> PersistenceCapable</classname> nor one of the default
            persistent types mandated by the JDO specification (primitives and
            wrappers, <classname>String</classname>, <classname>Locale</classname>,
            etc.) can by externalized to a storable form in the database.</para>
          </section>
        </section>
      </section>
    </section>
  </chapter>

  <chapter id="meta_data_ext">
    <title>Meta Data Extension Reference</title>

    <para>This is an alphabetical reference for all of the meta data
    extensions supported by Versant Open Access. The Versant Open Access
    Workbench provides easy to use dialogs to control nearly all of these and
    its online help links to this manual.</para>

    <section id="md_autoset">
      <title>autoset<indexterm><primary>autoset extension</primary></indexterm></title>

      <para>Configure a field to be automatically set by Versant Open Access
      when new instances and/or changes are committed. This may only be used
      on <classname>java.util.Date</classname>, <classname>byte,</classname>
      <classname>short</classname> and <classname>int</classname> fields. When
      used on a <classname>java.util.Date</classname> field the current time
      is set. When used on a <classname>byte,</classname>
      <classname>short</classname> or <classname>int</classname> field the
      current value of the field is incremented by one (wrapping to 0 at max
      positive value) or it is set to 1 for new objects. This is useful for
      automatically maintaining date created, date last modified and version
      number fields.</para>

      <programlisting>&#60;field name=&#34;orderDate&#34;&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;autoset&#34; value=&#34;created&#34; /&#62;
&#60;/field&#62;</programlisting>

      <para>Valid values:</para>

      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>autoset</entry>

              <entry>description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>none</entry>

              <entry>Do not autoset field (default).</entry>
            </row>

            <row>
              <entry>created</entry>

              <entry>Set on commit when new instance is created.</entry>
            </row>

            <row>
              <entry>modified</entry>

              <entry>Set on commit when existing instance is modified.</entry>
            </row>

            <row>
              <entry>both</entry>

              <entry>Set on commit when instance is created or modified.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>

    <section id="md_cache_strategy">
      <title>cache-strategy<indexterm><primary>cache-strategy extension</primary></indexterm></title>

      <para>Control how instances of a class are cached. This can be set at
      datastore and class level. The value set at datastore level becomes the
      default for all classes in that datastore. This extension is ignored if
      a cache is not being used.</para>

      <programlisting>&#60;package name=&#34;tut1.model&#34;&#62;
    &#60;class name=&#34;Item&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;cache-strategy&#34; value=&#34;no&#34; /&#62;
    &#60;/class&#62;
&#60;/package&#62;</programlisting>

      <para>Valid values:</para>

      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>cache-strategy</entry>

              <entry>description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>no</entry>

              <entry>Do not cache instances.</entry>
            </row>

            <row>
              <entry>yes</entry>

              <entry>Cache instances.</entry>
            </row>

            <row>
              <entry>all</entry>

              <entry>Read and cache all instances the first time an instance
              is read. This works well when the number of instances is small
              as reading them all in bulk is faster than individual on-demand
              reads.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>

    <section id="md_datastore">
      <title>datastore<indexterm><primary>datastore extension</primary></indexterm></title>

      <para>Set the name of the datastore used to store a class. The default
      datastore for a class is the first datastore defined in the
      <filename>.properties</filename> project file.</para>

      <programlisting>&#60;package name=&#34;tut1.model&#34;&#62;
    &#60;class name=&#34;Item&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;datastore&#34; value=&#34;main&#34; /&#62;
    &#60;/class&#62;
&#60;/package&#62;</programlisting>
    </section>

    <section id="md_delete_orphans">
      <title>delete-orphans<indexterm><primary>delete-orphans extension</primary></indexterm></title>

      <para>Boolean class level option to control the automatic deletion of
      certain types of unreferenced instances. If delete-orphans is true and
      the class is involved on the many side of at least one one-to-many
      relationship then it is deleted on commit if <emphasis>all</emphasis> of
      the reference fields used as inverses for the one-to-many
      relationship(s) are null. If you use this option you should should not
      set dependent on the collections. Instances used by one collection might
      be deleted when the other collection is deleted causing a
      VersantObjectNotFoundException when the collection is retrieved.</para>

      <para>Versions of Versant Open Access earlier than 1.4 effectively had
      delete-orphans on by default if any of the collections were flagged as
      dependent. This caused problems for models using multiple one-to-many
      collections to the same many class.</para>

      <programlisting>&#60;class name=&#34;OrderLine&#34;&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;delete-orphans&#34; value=&#34;true&#34; /&#62;
&#60;/class&#62;</programlisting>
    </section>

    <section id="md_dependent">
      <title>dependent<indexterm><primary>dependent extension</primary></indexterm></title>

      <para>Set a reference to a persistent class or the persistent values in
      a collection, array or map to be considered dependent. Dependent objects
      are deleted when the instance refering to them is deleted. Note that
      Versant Open Access does not check for other references to the instances
      deleted so this extension should only be used for objects that are not
      referenced from anywhere else.</para>

      <programlisting>&#60;field name=&#34;lines&#34;&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;dependent&#34; value=&#34;true&#34; /&#62;
    &#60;collection element-type=&#34;OrderLine&#34; /&#62;
&#60;/field&#62;</programlisting>

      <para>See also: <link linkend="md_keys_dependent">keys-dependent</link></para>
    </section>

    <section id="md_fetch_group">
      <title>fetch-group<indexterm><primary>fetch-group extension</primary></indexterm></title>

      <para>Define a named fetch group for a class or set the fetch group for
      a field. Versant Open Access supports multiple fetch groups per class
      for precise control over which fields are fetched and how they are
      fetched. A field may have a fetch group specified for it (this overrides
      the standard <command>default-fetch-group</command> attribute). All the
      fields in that group will be fetched when the field is fetched. A fetch
      group may also be named when executing a JDOQL query.</para>

      <para>Fetch groups are defined at class level. Each field in the fetch
      group is named using a <command>field-name</command> extension.
      Additional child extensions of <command>field-name</command> control how
      the field is fetched if it is a reference or a collection, array or map
      of a persistent class. The <command>next-fetch-group</command> extension<indexterm><primary>next-fetch-group
      extension</primary></indexterm> specifies the name of the fetch group to
      use to fetch the fields of the referenced class or value. The
      <command>jdbc-use-join</command> extension<indexterm><primary>jdbc-use-join
      extension</primary></indexterm> controls the type of join done to
      retrieve these fields. <emphasis>These extensions allow fetch groups to
      be chained together to fetch a section of an object graph with a single
      query solving the N+1 database calls problem.</emphasis> The
      <command>next-key-fetch-group</command> and <command>jdbc-use-key-join</command>
      extensions<indexterm><primary>jdbc-use-key-join extension</primary></indexterm>
      <indexterm><primary>next-key-fetch-group extension</primary></indexterm>control
      how the keys of a map are fetched (if they are instances of a persistent
      class).</para>

      <para>The example below creates a fetch group on Order
      (orderNo_custcode) that contains the orderNo and customer fields. This
      group uses an outer join to fetch the code_only group from the Customer.
      This avoids the N + 1 database calls problem when a number of Orders are
      fetched and the customer reference on each order is navigated.</para>

      <programlisting>&#60;class name=&#34;Order&#34; identity-type=&#34;application&#34; objectid-class=&#34;OrderNo&#34;&#62;
    &#60;field name=&#34;orderNo&#34; primary-key=&#34;true&#34; /&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;fetch-group&#34; value=&#34;orderNo_custcode&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;field-name&#34; value=&#34;orderNo&#34; /&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;field-name&#34; value=&#34;customer&#34;&#62;
            &#60;extension vendor-name=&#34;versant&#34; key=&#34;next-fetch-group&#34;
                value=&#34;code_only&#34; /&#62;
            &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-use-join&#34;
                value=&#34;outer&#34; /&#62;
        &#60;/extension&#62;
    &#60;/extension&#62;
&#60;/class&#62;

&#60;class name=&#34;Customer&#34;&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;fetch-group&#34; value=&#34;code_only&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;field-name&#34; value=&#34;code&#34; /&#62;
    &#60;/extension&#62;
&#60;/class&#62;</programlisting>

      <para>Valid values:</para>

      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>jdbc-use-join and jdbc-use-key-join</entry>

              <entry>description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>no</entry>

              <entry>Do not join to retrieve the fields.</entry>
            </row>

            <row>
              <entry>outer</entry>

              <entry>Use an outer join to retrieve fields.</entry>
            </row>

            <row>
              <entry>inner</entry>

              <entry>Use an inner join to retrieve fields. Using an inner join
              allows the join to extend further accross the object graph as
              other joins can be done from the joined table.
              <emphasis>However rows will be lost if the reference contains
              null or database referential integrity is invalid.</emphasis></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>The fetch group is set on the Query by casting it to a
      VersantQuery:</para>

      <programlisting>VersantQuery q = (VersantQuery)pm.newQuery(Order.class);
q.setFetchGroup(&#34;orderDate_custcode&#34;);
Collection ans = (Collection)q.execute();</programlisting>

      <para>Or by using a dummy parameter (retains portability):</para>

      <programlisting>Query q = pm.newQuery(Order.class);
q.declareParameters(&#34;String versantOptions&#34;);
Collection ans = (Collection)q.execute(&#34;fetchGroup=orderDate_custcode&#34;);</programlisting>

      <para>Versant Open Access generates the following SQL (for Sybase)
      fetching only what is required using an outer join:</para>

      <programlisting>select a.order_id, a.order_date, a.customer_id, a.jdo_version, b.code, b.jdo_version
from ordr a, customer b
where a.customer_id *= b.customer_id</programlisting>

      <para>The fetch group for a field controls which other fields are
      fetched along with it. If you have several related fields that are not
      often needed (e.g. address, city, state and country) you can create a
      fetch group containing these fields and set it on each of them. Then if
      one of them is touched in your code and has to be fetched all of them
      will be fetched together. Setting a fetch group on a field overrides the
      <command>default-fetch-group</command> attribute.</para>

      <programlisting>&#60;field name=&#34;code&#34;&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;fetch-group&#34; value=&#34;code_related&#34; /&#62;
&#60;/field&#62;</programlisting>

      <para>It is easy to setup fetch groups using the Workbench.</para>

      <figure>
        <title>Creating fetch groups in the Workbench</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/fetchgroup_setup.png" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section id="md_interface">
      <title>interface<indexterm><primary>interface</primary></indexterm></title>

      <para>Declare a persistent interface. All references to the interface
      are considered persistent by default (see <xref
      linkend="mapping_interface_field" />).</para>

      <programlisting>&#60;package name=&#34;com.acme.erp.model&#34;&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;interface&#34; value=&#34;HasAddress&#34; /&#62;
    ...
&#60;/package&#62;</programlisting>
    </section>

    <section id="md_inverse">
      <title>inverse<indexterm><primary>inverse extension</primary></indexterm><indexterm><primary>jdbc-link-foreign-key
      extension</primary></indexterm></title>

      <para>Set the name of the field used to complete a collection
      implemented using an inverse reference or collection field in the
      element class (one-to-many or many-to-many relationship).</para>

      <section id="md_one_to_many">
        <title>one-to-many inverse<indexterm><primary>one-to-many inverse</primary></indexterm></title>

        <para>If the inverse field is a reference then a one-to-many
        relationship is created. No link table will be created between the
        classes as the field can be used to find all the elements in the
        collection. The field must reference the class with the collection.
        The inverse field is automatically set or cleared when objects are
        added or removed from the collection. The collection should never be
        replaced with a new instance. See <xref
        linkend="inverse_foreign_key_mapping" />.</para>

        <programlisting>&#60;field name=&#34;lines&#34;&#62;
    &#60;collection element-type=&#34;OrderLine&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;inverse&#34;
            value=&#34;order&#34; /&#62;
    &#60;/collection&#62;
&#60;/field&#62;</programlisting>

        <para>An index containing the foreign key columns will be added to the
        referenced table (see <xref linkend="md_inverse_index" />).</para>

        <para>This extension used to be called jdbc-link-foreign-key and this
        will still work. The Workbench automatically renames the old extension
        to &#39;inverse&#39; when old projects are opened.</para>
      </section>

      <section id="md_many_to_many">
        <title>many-to-many inverse<indexterm><primary>one-to-many inverse</primary></indexterm></title>

        <para>If the inverse field is a collection then a many-to-many
        relationship is created. The link table used by the other side of the
        relationship is used to complete the collection. Anything done to the
        collection on one side is automatically applied to the other side. The
        collection should never be replaced with a new instance. See <xref
        linkend="many_to_many_mapping" />.</para>

        <programlisting>&#60;class name=&#34;User&#34;&#62;
    &#60;field name=&#34;groups&#34;&#62;
        &#60;collection element-type=&#34;Groups&#34; /&#62;
    &#60;/field&#62;
&#60;/class&#62;

&#60;class name=&#34;Groups&#34;&#62;
    &#60;field name=&#34;users&#34;&#62;
        &#60;collection element-type=&#34;User&#34;&#62;
            &#60;extension vendor-name=&#34;versant&#34; key=&#34;inverse&#34; value=&#34;groups&#34; /&#62;
        &#60;/collection&#62;
    &#60;/field&#62;
&#60;/class&#62;</programlisting>

        <para>An index containing the foreign key columns will be added to the
        link table (see <xref linkend="md_inverse_index" />).</para>
      </section>
    </section>

    <section id="md_jdbc_class_id">
      <title>jdbc-class-id<indexterm><primary>jdbc-class-id extension</primary></indexterm></title>

      <para>Set the JDBC class ID for a class and/or define what the JDBC
      class ID column looks like. Versant Open Access supports flat
      inheritance by using a class ID column in the base class table to
      specify the type of each row (see <xref linkend="inheritance" />). The
      default class ID value for each class is a 31 bit hash generated from
      the fully qualified class name. This extension can be used to specify
      any positive 32 bit integer or a String (unique within the hierarchy) as
      the JDBC class ID.</para>

      <para>You can use a nested <command><link linkend="md_jdbc_column">jdbc-column
      extension</link></command> to define the column used to store the class
      ID. The default class ID column has JDBC type INTEGER. The class ID
      column may only be defined in the topmost class in the hierarchy but
      every class may have a class ID defined for it. The example below
      defines the JDBC class ID column to be a TINYINY (byte) and sets the
      JDBC class ID for <classname>Item</classname> to 1 and
      <classname>CompositeItem</classname> to 2. Be sure that the class ID
      values you choose fit into the column.</para>

      <programlisting>&#60;class name=&#34;Item&#34;&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-class-id&#34; value=&#34;1&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-column&#34;&#62;
            &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-type&#34; value=&#34;TINYINT&#34; /&#62;
        &#60;/extension&#62;
    &#60;/extension&#62;
&#60;/class&#62;

&#60;class name=&#34;CompositeItem&#34; persistence-capable-superclass=&#34;Item&#34;&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-class-id&#34; value=&#34;2&#34;/&#62;
&#60;/class&#62;</programlisting>
    </section>

    <section id="md_jdbc_column">
      <title>jdbc-column<indexterm><primary>jdbc-column extension</primary></indexterm></title>

      <para>Define one or more properties for a column in a table. This
      extension is used wherever a value needs to a JDBC column. The optional
      value attribute specifies the type of database that the mapping applies
      to or all database if not specified. Any child extensions not set are
      defaulted by Versant Open Access based on the inferred Java type of the
      column (e.g. the type of the field). The example below sets the length
      (precision) and scale for a BigDecimal field to (10,4) for all databases
      except sybase which is (12,4). Versant Open Access will use a NUMERIC
      column for a BigDecimal field by default so there is no need to specify
      the type of the column. Normally it is best to let Versant Open Access
      choose as many things as possible as this will result in a portable
      database schema.</para>

      <programlisting>&#60;field name=&#34;qty&#34;&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-column&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-length&#34; value=&#34;10&#34; /&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-scale&#34; value=&#34;4&#34; /&#62;
    &#60;/extension&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-column&#34; value=&#34;sybase&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-length&#34; value=&#34;12&#34; /&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-scale&#34; value=&#34;4&#34; /&#62;
    &#60;/extension&#62;
&#60;/field&#62;</programlisting>

      <para>Valid child extensions:</para>

      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>child extension</entry>

              <entry>description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>jdbc-column-name</entry>

              <entry>Set the name of the column. The default name is provided
              by the name generator for the datastore of the table.</entry>
            </row>

            <row>
              <entry>jdbc-type</entry>

              <entry>JDBC type from <literal>java.sql.Types</literal>.</entry>
            </row>

            <row>
              <entry>jdbc-sql-type</entry>

              <entry>Database specific SQL type for the create script.</entry>
            </row>

            <row>
              <entry>jdbc-length</entry>

              <entry>Length (or precision).</entry>
            </row>

            <row>
              <entry>jdbc-scale</entry>

              <entry>Scale (digits after the decimal point).</entry>
            </row>

            <row>
              <entry>jdbc-nulls</entry>

              <entry>True or false to allow nulls or not (defaults to false
              for primitive types and true for all others).</entry>
            </row>

            <row>
              <entry>jdbc-shared</entry>

              <entry>This extension is no longer required and is ignored if
              present.</entry>
            </row>

            <row>
              <entry>jdbc-converter</entry>

              <entry>JdbcConverterFactory to use for this column (see <xref
              linkend="writing_jdbc_converter" />).</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>

    <section id="md_jdbc_constraint">
      <title>jdbc-constraint<indexterm><primary>jdbc-constraint extension</primary></indexterm></title>

      <para>Set the name of a JDBC referential integrity constraint or disable
      the constraint. If the value attribute of the extension is
      &#34;{no}&#34; then no constraint is generated. Any other value is used
      as the name of the constraint instead of the default name provided by
      the name generator for the datastore. Currently this extension may be
      used for fields that reference persistent classes. This extension is
      ignored if the field allows nulls and the target database does not
      support referential integrity constraints on columns that allow nulls.</para>

      <programlisting>&#60;field name=&#34;category&#34;&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-constraint&#34; value=&#34;ref_cat&#34; /&#62;
&#60;/field&#62;</programlisting>
    </section>

    <section id="md_jdbc_do_not_create_table">
      <title>jdbc-do-not-create-table<indexterm><primary>jdbc-do-not-create-table
      extension</primary></indexterm></title>

      <para>Turn table generation for a class or link table on or off (boolean
      extension). The can be set at datastore and class level. The value set
      at datastore level becomes the default for all classes in that
      datastore. This is useful when some of the classes in your model map to
      legacy database tables to leave these tables out of the generated
      schema.</para>

      <programlisting>&#60;class name=&#34;Item&#34;&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-do-not-create-table&#34;
        value=&#34;true&#34; /&#62;
&#60;/class&#62;</programlisting>

      <para>Here is an example of this extension used on a link table for a
      Collection:</para>

      <programlisting>&#60;field name=&#34;lines&#34;&#62;
    &#60;collection element-type=&#34;OrderLine&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-link-table&#34;&#62;
            &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-do-not-create-table&#34; value=&#34;true&#34; /&#62;
        &#60;/extension&#62;
    &#60;/collection&#62;
&#60;/field&#62;</programlisting>
    </section>

    <section id="md_jdbc_index">
      <title>jdbc-index<indexterm><primary>jdbc-index extension</primary></indexterm></title>

      <para>Define a JDBC index on one or more fields of a class or control
      automatic index generation for columns used to complete collections
      mapped using a foreign key.</para>

      <section id="defining_an_index">
        <title>Defining an index on a class</title>

        <para>The optional value attribute specifies the name of the index.
        The default name is provided by the name generator for the datastore
        of the class. One or more nested <command>jdbc-field</command>
        extensions define the names of the fields in the index in order. The
        optional <command>jdbc-unique</command> and <command>jdbc-clustered</command>
        extensions default to false.</para>

        <programlisting>&#60;class name=&#34;Order&#34;&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-index&#34; value=&#34;idx_cust&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;field-name&#34; value=&#34;customer&#34; /&#62;
    &#60;/extension&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-index&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;field-name&#34; value=&#34;orderDate&#34; /&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;field-name&#34; value=&#34;orderNo&#34; /&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-unique&#34; value=&#34;true&#34; /&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-clustered&#34; value=&#34;false&#34; /&#62;
    &#60;/extension&#62;
&#60;/class&#62;</programlisting>

        <para>Schema script create index statements for Sybase:</para>

        <programlisting>create index idx_cust on ordr(customer_id)
go

create index idx_ordr_order_date_orderNo on ordr(order_date, orderNo)
go</programlisting>

        <figure>
          <title>Defining JDBC Indexes in the Workbench</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/jdbc_index.png" />
            </imageobject>
          </mediaobject>
        </figure>
      </section>

      <section id="md_inverse_index">
        <title>Controlling index generation for an one-to-many collection<indexterm><primary>one-to-many
        index</primary></indexterm></title>

        <para>Columns for a field used to complete a collection mapped using
        an inverese reference field in the element-type class (see <xref
        linkend="md_inverse" />) are automatically indexed. The value
        attribute specifies the name of the index or &#34;{no}&#34; to disable
        the index. The default name is provided by the name generator for the
        datastore of the class. Here is an example showing how to disable the
        index:</para>

        <programlisting>&#60;field name=&#34;lines&#34;&#62;
    &#60;collection element-type=&#34;OrderLine&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;inverse&#34; value=&#34;order&#34;&#62;
            &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-index&#34; value=&#34;{no}&#34; /&#62;
        &#60;/extension&#62;
    &#60;/collection&#62;
&#60;/field&#62;</programlisting>
      </section>

      <section id="md_inverse_many_to_many_index">
        <title>Controlling index generation for an many-to-many collection<indexterm><primary>many-to-many
        index</primary></indexterm></title>

        <para>Columns in a link table used to complete a collection mapped
        using an inverese collection field in the element-type class (see
        <xref linkend="md_inverse" />) are automatically indexed. The value
        attribute specifies the name of the index or &#34;{no}&#34; to disable
        the index. The default name is provided by the name generator for the
        datastore of the class. Here is an example showing how to disable the
        index:</para>

        <programlisting>&#60;field name=&#34;groups&#34;&#62;
    &#60;collection element-type=&#34;Group&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;inverse&#34; value=&#34;users&#34;&#62;
            &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-index&#34; value=&#34;{no}&#34; /&#62;
        &#60;/extension&#62;
    &#60;/collection&#62;
&#60;/field&#62;</programlisting>
      </section>
    </section>

    <section id="md_jdbc_key_generator">
      <title>jdbc-key-generator<indexterm><primary>jdbc-key-generator
      extension</primary></indexterm></title>

      <para>Define the primary key generator for a class. This can be set at
      class and datastore level. The key generator set at datastore level
      becomes the default for all datastore identity classes in that
      datastore. The value attribute specifies the name of a built in key
      generator or the name of a <classname>com.versant.core.jdbc.JdbcKeyGeneratorFactory</classname>
      class to use as a factory. The first time a <command>jdbc-key-generator</command>
      class is encountered in the meta data an instance is created and stored
      for later use. Nested <command>property</command> extensions may be used
      to pass properties to the factory each time a key generator is created.</para>

      <para>Versant Open Access supports key generators for application
      identity classes. Normally if a class is using application identity the
      application must supply values for the primary key fields of new
      instances. Versant Open Access will generate these values automatically
      if you use a key generator and the values of the primary key fields
      match those of a default instance of the application identity class. You
      must specify the key generator for each application identity class i.e.
      the datastore level default does not apply.</para>

      <programlisting>&#60;class name=&#34;Branch&#34; identity-type=&#34;application&#34;
      objectid-class=&#34;Branch$ID&#34;&#62;
  &#60;extension vendor-name=&#34;versant&#34;
      key=&#34;jdbc-key-generator&#34; value=&#34;HIGHLOW&#34; /&#62;
  &#60;field name=&#34;branchNo&#34; primary-key=&#34;true&#34;/&#62;
&#60;/class&#62;</programlisting>

      <para>Versant Open Access currently supports key generation using a
      lookup table (the HIGHLOW or sequence block algorithm) and using
      identity or autoincrement columns (AUTOINC key generator). The HIGHLOW
      key generator is the default. The source code for this key generator and
      the interfaces is supplied in the <filename>src</filename> directory of
      the Versant Open Access distribution.</para>

      <figure>
        <title>Configuring the default key generator</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/datastore_settings.png" />
          </imageobject>
        </mediaobject>
      </figure>

      <table>
        <title>Properties for the HIGHLOW JDBC key generator</title>

        <tgroup cols="3">
          <thead>
            <row>
              <entry>Property</entry>

              <entry>Default</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>tableName</entry>

              <entry>jdo_keygen</entry>

              <entry>Name of the keygen lookup table.</entry>
            </row>

            <row>
              <entry>keyColumnName</entry>

              <entry>table_name</entry>

              <entry>Name of the table name column.</entry>
            </row>

            <row>
              <entry>valueColumnName</entry>

              <entry>last_used_id</entry>

              <entry>Name of the last used number column.</entry>
            </row>

            <row>
              <entry>keyColumnLength</entry>

              <entry>64</entry>

              <entry>Length of the table name column.</entry>
            </row>

            <row>
              <entry>grabSize</entry>

              <entry>10</entry>

              <entry>The number of instances created per keygen table update.
              Using a grabSize &#62; 1 improves performance but may result in
              &#34;holes&#34; in the sequence.</entry>
            </row>

            <row>
              <entry>start</entry>

              <entry>0</entry>

              <entry>If a table has no keygen row and start is 0 then the
              first primary key will be &#34;select max(id) from table&#34; +
              1. Otherwise start is the first primary key.</entry>
            </row>

            <row>
              <entry>createTable</entry>

              <entry>true</entry>

              <entry>If false the keygen table is left out of the generated
              schema.</entry>
            </row>

            <row>
              <entry>pkConstraint</entry>

              <entry>pk_{tableName}</entry>

              <entry>Name of the primary key constraint for the keygen table.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section id="md_jdbc_link_table">
      <title>jdbc-link-table<indexterm><primary>jdbc-link-table extension</primary></indexterm></title>

      <para>Set properties of the link table used to store a collection, map
      or array field. This extension supports the following nested extensions
      (defaults apply if not present):</para>

      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Nested extension</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>jdbc-table-name</entry>

              <entry>The name of the link table.</entry>
            </row>

            <row>
              <entry>jdbc-owner-ref</entry>

              <entry>The column(s) that reference the class containing the
              field that the link table is for. If the owning class has a
              composite primary key then use nested jdbc-ref extensions to
              change column properties (see <xref linkend="md_jdbc_ref" />).
              Otherwise use jdbc-column extensions.</entry>
            </row>

            <row>
              <entry>jdbc-sequence</entry>

              <entry>The sequence number column for collections that are
              ordered (e.g. List&#39;s) to maintain the ordering. Use nested
              jdbc-column extensions (see <xref linkend="md_jdbc_column" />)
              to change the properties of this column.</entry>
            </row>

            <row>
              <entry>jdbc-key</entry>

              <entry>The key column(s) for maps. If the key is a simple type
              (e.g. String) or a reference to a PC class with a single column
              primary key then use nested jdbc-column extensions to change
              column properties (see <xref linkend="md_jdbc_column" />). If
              the key is a reference to a composite primary key class then use
              nested jdbc-ref extensions (see <xref linkend="md_jdbc_ref" />).</entry>
            </row>

            <row>
              <entry>jdbc-value</entry>

              <entry>The value column(s). If the value or element is a simple
              type (e.g. String) or a reference to a PC class with a single
              column primary key then use nested jdbc-column extensions to
              change column properties (see <xref linkend="md_jdbc_column" />).
              If the value is a reference to a composite primary key class
              then use nested jdbc-ref extensions (see <xref
              linkend="md_jdbc_ref" />).</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>Here is an example for the link table for a List of String&#39;s.
      The name of the table is set to &#39;user_email&#39; and JDBC type of
      the sequence column is SMALLINT and its name is priority.</para>

      <programlisting>&#60;field name=&#34;emailAddressList&#34;&#62;
    &#60;collection element-type=&#34;String&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-link-table&#34;&#62;
            &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-table-name&#34;
                value=&#34;user_email&#34; /&#62;
            &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-sequence&#34;&#62;
                &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-column&#34;&#62;
                    &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-column-name&#34;
                        value=&#34;priority&#34; /&#62;
                    &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-type&#34;
                        value=&#34;SMALLINT&#34; /&#62;
                &#60;/extension&#62;
            &#60;/extension&#62;
            &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-value&#34;&#62;
                &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-column&#34;&#62;
                    &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-column-name&#34;
                        value=&#34;email&#34; /&#62;
                &#60;/extension&#62;
            &#60;/extension&#62;
        &#60;/extension&#62;
    &#60;/collection&#62;
&#60;/field&#62;</programlisting>
    </section>

    <section id="md_jdbc_optimistic_locking">
      <title>jdbc-optimistic-locking<indexterm><primary>jdbc-optimistic-locking
      extension</primary></indexterm></title>

      <para>Control optimistic locking for a class. This can be set at
      datastore and class level. The value set at datastore level becomes the
      default for all classes in that datastore. Optimistic locking prevents
      changes made in one transaction from overwriting changes committed by
      another transaction after the instance in the first transaction had been
      read. This avoids the need to pin a database connection to a
      PersistenceManager for the duration of a transaction to maintain
      database locks.</para>

      <para>All the optimistic locking modes add extra where clauses to the
      update statement to check that the instance has not been changed since
      it was read. If no row is modified by the update a
      <classname>za.co.hemtech.jdo.common.JdoConcurrentUpdateException</classname>
      is thrown. This is done even if the transaction is using pessimistic
      locking as other concurrent transactions may be using optimistic
      locking.</para>

      <table>
        <title>JDBC Optimistic Locking Options</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>jdbc-optimistic-locking</entry>

              <entry>description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>none</entry>

              <entry>Do not detect concurrent updates.</entry>
            </row>

            <row>
              <entry>version</entry>

              <entry>Use a row version column to detect concurrent updates.
              The version number is incremented on every update and the
              previous version number is included in the where clause.
              <emphasis>This is the fastest and safest optimistic locking mode</emphasis>.</entry>
            </row>

            <row>
              <entry>timestamp</entry>

              <entry>Use a timestamp column to detect concurrent updates. The
              timestamp is set on every update and the previous value is
              included in the where clause. <emphasis>This may not be safe if
              updates happen quicker than the resolution of the timestamp
              field</emphasis>. It is included to support legacy database
              schema&#39;s.</entry>
            </row>

            <row>
              <entry>changed</entry>

              <entry>Include the previous value of all changed columns in the
              where clause. This provides more fine grained optimistic locking
              as different transactions may modify different fields of the
              same instance. <emphasis>This mode can be used when the database
              schema is fixed</emphasis>. Float and double fields are excluded
              as they are not exact.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The version and timestamp optimistic locking modes require an
      extra column for locking. Versant Open Access will automatically add a
      suitable column to the table or you can specify an existing field in
      your class using a nested <command>field-name</command> extension. This
      is useful if the class requires a version number or last modified date
      field for some other purpose. The value for this field will be filled in
      automatically on commit (see <xref linkend="md_autoset" />).</para>

      <programlisting>&#60;class name=&#34;Customer&#34;&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-optimistic-locking&#34;
            value=&#34;timestamp&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;field-name&#34;
                value=&#34;lastModifiedDate&#34; /&#62;
    &#60;/extension&#62;
&#60;/class&#62;</programlisting>
    </section>

    <section id="md_jdbc_pk_constraint_name">
      <title>jdbc-pk-constraint-name<indexterm><primary>jdbc-pk-constraint-name
      extension</primary></indexterm></title>

      <para>Set the name of the primary key constraint for the table for a
      class. The default name is provided by the name generator for the
      datastore of the class.</para>

      <programlisting>&#60;class name=&#34;Category&#34;&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-pk-constraint-name&#34;
        value=&#34;pk_cat&#34; /&#62;
&#60;/class&#62;</programlisting>
    </section>

    <section id="md_jdbc_primary_key">
      <title>jdbc-primary-key<indexterm><primary>jdbc-primary-key extension</primary></indexterm></title>

      <para>Define one or more properties of the primary key column for a
      class using datastore identity. This extension uses nested <link
      linkend="md_jdbc_column">jdbc-column</link> extensions. If the type of
      the primary key column is not compatible with INTEGER then a <link
      linkend="md_jdbc_key_generator">jdbc-key-generator</link> is required to
      persist new instances.</para>

      <programlisting>&#60;class name=&#34;Category&#34;&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-primary-key&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-column&#34;&#62;
            &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-type&#34; value=&#34;SMALLINT&#34; /&#62;
        &#60;/extension&#62;
    &#60;/extension&#62;
&#60;/class&#62;</programlisting>
    </section>

    <section id="md_jdbc_ref">
      <title>jdbc-ref<indexterm><primary>jdbc-ref extension</primary></indexterm></title>

      <para>Define column properties for part of a reference to an application
      identity class using a composite primary key. You must supply one
      jdbc-ref extension for each field in the referenced class&#39;es primary
      key and the value attribute of each must contain the name of the field.
      Composite primary keys are not supported for datastore identity classes.
      This extension may contain zero or more nested <link
      linkend="md_jdbc_column">jdbc-column</link> extensions to change the
      default column properties. Here is an example for a reference to the
      Customer class which has a composite primary key consisting of branch
      and code. The code column from the reference is renamed customer_code.</para>

      <programlisting>&#60;field name=&#34;customer&#34;&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-ref&#34; value=&#34;branch&#34; /&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-ref&#34; value=&#34;code&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-column&#34;&#62;
            &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-column-name&#34;
                value=&#34;customer_code&#34; /&#62;
        &#60;/extension&#62;
    &#60;/extension&#62;
&#60;/field&#62;</programlisting>
    </section>

    <section id="md_jdbc_table_name">
      <title>jdbc-table-name<indexterm><primary>jdbc-table-name extension</primary></indexterm></title>

      <para>Set the name of the table for a class. The default name is
      provided by the name generator for the datastore of the class. This
      extension is also nested inside other extensions to set table names (see
      <link linkend="md_jdbc_link_table">jdbc-link-table</link>).</para>

      <programlisting>&#60;class name=&#34;Category&#34;&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-table-name&#34; value=&#34;cat&#34; /&#62;
&#60;/class&#62;</programlisting>
    </section>

    <section id="md_jdbc_use_join">
      <title>jdbc-use-join<indexterm><primary>jdbc-use-join extension</primary></indexterm></title>

      <para>Set the type of join used to fetch a referenced instance. This
      extension can be used in different contexts but the possible values
      remain the same.</para>

      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>jdbc-use-join and jdbc-use-key-join</entry>

              <entry>description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>no</entry>

              <entry>Do not join to retrieve the fields.</entry>
            </row>

            <row>
              <entry>outer</entry>

              <entry>Use an outer join to retrieve fields.</entry>
            </row>

            <row>
              <entry>inner</entry>

              <entry>Use an inner join to retrieve fields. Using an inner join
              allows the join to extend further across the object graph as
              other joins can be done from the joined table.
              <emphasis>However rows will be lost if the reference contains
              null or database referential integrity is invalid.</emphasis></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <formalpara>
        <title>Setting jdbc-use-join on a class</title>

        <para>The <command>jdbc-use-join</command> value set on a class is the
        default <command>jdbc-use-join</command> value for all fields that
        reference the class. If the model has a Person class with an Address
        field and <command>jdbc-use-join</command> on Address is set to outer
        then an outer join will be done to pickup the Address fields whenever
        Person is read. This will work even if the address on Person is null.
        In an inner join is used and address is null then an exception might
        be thrown or worse <emphasis>rows will be silently dropped from the
        result</emphasis>. The inner join has the advantage that more joins
        may be done from Address to instances it referenced (e.g. Country).</para>
      </formalpara>

      <programlisting>&#60;class name=&#34;Address&#34;&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-use-join&#34; value=&#34;outer&#34; /&#62;
&#60;/class&#62;</programlisting>

      <formalpara>
        <title>Setting jdbc-use-join on a field</title>

        <para>The <command>jdbc-use-join</command> value set on a field is
        used instead of the <command>jdbc-use-join</command> value from the
        referenced class. This also becomes the default value for any fetch
        groups that include the field (see <link linkend="md_fetch_group">fetch-group</link>).</para>
      </formalpara>

      <programlisting>&#60;field name=&#34;address&#34;&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;jdbc-use-join&#34; value=&#34;no&#34; /&#62;
&#60;/field&#62;</programlisting>

      <formalpara id="md_jdbc_use_key_join_para">
        <title>Setting jdbc-use-join on a collection, array or map field</title>

        <para>The <command>jdbc-use-join</command> extension can be set on a
        collection, array and map fields storing persistent class values. The
        default value in this case is inner. The <command>jdbc-use-key-join</command>
        extension behaves in the same way for maps with persistent class keys.</para>
      </formalpara>
    </section>

    <section id="md_jdbc_use_key_join">
      <title>jdbc-use-key-join<indexterm><primary>jdbc-use-key-join extension</primary></indexterm></title>

      <para>See <link linkend="md_jdbc_use_key_join_para">jdbc-use-join</link>
      and <link linkend="md_fetch_group">fetch-group</link>.</para>
    </section>

    <section id="md_keys_dependent">
      <title>keys-dependent<indexterm><primary>keys-dependent extension</primary></indexterm></title>

      <para>This extension behaves in the same way as <link
      linkend="md_dependent">dependent</link> but is used for maps with
      persistent class keys.</para>
    </section>

    <section id="md_ordered">
      <title>ordered<indexterm><primary>ordered extension</primary></indexterm></title>

      <para>Configure a collection or array as ordered or not (boolean
      extension). By default Versant Open Access preserves the order of
      elements in List&#39;s and arrays by adding a sequence column to the
      table used to store the elements. If the order is not important use this
      option to disable ordering. This extension is also useful in conjunction
      with the <xref linkend="md_ordering" /> extension to order a list based
      on an JDOQL ordering expression.</para>

      <programlisting>&#60;field name=&#34;emailList&#34;&#62;
    &#60;collection element-type=&#34;java.lang.String&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;ordered&#34; value=&#34;false&#34; /&#62;
    &#60;/collection&#62;
&#60;/field&#62;</programlisting>
    </section>

    <section id="md_ordering">
      <title>ordering<indexterm><primary>ordering extension</primary></indexterm></title>

      <para>Order an a collection or array by specifying a JDOQL ordering
      expression (see <xref linkend="jdoql" />). This expression is used to
      generate an <literal>order by</literal> for the SQL query that retrieves
      the elements. It implicitly sets ordered to false (see <xref
      linkend="md_ordered" />). If the element-type of the collection is not
      one of your persistent classes (e.g. <classname>java.lang.String</classname>)
      then use the <literal>this</literal> keyword to refer to the value. The
      only possible expressions in this case are <literal>this ascending</literal>
      and <literal>this descending</literal>.</para>

      <para>Note that the ordering only applies to the initial contents of the
      list populated from the SQL query. No attempt is made to keep the list
      in order as changes are made during normal execution.</para>

      <programlisting>&#60;field name=&#34;studentList&#34;&#62;
    &#60;collection element-type=&#34;Student&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;ordering&#34;
            value=&#34;addr.city ascending, addr.street ascending&#34; /&#62;
    &#60;/collection&#62;
&#60;/field&#62;

&#60;field name=&#34;emailList&#34;&#62;
    &#60;collection element-type=&#34;java.lang.String&#34;&#62;
        &#60;extension vendor-name=&#34;versant&#34; key=&#34;ordering&#34;
            value=&#34;this descending&#34; /&#62;
    &#60;/collection&#62;
&#60;/field&#62;</programlisting>
    </section>

    <section id="md_read_only">
      <title>read-only<indexterm><primary>read-only extension</primary></indexterm></title>

      <para>Set a class to be read-only or not (boolean extension). This can
      be set at class and package level. The value set at package level
      becomes the default value for all classes in the package. Any attempt to
      modify a read only class will result in an exception.
      <emphasis>This feature has not been implemented</emphasis>.</para>

      <programlisting>&#60;class name=&#34;Work&#34;&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;read-only&#34; value=&#34;true&#34; /&#62;
&#60;/class&#62;</programlisting>
    </section>

    <section id="md_oids_in_default_fetch_group">
      <title>oids-in-default-fetch-group<indexterm><primary>oids-in-default-fetch-group
      extension</primary></indexterm></title>

      <para>If this extension is true then the OIDs (primary keys) of
      referenced instances are retrieved along with the default fetch group
      fields. This extension defaults to true as this usually provides better
      performance for a JDBC store (it is expensive to query for fields not
      read during the first select). The <command>oids-in-default-fetch-group</command>
      extension can also be set at datastore level.</para>

      <programlisting>&#60;package name=&#34;tut1.model&#34;&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;oids-in-default-fetch-group&#34;
        value=&#34;false&#34; /&#62;
&#60;/package&#62;</programlisting>
    </section>

    <section id="md_valid_class">
      <title>valid-class<indexterm><primary>valid-class extension</primary></indexterm></title>

      <para>Define a valid class for an interface or Object reference and
      optionally specify the type code for the class. If the type code is not
      specified then the class-id of the class is used. See <xref
      linkend="mapping_interface_field" /> for more information.</para>

      <programlisting>&#60;field name=&#34;owner&#34;&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;valid-class&#34; value=&#34;Resturant=R&#34; /&#62;
    &#60;extension vendor-name=&#34;versant&#34; key=&#34;valid-class&#34; value=&#34;Supplier=S&#34; /&#62;
&#60;/field&#62;</programlisting>
    </section>
  </chapter>

  <appendix id="database_specific_information">
    <title>Database Specific Information</title>

    <para>This appendix provides information specific to each database server
    supported by Versant Open Access and describes the default mapping of JDBC
    types database specific SQL types. For some databases there are specific
    properties that have to be set to enable Versant Open Access to connect to
    the database server. Note that Versant Open Access will most likely work
    with different (especially newer) versions of the database servers listed
    here.</para>

    <para>The connection properties listed in the sections for each supported
    database include the <command>javax.jdo.option.ConnectionDriverName</command>
    option to specify the name of the JDBC driver. If you are using the
    standard driver listed (usually the one supplied by the database vendor)
    then this property can be left out as the <command>javax.jdo.option.ConnectionURL</command>
    is used to guess the driver name.</para>

    <table>
      <title>Database Servers tested with Versant Open Access</title>

      <tgroup cols="4">
        <thead>
          <row>
            <entry>Database</entry>

            <entry>JDBC Driver</entry>

            <entry>Operating System</entry>

            <entry>Notes</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>MySQL 4.0.18</entry>

            <entry>MySQL Connector Java 3.0.9</entry>

            <entry>Linux 2.6.8-gentoo-r3</entry>

            <entry>InnoDB tables only.</entry>
          </row>

          <row>
            <entry>Sybase 15.0</entry>

            <entry>JConnect 6</entry>

            <entry>Linux 2.6.8-gentoo-r3</entry>

            <entry></entry>
          </row>

          <row>
            <entry>Oracle 8.1.7</entry>

            <entry>Oracle thin driver 1.0</entry>

            <entry>Windows 2000 Server</entry>

            <entry>Do not use 10g JDBC driver.</entry>
          </row>

          <row>
            <entry>Oracle 10.1.0 (10g)</entry>

            <entry>Oracle 10g thin driver</entry>

            <entry>Linux 2.6.8-gentoo-r3</entry>

            <entry></entry>
          </row>

          <row>
            <entry>Microsoft SQL Server 2000</entry>

            <entry>Microsoft JDBC Driver 2.0</entry>

            <entry>Windows 2000 Server</entry>

            <entry></entry>
          </row>

          <row>
            <entry>IBM DB2 V8.1</entry>

            <entry>DB2JCC (new type 4 driver)</entry>

            <entry>RedHat Linux 7.3</entry>

            <entry></entry>
          </row>

          <row>
            <entry>Hypersonic SQL 1.7.2 RC2</entry>

            <entry>org.hsqldb.jdbcDriver</entry>

            <entry>Linux 2.6.8-gentoo-r3</entry>

            <entry>Earlier versions do not work.</entry>
          </row>

          <row>
            <entry>Postgres 8.0.1</entry>

            <entry>pg73jdbc2</entry>

            <entry>Linux 2.6.8-gentoo-r3</entry>

            <entry></entry>
          </row>

          <row>
            <entry>Versant ODBMS 7.0.1.0</entry>

            <entry>None required</entry>

            <entry>Windows 2000 Server</entry>

            <entry></entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>The following databases have been successfully tested with Versant
    Open Access in the past but are not tested for every release: Informix
    Dynamic Server 7.31.UD1, Informix Dynamic Server 9.30.UC1, Informix SE
    7.25.UC5X1, Pointbase 4.6, Postgres 7.2.2, Postgres 7.3.1, Cache 5.0.4,
    SAP DB 7.4.3.17, Oracle 9i, MySQL 3.23.49, Interbase 6 and Firebird 1.0.2.</para>

    <para>The following tables show the default JDBC type mappings for each
    supported database (excluding Versant ODBMS which does not use JDBC).
    These can be changed for a datastore using the Versant Open Access
    Workbench (see <xref linkend="field_mapping" />).</para>

    <table>
      <title>Default JDBC Type Mappings (part 1)</title>

      <tgroup cols="6">
        <thead>
          <row>
            <entry>Database</entry>

            <entry>BIT</entry>

            <entry>TINYINT</entry>

            <entry>SMALLINT</entry>

            <entry>INTEGER</entry>

            <entry>BIGINT</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>Cache</entry>

            <entry>BIT</entry>

            <entry>TINYINT</entry>

            <entry>SMALLINT</entry>

            <entry>INTEGER</entry>

            <entry>NUMERIC(18)</entry>
          </row>

          <row>
            <entry>DB2</entry>

            <entry>SMALLINT</entry>

            <entry>SMALLINT</entry>

            <entry>SMALLINT</entry>

            <entry>INTEGER</entry>

            <entry>BIGINT</entry>
          </row>

          <row>
            <entry>Firebird</entry>

            <entry>SMALLINT</entry>

            <entry>SMALLINT</entry>

            <entry>SMALLINT</entry>

            <entry>INTEGER</entry>

            <entry>NUMERIC(18)</entry>
          </row>

          <row>
            <entry>Hypersonic SQL</entry>

            <entry>BIT</entry>

            <entry>TINYINT</entry>

            <entry>SMALLINT</entry>

            <entry>INTEGER</entry>

            <entry>BIGINT</entry>
          </row>

          <row>
            <entry>Informix</entry>

            <entry>SMALLINT</entry>

            <entry>SMALLINT</entry>

            <entry>SMALLINT</entry>

            <entry>INTEGER</entry>

            <entry>NUMERIC(18)</entry>
          </row>

          <row>
            <entry>Informix SE</entry>

            <entry>SMALLINT</entry>

            <entry>SMALLINT</entry>

            <entry>SMALLINT</entry>

            <entry>INTEGER</entry>

            <entry>NUMERIC(18)</entry>
          </row>

          <row>
            <entry>Interbase</entry>

            <entry>SMALLINT</entry>

            <entry>SMALLINT</entry>

            <entry>SMALLINT</entry>

            <entry>INTEGER</entry>

            <entry>NUMERIC(18)</entry>
          </row>

          <row>
            <entry>Microsoft SQL Server</entry>

            <entry>TINYINT</entry>

            <entry>TINYINT</entry>

            <entry>SMALLINT</entry>

            <entry>INTEGER</entry>

            <entry>NUMERIC(18)</entry>
          </row>

          <row>
            <entry>MySQL</entry>

            <entry>BIT</entry>

            <entry>TINYINT</entry>

            <entry>SMALLINT</entry>

            <entry>INTEGER</entry>

            <entry>BIGINT</entry>
          </row>

          <row>
            <entry>Oracle</entry>

            <entry>SMALLINT</entry>

            <entry>SMALLINT</entry>

            <entry>SMALLINT</entry>

            <entry>INTEGER</entry>

            <entry>NUMBER(19)</entry>
          </row>

          <row>
            <entry>Pointbase</entry>

            <entry>BOOLEAN</entry>

            <entry>TINYINT</entry>

            <entry>SMALLINT</entry>

            <entry>INTEGER</entry>

            <entry>BIGINT</entry>
          </row>

          <row>
            <entry>Postgres</entry>

            <entry>SMALLINT</entry>

            <entry>SMALLINT</entry>

            <entry>SMALLINT</entry>

            <entry>INTEGER</entry>

            <entry>BIGINT</entry>
          </row>

          <row>
            <entry>SAP DB</entry>

            <entry>BOOLEAN</entry>

            <entry>SMALLINT</entry>

            <entry>SMALLINT</entry>

            <entry>INTEGER</entry>

            <entry>NUMERIC(19)</entry>
          </row>

          <row>
            <entry>Sybase</entry>

            <entry>TINYINT</entry>

            <entry>TINYINT</entry>

            <entry>SMALLINT</entry>

            <entry>INTEGER</entry>

            <entry>NUMERIC(19)</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <table>
      <title>Default JDBC Type Mappings (part 2)</title>

      <tgroup cols="6">
        <thead>
          <row>
            <entry>Database</entry>

            <entry>NUMERIC</entry>

            <entry>DECIMAL</entry>

            <entry>FLOAT</entry>

            <entry>REAL</entry>

            <entry>DOUBLE</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>Cache</entry>

            <entry>NUMERIC</entry>

            <entry>DECIMAL</entry>

            <entry>FLOAT</entry>

            <entry>REAL</entry>

            <entry>DOUBLE</entry>
          </row>

          <row>
            <entry>DB2</entry>

            <entry>NUMERIC</entry>

            <entry>DECIMAL</entry>

            <entry>FLOAT</entry>

            <entry>REAL</entry>

            <entry>DOUBLE</entry>
          </row>

          <row>
            <entry>Firebird</entry>

            <entry>NUMERIC</entry>

            <entry>DECIMAL</entry>

            <entry>FLOAT</entry>

            <entry>FLOAT</entry>

            <entry>DOUBLE</entry>
          </row>

          <row>
            <entry>Hypersonic SQL</entry>

            <entry>NUMERIC</entry>

            <entry>DECIMAL</entry>

            <entry>FLOAT</entry>

            <entry>REAL</entry>

            <entry>DOUBLE</entry>
          </row>

          <row>
            <entry>Informix</entry>

            <entry>NUMERIC</entry>

            <entry>DECIMAL</entry>

            <entry>FLOAT</entry>

            <entry>REAL</entry>

            <entry>DOUBLE PRECISION</entry>
          </row>

          <row>
            <entry>Informix SE</entry>

            <entry>NUMERIC</entry>

            <entry>DECIMAL</entry>

            <entry>FLOAT</entry>

            <entry>REAL</entry>

            <entry>DOUBLE PRECISION</entry>
          </row>

          <row>
            <entry>Interbase</entry>

            <entry>NUMERIC</entry>

            <entry>DECIMAL</entry>

            <entry>FLOAT</entry>

            <entry>FLOAT</entry>

            <entry>DOUBLE</entry>
          </row>

          <row>
            <entry>Microsoft SQL Server</entry>

            <entry>NUMERIC</entry>

            <entry>DECIMAL</entry>

            <entry>FLOAT</entry>

            <entry>REAL</entry>

            <entry>DOUBLE PRECISION</entry>
          </row>

          <row>
            <entry>MySQL</entry>

            <entry>NUMERIC</entry>

            <entry>DECIMAL</entry>

            <entry>FLOAT</entry>

            <entry>FLOAT</entry>

            <entry>DOUBLE</entry>
          </row>

          <row>
            <entry>Oracle</entry>

            <entry>NUMERIC</entry>

            <entry>DECIMAL</entry>

            <entry>FLOAT</entry>

            <entry>REAL</entry>

            <entry>DOUBLE PRECISION</entry>
          </row>

          <row>
            <entry>Pointbase</entry>

            <entry>NUMERIC</entry>

            <entry>DECIMAL</entry>

            <entry>FLOAT</entry>

            <entry>REAL</entry>

            <entry>DOUBLE</entry>
          </row>

          <row>
            <entry>Postgres</entry>

            <entry>NUMERIC</entry>

            <entry>DECIMAL</entry>

            <entry>FLOAT</entry>

            <entry>REAL</entry>

            <entry>DOUBLE PRECISION</entry>
          </row>

          <row>
            <entry>SAP DB</entry>

            <entry>NUMERIC</entry>

            <entry>DECIMAL</entry>

            <entry>FLOAT</entry>

            <entry>REAL</entry>

            <entry>DOUBLE PRECISION</entry>
          </row>

          <row>
            <entry>Sybase</entry>

            <entry>NUMERIC</entry>

            <entry>DECIMAL</entry>

            <entry>FLOAT</entry>

            <entry>REAL</entry>

            <entry>DOUBLE PRECISION</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <table>
      <title>Default JDBC Type Mappings (part 3)</title>

      <tgroup cols="6">
        <thead>
          <row>
            <entry>Database</entry>

            <entry>CHAR</entry>

            <entry>VARCHAR</entry>

            <entry>DATE</entry>

            <entry>TIME</entry>

            <entry>TIMESTAMP</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>Cache</entry>

            <entry>CHAR</entry>

            <entry>VARCHAR</entry>

            <entry>DATE</entry>

            <entry>TIME</entry>

            <entry>TIMESTAMP</entry>
          </row>

          <row>
            <entry>DB2</entry>

            <entry>CHAR</entry>

            <entry>VARCHAR</entry>

            <entry>TIMESTAMP</entry>

            <entry>TIMESTAMP</entry>

            <entry>TIMESTAMP</entry>
          </row>

          <row>
            <entry>Firebird</entry>

            <entry>CHAR</entry>

            <entry>VARCHAR</entry>

            <entry>DATE</entry>

            <entry>TIME</entry>

            <entry>TIMESTAMP</entry>
          </row>

          <row>
            <entry>Hypersonic SQL</entry>

            <entry>CHAR</entry>

            <entry>VARCHAR</entry>

            <entry>DATE</entry>

            <entry>TIME</entry>

            <entry>TIMESTAMP</entry>
          </row>

          <row>
            <entry>Informix</entry>

            <entry>CHAR</entry>

            <entry>VARCHAR</entry>

            <entry>DATETIME YEAR TO FRACTION</entry>

            <entry>DATETIME YEAR TO FRACTION</entry>

            <entry>DATETIME YEAR TO FRACTION</entry>
          </row>

          <row>
            <entry>Informix SE</entry>

            <entry>CHAR</entry>

            <entry>CHAR</entry>

            <entry>DATETIME YEAR TO FRACTION</entry>

            <entry>DATETIME YEAR TO FRACTION</entry>

            <entry>DATETIME YEAR TO FRACTION</entry>
          </row>

          <row>
            <entry>Interbase</entry>

            <entry>CHAR</entry>

            <entry>VARCHAR</entry>

            <entry>DATE</entry>

            <entry>TIME</entry>

            <entry>TIMESTAMP</entry>
          </row>

          <row>
            <entry>Microsoft SQL Server</entry>

            <entry>CHAR</entry>

            <entry>VARCHAR</entry>

            <entry>DATETIME</entry>

            <entry>DATETIME</entry>

            <entry>DATETIME</entry>
          </row>

          <row>
            <entry>MySQL</entry>

            <entry>CHAR</entry>

            <entry>VARCHAR</entry>

            <entry>DATETIME</entry>

            <entry>DATETIME</entry>

            <entry>DATETIME</entry>
          </row>

          <row>
            <entry>Oracle</entry>

            <entry>CHAR</entry>

            <entry>VARCHAR2</entry>

            <entry>DATE</entry>

            <entry>DATE</entry>

            <entry>DATE</entry>
          </row>

          <row>
            <entry>Pointbase</entry>

            <entry>CHAR</entry>

            <entry>VARCHAR</entry>

            <entry>DATE</entry>

            <entry>TIME</entry>

            <entry>TIMESTAMP</entry>
          </row>

          <row>
            <entry>Postgres</entry>

            <entry>CHAR</entry>

            <entry>VARCHAR</entry>

            <entry>DATE</entry>

            <entry>TIME</entry>

            <entry>TIMESTAMP</entry>
          </row>

          <row>
            <entry>SAP DB</entry>

            <entry>CHAR</entry>

            <entry>VARCHAR</entry>

            <entry>TIMESTAMP</entry>

            <entry>TIMESTAMP</entry>

            <entry>TIMESTAMP</entry>
          </row>

          <row>
            <entry>Sybase</entry>

            <entry>CHAR</entry>

            <entry>VARCHAR</entry>

            <entry>DATETIME</entry>

            <entry>DATETIME</entry>

            <entry>DATETIME</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <table>
      <title>Default JDBC Type Mappings (part 4)</title>

      <tgroup cols="6">
        <thead>
          <row>
            <entry>Database</entry>

            <entry>CLOB</entry>

            <entry>LONG VARCHAR</entry>

            <entry>BLOB</entry>

            <entry>VARBINARY</entry>

            <entry>LONG VARBINARY</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>Cache</entry>

            <entry>LONGVARCHAR</entry>

            <entry>LONGVARCHAR</entry>

            <entry>LONGVARBINARY</entry>

            <entry>LONGVARBINARY</entry>

            <entry>LONGVARBINARY</entry>
          </row>

          <row>
            <entry>DB2</entry>

            <entry>CLOB</entry>

            <entry>CLOB</entry>

            <entry>BLOB</entry>

            <entry>BLOB</entry>

            <entry>BLOB</entry>
          </row>

          <row>
            <entry>Firebird</entry>

            <entry>BLOB SUB_TYPE 1</entry>

            <entry>BLOB SUB_TYPE 1</entry>

            <entry>BLOB</entry>

            <entry>BLOB</entry>

            <entry>BLOB</entry>
          </row>

          <row>
            <entry>Hypersonic SQL</entry>

            <entry>LONG VARCHAR</entry>

            <entry>LONG VARCHAR</entry>

            <entry>LONG VARBINARY</entry>

            <entry>VARBINARY</entry>

            <entry>LONG VARBINARY</entry>
          </row>

          <row>
            <entry>Informix</entry>

            <entry>TEXT</entry>

            <entry>TEXT</entry>

            <entry>BYTE</entry>

            <entry>BYTE</entry>

            <entry>BYTE</entry>
          </row>

          <row>
            <entry>Informix SE</entry>

            <entry>CHAR(32000)</entry>

            <entry>CHAR(32000)</entry>

            <entry>N/A</entry>

            <entry>N/A</entry>

            <entry>N/A</entry>
          </row>

          <row>
            <entry>Interbase</entry>

            <entry>BLOB SUB_TYPE 1</entry>

            <entry>BLOB SUB_TYPE 1</entry>

            <entry>BLOB</entry>

            <entry>BLOB</entry>

            <entry>BLOB</entry>
          </row>

          <row>
            <entry>Microsoft SQL Server</entry>

            <entry>TEXT</entry>

            <entry>TEXT</entry>

            <entry>IMAGE</entry>

            <entry>VARBINARY</entry>

            <entry>IMAGE</entry>
          </row>

          <row>
            <entry>MySQL</entry>

            <entry>LONGTEXT</entry>

            <entry>LONGTEXT</entry>

            <entry>LONGBLOB</entry>

            <entry>TINYBLOB</entry>

            <entry>LONGBLOB</entry>
          </row>

          <row>
            <entry>Oracle</entry>

            <entry>CLOB</entry>

            <entry>LONG</entry>

            <entry>BLOB</entry>

            <entry>BLOB</entry>

            <entry>LONG RAW</entry>
          </row>

          <row>
            <entry>Pointbase</entry>

            <entry>CLOB</entry>

            <entry>LONG VARCHAR</entry>

            <entry>BLOB</entry>

            <entry>BLOB</entry>

            <entry>BLOB</entry>
          </row>

          <row>
            <entry>Postgres</entry>

            <entry>TEXT</entry>

            <entry>TEXT</entry>

            <entry>BYTEA</entry>

            <entry>BYTEA</entry>

            <entry>BYTEA</entry>
          </row>

          <row>
            <entry>SAP DB</entry>

            <entry>LONG</entry>

            <entry>LONG</entry>

            <entry>LONG BYTE</entry>

            <entry>LONG BYTE</entry>

            <entry>LONG BYTE</entry>
          </row>

          <row>
            <entry>Sybase</entry>

            <entry>TEXT</entry>

            <entry>TEXT</entry>

            <entry>IMAGE</entry>

            <entry>VARBINARY</entry>

            <entry>IMAGE</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <section id="cache">
      <title>Cache <indexterm><primary>Cache</primary></indexterm></title>

      <para>Currently all tables will be generated in the default schema.</para>

      <formalpara>
        <title>Typical Connection Properties</title>

        <para><programlisting>javax.jdo.option.ConnectionURL=jdbc:Cache://[HOST]:[PORT]/[DATABASE_NAME]
javax.jdo.option.ConnectionDriverName=com.intersys.jdbc.CacheDriver
javax.jdo.option.ConnectionUserName=_SYSTEM
javax.jdo.option.ConnectionPassword=SYS</programlisting></para>
      </formalpara>
    </section>

    <section id="db2">
      <title>DB2 <indexterm><primary>DB2</primary></indexterm></title>

      <para>Prepared statement caching is unreliable and not used with DB2.
      You should use the new type 4 JDBC driver if possible (db2jcc.jar). JDBC
      2.0 statement batching is not used when using the old driver
      (db2java.zip).</para>

      <para>The user used to connect to the database must have SELECT rights
      to the view SYSIBM.SYSDUMMY1 for connection validation.</para>

      <formalpara>
        <title>Typical Connection Properties</title>

        <para><programlisting>javax.jdo.option.ConnectionURL=jdbc:db2://[HOST]:[PORT]/[DATABASE_NAME]
javax.jdo.option.ConnectionDriverName=com.ibm.db2.jcc.DB2Driver
javax.jdo.option.ConnectionUserName=david
javax.jdo.option.ConnectionPassword=password</programlisting></para>
      </formalpara>
    </section>

    <section id="firebird">
      <title>Firebird <indexterm><primary>Firebird</primary></indexterm></title>

      <para>The database server must be configured for SQL dialect 3.</para>

      <para>Firebird JCA JDBC 1.0.0-RC2 driver does not support scrollable
      resultsets so random access queries are not supported with this driver (<xref
      linkend="random_access" />).</para>

      <para>Firebird 1.0.2 comes with a ready-to-use library of user defined
      functions. These must be installed on any database used with Versant
      Open Access. UDFs are included in &#60;Interbase&#62;\UDF\ib_udf.dll in
      the Windows version and in /opt/interbase/UDF/ib_udf in Linux/Unix.
      These functions must be declared using the ib_udf.sql script.</para>

      <para>On UNIX:<programlisting>Change to the Interbase bin directory:
   cd /opt/interbase/bin

Using the isql utility, execute the ib_udf.sql script on your database:
   ./isql /path/to/yourdb/yourdb.gdb -i /opt/interbase/examples/ib_udf.sql</programlisting></para>

      <para>On Windows:</para>

      <programlisting>Connect to your database using IBConsole or your IB administration tool.
Execute the ib_udf.sql script located in &#60;InterBase&#62;\examples\udf.</programlisting>

      <formalpara>
        <title>Typical Connection Properties</title>

        <para><programlisting>javax.jdo.option.ConnectionURL=jdbc:firebirdsql:[HOST_NAME]/[PORT:][FULL_PATH_TO_DATABASE_FILE]
javax.jdo.option.ConnectionDriverName=org.firebirdsql.jdbc.FBDriver
javax.jdo.option.ConnectionUserName=SYSDBA
javax.jdo.option.ConnectionPassword=masterkey</programlisting></para>
      </formalpara>
    </section>

    <section id="hypersonic">
      <title>Hypersonic SQL <indexterm><primary>Hypersonic</primary></indexterm></title>

      <para>Prepared statement caching is unreliable and not used with
      Hypersonic.</para>

      <formalpara>
        <title>Typical Connection Properties</title>

        <para><programlisting>javax.jdo.option.ConnectionURL=jdbc:hsqldb:hsql://host/name_of_database
javax.jdo.option.ConnectionDriverName=org.hsqldb.jdbcDriver
javax.jdo.option.ConnectionUserName=sa
javax.jdo.option.ConnectionPassword=</programlisting></para>
      </formalpara>
    </section>

    <section id="informix">
      <title>Informix Dynamic Server<indexterm><primary>Informix</primary></indexterm></title>

      <para>Schema migration is not currently supported on Informix Dynamic
      Server. The following connection properties must be specified to connect
      to Informix:</para>

      <programlisting>INFORMIXSERVER=ifmxserver_tcp</programlisting>

      <para>The value (ifmxserver_tcp) is the name of the Informix server
      instance to connect to (sqlhosts entry).</para>

      <para>The database must be in transaction logging mode. To enable
      logging run the following commands from the command line as the informix
      user:</para>

      <programlisting>ondblog buf [ database_name }

onbar -b -F</programlisting>

      <para>The first command will switch the database to buffered log mode,
      but will not enable it, since informix requires you to do a backup
      before the log is activated, the second command will do a FAKE backup
      and enable the logging mode.</para>

      <para>It is advisable to do a system backup on a production system, and
      not a fake backup like the one above.</para>

      <formalpara>
        <title>Typical Connection Properties</title>

        <para><programlisting>javax.jdo.option.ConnectionURL=jdbc:informix-sqli:[HOST_NAME]:[PORT]/[DATABASE_NAME]
javax.jdo.option.ConnectionDriverName=com.informix.jdbc.IfxDriver
javax.jdo.option.ConnectionUserName=david
javax.jdo.option.ConnectionPassword=password
versant.properties=INFORMIXSERVER=ifmxserver_tcp</programlisting></para>
      </formalpara>
    </section>

    <section id="informixse">
      <title>Informix SE<indexterm><primary>Informix SE</primary></indexterm></title>

      <para>Schema migration is not currently supported on Informix SE. The
      following connection properties must be specified to connect to Informix
      SE:</para>

      <programlisting>INFORMIXSERVER=server_name</programlisting>

      <para>The value (server_name) is the name of the Informix server
      instance to connect to (sqlhosts entry).</para>

      <para>The database must be in transaction logging and ANSI mode. The
      previous Informix SE version 7.25.UC5 (without the X1) has a bug that
      does not allow JDBC connections.</para>

      <para>Informix SE has several restrictions:</para>

      <itemizedlist>
        <listitem>
          <para>No support for VARCHAR columns. Versant Open Access maps
          Strings to CHAR(116) columns instead and trims excess spaces on
          fetch. The default length is only 116 to avoid exceeding maximum
          constraint lengths. If you are not using a String in a constraint
          you can increase this for the field (jdbc-length extension).</para>
        </listitem>

        <listitem>
          <para>No support BLOB or BYTE columns so arrays[] of primitives
          cannot be persisted.</para>
        </listitem>

        <listitem>
          <para>No support CLOB or TEXT columns. Versant Open Access maps
          these types to a CHAR(32000).</para>
        </listitem>

        <listitem>
          <para>No support for the SQL function <methodname>lower(...)</methodname>.
          This means you cannot use the <methodname>toLowerCase()</methodname>
          method in JDOQL filters. If you need this functionality you will
          need to add an extra field with lowercase data to your class.</para>
        </listitem>

        <listitem>
          <para>PreparedStatement pooling is disabled. Informix SE and/or the
          JDBC driver carry information (e.g. update counts) over from one use
          of a PreparedStatement to the next.</para>
        </listitem>
      </itemizedlist>

      <formalpara>
        <title>Typical Connection Properties</title>

        <para><programlisting>versant.db=informixse
javax.jdo.option.ConnectionURL=jdbc:informix-sqli:[HOST_NAME]:[PORT]/[path to DATABASE_NAME]
javax.jdo.option.ConnectionDriverName=com.informix.jdbc.IfxDriver
javax.jdo.option.ConnectionUserName=david
javax.jdo.option.ConnectionPassword=password
versant.properties=INFORMIXSERVER=server_name</programlisting></para>
      </formalpara>
    </section>

    <section id="interbase">
      <title>Interbase <indexterm><primary>Interbase</primary></indexterm></title>

      <para>The database server must be configured for SQL dialect 3.</para>

      <para>The Interclient 2.01 driver does not support scrollable resultsets
      so random access queries are not supported with this driver (<xref
      linkend="random_access" />).</para>

      <para>The Interbase console and any other applications using Interbase
      must be closed when using the jdo-create-db task to drop and recreate
      tables.</para>

      <para>InterBase 6 comes with a ready-to-use library of user defined
      functions. These must be installed on any database used with Versant
      Open Access. UDFs are included in &#60;Interbase&#62;\UDF\ib_udf.dll in
      the Windows version and in /opt/interbase/UDF/ib_udf in Linux/Unix.
      These functions must be declared using the ib_udf.sql script.</para>

      <para>On UNIX:<programlisting>Change to the InterBase bin directory:
   cd /opt/interbase/bin

Using the isql utility, execute the ib_udf.sql script on your database:
   ./isql /path/to/yourdb/yourdb.gdb -i /opt/interbase/examples/ib_udf.sql</programlisting></para>

      <para>On Windows:</para>

      <programlisting>Connect to your database using IBConsole or your IB administration tool.
Execute the ib_udf.sql script located in &#60;InterBase&#62;\examples\udf.</programlisting>

      <formalpara>
        <title>Typical Connection Properties</title>

        <para><programlisting>javax.jdo.option.ConnectionURL=jdbc:interbase:[HOST_NAME]/[PORT:][FULL_PATH_TO_DATABASE_FILE]
javax.jdo.option.ConnectionDriverName=interbase.interclient.Driver
javax.jdo.option.ConnectionUserName=SYSDBA
javax.jdo.option.ConnectionPassword=masterkey</programlisting></para>
      </formalpara>
    </section>

    <section id="mssql">
      <title>Microsoft SQL Server<indexterm><primary>Microsoft SQL Server</primary></indexterm></title>

      <para>Note that Microsoft SQL Server 6.5 is not supported.</para>

      <para>The following connection properties must be specified to connect
      to Micrsoft SQL Server:</para>

      <programlisting>SelectMethod=cursor
DatabaseName=[database_name]</programlisting>

      <formalpara>
        <title>Typical Conection Properties</title>

        <para><programlisting>javax.jdo.option.ConnectionURL=jdbc:microsoft:sqlserver://[Server Name]:[PORT]
javax.jdo.option.ConnectionDriverName=com.microsoft.jdbc.sqlserver.SQLServerDriver
javax.jdo.option.ConnectionUserName=user
javax.jdo.option.ConnectionPassword=password
versant.properties=DatabaseName=[database_name];SelectMethod=cursor</programlisting></para>
      </formalpara>
    </section>

    <section id="mysql">
      <title>MySQL<indexterm><primary>MySQL</primary></indexterm></title>

      <para>Only InnoDB tables are supported and referential integrity
      constraints are not generated for MySQL.</para>

      <para>The MySQL JDBC driver always downloads all query results in one go
      when the query is executed. It does not stream results as they are
      accessed. Queries that return a lot of rows (instances) use a lot of
      memory.</para>

      <para>MySQL strips trailing whitespace from VARCHAR columns
      (http://sql-info.de/mysql/gotchas.html#1_6). So String and other fields
      mapped to VARCHAR columsn are trimmed.</para>

      <para>Fixing this is on the TODO list for version 5.0:
      http://dev.mysql.com/doc/mysql/en/todo-mysql-5-0.html</para>

      <formalpara>
        <title>Typical Connection Properties</title>

        <para><programlisting>javax.jdo.option.ConnectionURL=jdbc:mysql://[HOST]:[PORT]/[database_name]
javax.jdo.option.ConnectionDriverName=com.mysql.jdbc.Driver
javax.jdo.option.ConnectionUserName=user
javax.jdo.option.ConnectionPassword=password</programlisting></para>
      </formalpara>
    </section>

    <section id="oracle">
      <title>Oracle<indexterm><primary>Oracle</primary></indexterm></title>

      <para>Versant Open Access maps the JDBC CLOB/BLOB type to CLOB/BLOB
      column and the JDBC LONGVARCHAR type to a LONG column. There are many
      restrictions on LONG columns. See <xref linkend="oracle_long_columns" />for
      more information.</para>

      <para>Oracle keeps an open cursor for each PreparedStatement. For this
      reason Versant Open Access will by default cache only 30
      PreparedStatements per connection on Oracle. You can change this using
      the Workbench datastore properties dialog (<command>File | Datastore
      Properties | Pool Settings tab</command>).</para>

      <para>We have found that the Oracle 10g JDBC driver does
      <emphasis>not</emphasis> work with Oracle 8 and 9 (Oracle documentation
      says that it does).</para>

      <formalpara>
        <title>Typical Connection Properties</title>

        <para><programlisting>javax.jdo.option.ConnectionURL=jdbc:oracle:thin:@[SERVER_NAME]:[PORT]:[DBNAME]
javax.jdo.option.ConnectionDriverName=oracle.jdbc.driver.OracleDriver
javax.jdo.option.ConnectionUserName=system
javax.jdo.option.ConnectionPassword=manager</programlisting></para>
      </formalpara>

      <para>It has been reported that Oracle Light works with Open Access if
      prepared statement caching and batched inserts and updates are disabled.</para>

      <formalpara>
        <title>Connection Properties for Oracle Light</title>

        <para><programlisting>versant.db=oracle
javax.jdo.option.ConnectionDriverName=oracle.lite.poljdbc.POLJDBCDriver
javax.jdo.option.ConnectionURL=jdbc:polite[:uid / pwd]@[host]:[port]:dsn [;key=value]
javax.jdo.option.ConnectionUserName=system
javax.jdo.option.ConnectionPassword=manager
versant.jdbcNobatching=true
versant.jdbcDisablePsCache=true</programlisting></para>
      </formalpara>
    </section>

    <section id="pointbase">
      <title>Pointbase<indexterm><primary>Pointbase</primary></indexterm></title>

      <para>Versant Open Access has been tested with Pointbase 4.6 Server.
      Some of our unit tests fail mysteriously when used with Pointbase
      Embedded.</para>

      <para>Pointbase version 4.5 has an intermittent bug (fixed in 4.6) that
      if a row is updated and immediately selected in the same transaction it
      is not found. By default Versant Open Access will lock the first object
      touched in a datastore transaction using a dummy update on Pointbase.
      This triggers the bug.<programlisting>update table set col=col where pk=1 -- get exclusive lock
select * from table where pk=1
-- On Pointbase 4.5 the select will sometimes not find the row just updated.</programlisting></para>

      <para>Pointbase expects a foreign key references with referential
      integrity constraints to have exactly the same type and length as the
      referenced primary key. The other databases supported by Versant Open
      Access are not as strict. This is normally only an issue when multiple
      fields are mapped to the same column usually for performance reasons.
      Consider the following classes:</para>

      <programlisting>public class Address {
    private String city;
    private Country country;    // mapped to country_code
    private String countryCode; // mapped to country_code
}

public class Country {
    private String code;  // primary key
    private String name;
}</programlisting>

      <para>Adding a String countryCode field to Address makes it possible to
      access the country code without having to navigate the country reference
      (and hence fetch the country instance as well).</para>

      <para>The tables are as follows:</para>

      <programlisting>create table address (
    address_id INTEGER not null,
    city VARCHAR(255),
    country_code VARCHAR(255),
    jdo_version SMALLINT not null,
    constraint pk_address primary key (address_id)
);

create table country (
    code VARCHAR(2) not null,
    nme VARCHAR(40) not null,
    constraint pk_country primary key (code)
);

alter table address add constraint ref_address_country foreign key (country_code) references country(code) match full;</programlisting>

      <para>Pointbase will refuse to add the constraint as
      address.country_code is VARCHAR(255) and country.code is VARCHAR(2). You
      need to edit the mapping for Address.countryCode in the Workbench (or
      .jdo file) and set the jdbc-length to 2 to match the referenced table.</para>

      <formalpara>
        <title>Typical Connection Properties</title>

        <para><programlisting>javax.jdo.option.ConnectionURL=jdbc:pointbase:server://[HOST]:[PORT]/[database_name]
javax.jdo.option.ConnectionDriverName=com.pointbase.jdbc.jdbcUniversalDriver
javax.jdo.option.ConnectionUserName=PBPUBLIC
javax.jdo.option.ConnectionPassword=PBPUBLIC</programlisting></para>
      </formalpara>
    </section>

    <section id="postgres">
      <title>Postgres<indexterm><primary>Postgres</primary></indexterm></title>

      <para>The Postgres JDBC driver uses a lot of memory when working with
      TEXT (clob) and BYTEA (blob) columns. If you encounter &#34;Out of
      Memory&#34; errors when running your application against Postgres you
      may need to increase the size of the heap (-xmx option to java).</para>

      <para>The MySQL JDBC driver always downloads all query results in one go
      when the query is executed. It does not stream results as they are
      accessed. Queries that return a lot of rows (instances) use a lot of
      memory.</para>

      <formalpara>
        <title>Note</title>

        <para>A column of type VARCHAR always allow nulls in the Postgres Data
        Server,so specifying null-value=&#34;exception&#34; for a String field
        on Postgres has no effect.</para>
      </formalpara>

      <formalpara>
        <title>Typical Connection Properties</title>

        <para><programlisting>javax.jdo.option.ConnectionURL=jdbc:postgresql://[SERVER_NAME]/[DATABASE_NAME]
javax.jdo.option.ConnectionDriverName=org.postgresql.Driver
javax.jdo.option.ConnectionUserName=postgres
javax.jdo.option.ConnectionPassword=postgres </programlisting></para>
      </formalpara>
    </section>

    <section id="sapdb">
      <title>SAP DB<indexterm><primary>SAP DB</primary></indexterm></title>

      <para>The JDBC CLOB/BLOB and LONGVARCHAR/LONGVARBINARY types are mapped
      to a LONG / LONG BYTE column. SAP DB version 7.3 has a bug with LONG /
      LONG BYTE columns. If there is more than one LONG / LONG BYTE column in
      an insert statement and the total amount of data is approximately 64K or
      more then the insert fails with the following exception:</para>

      <programlisting>com.sap.dbtech.jdbc.exceptions.DatabaseException: [-3041]: Invalid position</programlisting>

      <para>If there is only one LONG / LONG BYTE column then there is no
      limit to the size of the data. What this means is that you should only
      have one LONG / LONG RAW field per class. If you do have more than one
      the total size of data in the fields must not exceed approximately 64K.</para>

      <para>This bug has been fixed in SAP DB 7.3.0.32 and newer.</para>

      <formalpara>
        <title>Typical Connection Properties</title>

        <para><programlisting>javax.jdo.option.ConnectionURL=jdbc:sapdb://[SERVER_NAME]/[DATABASE_NAME]
javax.jdo.option.ConnectionDriverName=com.sap.dbtech.jdbc.DriverSapDB
javax.jdo.option.ConnectionUserName=test
javax.jdo.option.ConnectionPassword=test </programlisting></para>
      </formalpara>
    </section>

    <section id="sybase">
      <title>Sybase<indexterm><primary>Sybase</primary></indexterm></title>

      <para>You cannot make a JDBC connection to Sybase with a user that has
      no password (i.e. password is null).</para>

      <para>Versant Open Access uses the ANSI-92 SQL syntax when connected to
      Sybase 12 or newer and the older T-SQL syntax when connected to Sybase
      11.92. There are query optimisations that are only reliable with the
      ANSI-92 SQL syntax and some T-SQL queries produce different results on
      Sybase 11.92 and Sybase 12 and up.</para>

      <para>It is recommended that you use JConnect 5.5 to connect to Sybase.
      The JConnect 5.5 driver supports the JDBC 2.0 API including scrollable
      result set&#39;s and can be used with Versant Open Accesss random access
      query support, JConnect 5.0 does not support this functionality.</para>

      <para>Batch inserts and updates are not used with Sybase and JConnect as
      they fail if there are more than a certain number of batches. This
      appears to be a bug in JConnect.</para>

      <formalpara>
        <title>Typical Connection Properties</title>

        <para><programlisting>javax.jdo.option.ConnectionURL=jdbc:sybase:Tds:[SERVER_NAME]:[PORT]/[DATABASE_NAME]
javax.jdo.option.ConnectionDriverName=com.sybase.jdbc2.jdbc.SybDriver
javax.jdo.option.ConnectionUserName=sa
javax.jdo.option.ConnectionPassword=password</programlisting></para>
      </formalpara>
    </section>

    <section id="vds_specific_info">
      <title>Versant ODBMS<indexterm><primary>Versant ODBMS</primary></indexterm><indexterm><primary>VDS</primary></indexterm></title>

      <para>Please see <xref linkend="vds" /> for detailed information on
      using VDS.</para>
    </section>
  </appendix>

  <appendix id="jdo_tutorial">
    <title>JDO Tutorial<indexterm><primary>JDO tutorial</primary></indexterm></title>

    <para>This chapter explains the tut1 demo in <filename>demos/tut1</filename>.
    Tut1 is a simple application that uses Versant Open Access locally or
    connects to a remote Versant Open Access server. The main class persists a
    simple product catalog, queries the catalog, creates an order and changes
    the order. This is intended to be a very simple introduction to JDO
    without any extra complexity (servlets, JSPs, session beans, Swing
    components and so on). You need JDK 1.3.x or JDK 1.4.x and Ant 1.5 to
    build and run this tutorial.</para>

    <para>In local mode the Versant Open Access server runs in the same VM as
    the application using it. This is the normal way to use JDO and works well
    for server side applications (e.g. Web apps) that do not need to interact
    with clients running in remote VMs (e.g. Swing clients) and simple low
    user count Swing applications.</para>

    <para>In remote mode the Versant Open Access server runs in a different
    virtual machine (VM) to the client application. The
    PersistenceManager&#39;s communicate with the server using RMI. This
    deployment option offers performance advantages over simple local
    deployment or value object transfers with session beans. All the remote
    PM&#39;s share a common cache. It is possible to have GUI clients using
    remote PM&#39;s, JSP/Servlets clients and session beans using local
    PM&#39;s running in an application server in the same application. The
    remote PM solves the problems associated with value object transfers
    between the server and the GUI clients (object graphs too big, complex
    code to detect changes etc.).</para>

    <para><table><title>Files in demos/tut1</title><tgroup cols="2"><thead><row><entry>File</entry><entry>Description</entry></row></thead><tbody><row><entry><filename>build.xml</filename></entry><entry>Ant
    build file (Ant 1.5 or newer is required).</entry></row><row><entry><filename>tut1.properties</filename></entry><entry>Versant
    Open Access project file.</entry></row><row><entry><filename>policy.all</filename></entry><entry>Security
    policy file for 3 tier version of demo.</entry></row><row><entry><filename>src/tut1.jdo</filename></entry><entry>JDO
    meta data for the model.</entry></row><row><entry><filename>src/tut1/Main.java</filename></entry><entry>Main
    class.</entry></row><row><entry><filename>src/tut1/model/Category.java</filename></entry><entry>An
    item category.</entry></row><row><entry><filename>src/tut1/model/Customer.java</filename></entry><entry>A
    customer.</entry></row><row><entry><filename>src/tut1/model/Item.java</filename></entry><entry>An
    item in the product catalog.</entry></row><row><entry><filename>src/tut1/model/Order.java</filename></entry><entry>An
    order for one or more items.</entry></row><row><entry><filename>src/tut1/model/OrderLine.java</filename></entry><entry>A
    line on an order (item and quantity.</entry></row></tbody></tgroup></table></para>

    <para>The JDO development process consists of 5 steps:<orderedlist><listitem><para>Write
    and compile normal Java classes to represent your domain objects.</para></listitem><listitem><para>Describe
    the classes to be persisted using JDO meta data.</para></listitem><listitem><para>Enhance
    the classes using the jdo-enhance Ant task.</para></listitem><listitem><para>Generate
    the database schema using the jdo-create-db Ant task or the Workbench.</para></listitem><listitem><para>Run
    or deploy the application.</para></listitem></orderedlist></para>

    <figure>
      <title>Class diagram for tut1.model</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/tut1_model.png" />
        </imageobject>
      </mediaobject>
    </figure>

    <section id="tut1_compiling">
      <title>Compiling the Classes</title>

      <para>Change to <filename>demos/tut1</filename> and run
      <command>ant compile</command> to compile and enhance the classes.</para>
    </section>

    <section id="tut1_editing_meta_data_and_project">
      <title>Editing the Meta Data and Project</title>

      <para>Run <command>workbench.sh</command> (Linux/Unix) or
      <command>workbench.bat</command> (Windows) from the Versant Open Access
      home directory to start the Versant Open Access workbench.<indexterm><primary>running
      the Workbench</primary></indexterm><tip><para>If your
      <filename>openaccess.license</filename> is invalid or not present an
      error dialog will be displayed. Make sure your <filename>openaccess.license</filename>
      is in the <filename>license</filename> directory. You can obtain a free
      evaluation license from <ulink url="http://www.jdogenie.com">http://www.versant.com</ulink>.<indexterm><primary>license
      file</primary></indexterm><indexterm><primary>jdogenie license file</primary></indexterm></para></tip>Choose
      <command>File | Open Project</command> and open <filename>demos/tut1/tut1.properties</filename>.
      The splitter divides the desktop into persistent classes (top) and
      fields (bottom). The <command>Class view</command> dropdown selects the
      columns displayed on the top grid. The <command>Field view</command>
      drop down filters the fields displayed on the bottom grid according to
      category and selects appropriate columns. If the <command>All fields</command>
      checkbox is ticked then fields for all classes are displayed. You can
      click the column headers to sort and choose options from the
      <command>Meta</command> menu to edit additional settings for classes and
      fields. You can quickly see where changes have been made as grid cells
      that have been modified are shown in blue, invalid cells in red and
      fields with all settings left at default values are shown in gray. Most
      drop downs display a selection of possible values and a default value in
      round brackets at the top of the list. If you choose the default then
      nothing is written to the meta data or project file.</para>

      <figure>
        <title>Workbench desktop for tut1</title>

        <screenshot>
          <graphic fileref="images/tut1_Order_lines.png" />
        </screenshot>
      </figure>

      <para>Choose <command>File | Datastore properties</command> and change
      to the <command>Connection</command> tab. This tab controls the database
      connection properties for the project. The project is initially
      configured to connect to a Postgres<footnote><para>Postgres is a full
      featured, free, open source relational database available from <ulink
      url="http://www.postgres.org">http://www.postgres.org.</ulink></para></footnote>
      database called jdo_tut1 on the local machine. Change the connection
      properties to connect to a database available on your own network and
      add a JDBC driver for your database to the Versant Open Access
      <filename>lib</filename> directory. Use the <command>Choose</command>
      button to select the driver name and database type. Use the
      <command>Test</command> button to make sure your connection is working.
      Close the dialog and choose <command>File | Save</command> to save the
      project. The Workbench supports connection properties defined by Ant
      filter tokens by resolving them against a properties file. The right
      hand side of the dialog shows the connection properies after all tokens
      have been resolved. You can have different sets of token properties for
      different environments (development, test and production), one master
      .properties project file and do token replacement using the Ant copy
      task.</para>

      <figure>
        <title>Workbench dialog for tut1 datastores</title>

        <screenshot>
          <graphic fileref="images/tut1_datastores.png" />
        </screenshot>
      </figure>
    </section>

    <section id="tut1_enhance">
      <title>Enhancing the Classes</title>

      <para>Change to <filename>demos/tut1</filename> and run
      <command>ant compile</command> to compile and enhance the compiled
      classes. You must repeat this step if you recompile the classes with an
      IDE or some other tool or if you make changes to the JDO meta data.
      Normally this will happen automatically as your other build targets
      should depend on compile. The compile target uses the Versant Open
      Access <command>jdo-enhance</command> task. To use this task and other
      Versant Open Access tasks in other projects you need to include the
      following Ant taskdef if your build file: <indexterm><primary>Ant tasks</primary></indexterm></para>

      <programlisting>&#60;taskdef resource=&#34;jdogenie.tasks&#34;&#62;
    &#60;classpath&#62;
        &#60;path refid=&#34;cp&#34;/&#62;
        &#60;fileset dir=&#34;${jdo.tools}&#34; includes=&#34;**/*.jar&#34;/&#62;
    &#60;/classpath&#62;
&#60;/taskdef&#62;</programlisting>

      <para>The classpath must include your application classpath (which must
      include all the jars in the Versant Open Access <filename>lib</filename>
      and the <filename>license</filename> directory) and all the jars in the
      <filename>tools</filename> directory. Only the jars in the Versant Open
      Access <filename>lib</filename> directory are required to run your
      application. This taskdef should only be defined once the directory for
      your class files has been created or it will be unable to access the
      compiled classes. In the demo this is done in the init task.</para>

      <para>This is the compile task from <filename>demos/tut1/build.xml</filename>:</para>

      <programlisting>&#60;target name=&#34;compile&#34; depends=&#34;init&#34;
        description=&#34;Compile and enhance all Java sources&#34;&#62;
    &#60;dependset&#62;
        &#60;!-- Delete the classes if the JDO meta data has been changed.
             They need to be recompiled and enhanced. --&#62;
        &#60;srcfileset dir=&#34;${src}&#34; includes=&#34;**/*.jdo&#34;/&#62;
        &#60;targetfileset dir=&#34;${build.classes}&#34; includes=&#34;**/*.class&#34;/&#62;
    &#60;/dependset&#62;
    &#60;javac srcdir=&#34;${src}&#34; destdir=&#34;${build.classes}&#34; classpathref=&#34;cp&#34;/&#62;
    &#60;jdo-enhance project=&#34;${jdo.project}&#34; outputdir=&#34;${build.classes}&#34;&#62;
        &#60;persistentaware dir=&#34;${build.classes}&#34;/&#62;
    &#60;/jdo-enhance&#62;
&#60;/target&#62;</programlisting>

      <para>The <command>dependset</command> task ensures that all the class
      files are deleted (and hence recompiled and enhanced) if any of the .jdo
      meta data files have changed. If the enhanced classes are out of sync
      with the .jdo meta data strange errors result at runtime.</para>
    </section>

    <section id="tut1_generating_db_schema">
      <title>Generating the Database Schema</title>

      <para>Change to <filename>demos/tut1</filename> and run
      <command>ant create-db</command> to recreate the database schema.<warning><para>This
      will drop and recreate all tables with the same names as tables in the
      generated schema for the database URL specified in <filename>demos/tut1/src/tut1.properties</filename>
      (i.e. the one you entered on the datastores tab in the Workbench).</para></warning>The
      database create script is written to <filename>demos/tut1/build/main.sql</filename>.<indexterm><primary>create
      JDBC schema Ant task</primary></indexterm> This is the create-db task
      from <filename>demos/tut1/build.xml</filename>:</para>

      <programlisting>&#60;target name=&#34;create-db&#34; depends=&#34;compile&#34;
        description=&#34;Re-create database schema&#34;&#62;
    &#60;jdo-create-db
            project=&#34;${jdo.project}&#34;
            outputdir=&#34;${build}&#34;
            droptables=&#34;*&#34;
            createtables=&#34;*&#34; /&#62;
&#60;/target&#62;</programlisting>

      <para>The droptables <command>attribute</command> specifies datastores
      to drop tables for with the asterisk indicating all. The
      <command>createtables</command> attribute specifies datastores to create
      tables for by connecting to the database using JDBC. If neither of these
      is present then only scripts are generated. You can also view and
      optionally recreate the schema from the Versant Open Access Workbench.
      Choose the <command>Build | View Schema</command> option to display the
      schema in a window on the desktop.</para>

      <figure>
        <title>Workbench Schema Window</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/tut1_view_schema.png" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The Entity Relationship (ER) diagram for tut1 is shown in <xref
      linkend="tut1_er" />. Note that all model tables have an extra column
      called <varname>jdo_version</varname> for optimistic locking. All
      <literal>String</literal> fields have been mapped to <literal>VARCHAR(255)</literal>
      columns. There is also an extra table called <classname>jdo_keygen</classname>
      for primary key generation. All of these things can be easily customised
      in the meta data using the Workbench.</para>

      <figure id="tut1_er">
        <title>ER Diagram for tut1</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/tut1_er.png" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section id="tut1_running_app">
      <title>Running the application</title>

      <para>Change to <filename>demos/tut1</filename> and run
      <command>ant run</command> to run the application. This compile, enhance
      and run tut1.Main. A lot of output is displayed on the console including
      all SQL generated by Versant Open Access (debugging output from Versant
      Open Access can be disabled). The following sections will explain each
      part of <filename>demos/tut1/src/tut1/Main.java</filename>.</para>
    </section>

    <section id="tut1_importing_jdo_api">
      <title>Importing the JDO API</title>

      <para>This fragment imports the <classname>javax.jdo</classname> package
      to access the JDO development API. Note that there is no need to import
      any Versant Open Access specific classes.</para>

      <programlisting>import javax.jdo.*;</programlisting>
    </section>

    <section id="tut1_obtaining_PMF">
      <title>Obtaining the PMF and PM</title>

      <para>The PersistenceManagerFactory (PMF) is obtained by calling
      <classname>JDOHelper.getPersistenceManagerFactory</classname> with a
      <classname>java.util.Properties</classname> object containing all the
      properties in the <filename>tut1.properties</filename> project file. The
      properties are read from the classpath by the loadProperties helper
      method. The JDOHelper class is part of the JDO API and all compliant
      implementations should be able to start from a Properties instance.</para>

      <para>This application only needs one PersistenceManager (PM) which is
      obtained from the factory. The configuration of this PM is determined by
      the properties in <filename>tut1.properties</filename> which in turn can
      be set using the <command>File | Project Properties</command> option in
      the Workbench. You can also configure the PM by setting properties in
      code.</para>

      <para>The demo supports remote operation (i.e. access to a Versant Open
      Access server from a PersistenceManager in a remote VM) so there is more
      code here than would normally be needed. If the host property is set
      then JDOHelper.getPersistenceManagerFactory will connect to a remote
      Versant Open Access server running on that host. The host property can
      be set from the Project Properties dialog in the workbench in which case
      Versant Open Access will connect to the host by default. The tut1 demo
      removes this property as it uses command line arguments to decide on
      local or remote access.</para>

      <programlisting>public static void main(String[] args) {
    try {
        // load .properties project file as properties to connect
        Properties p = loadProperties();
        p.remove(&#34;host&#34;); // this is set based on command line args

        // process command line args
        boolean server = false;
        if (args.length != 0) {
            if (args.length == 1) {
                String s = args[0];
                if (s.equals(&#34;-server&#34;)) server = true;
                else p.setProperty(&#34;host&#34;, s);
            } else {
                throw new IllegalArgumentException(
                        &#34;Expected: [ -server | &#60;remote host&#62; ]&#34;);
            }
        }

        if (server) {

            // start a Versant Open Access server and wait for connections
            PersistenceManagerFactory pmf =
                JDOHelper.getPersistenceManagerFactory(p);
            // this keeps a reference to the server on the stack so it does
            // not get garbage collected
            System.out.println(
                &#34;Started remote server .. do &#39;ant run-remote&#39; from another &#34; +
                &#34;console (Ctrl-C to exit)&#34;);
            for (;;) Thread.sleep(60 * 1000);

        } else {

            // run against local or remote Versant Open Access server
            PersistenceManagerFactory pmf =
                JDOHelper.getPersistenceManagerFactory(p);
            Main main = new Main(pmf.getPersistenceManager());
            try {
                main.go();
            } finally {
                main.pm.close();
            }
            System.exit(0);
        }
    } catch (Exception e) {
        e.printStackTrace(System.out);
        System.exit(1);
    }
}

private static Properties loadProperties() throws IOException {
    Properties p = new Properties();
    InputStream in = null;
    try {
        in = Main.class.getResourceAsStream(&#34;/tut1.properties&#34;);
        if (in == null) throw new IOException(&#34;tut1.properties not on classpath&#34;);
        p.load(in);
    } finally {
        if (in != null) in.close();
    }
    return p;
}</programlisting>
    </section>

    <section id="tut1_creating_product_catalog">
      <title>Creating the product catalog</title>

      <para>The product catalog is created by persisting 3 Item&#39;s and 2
      Category&#39;s by calling methods on the PM. Note that the Category
      instances are persisted automatically as they are reachable from the
      Item instances. Also note the use of begin and commit for transaction
      control. If this code was running in a session bean method using
      container managed transactions this would not be necessary.</para>

      <programlisting>private void createCatalog() {
    pm.currentTransaction().begin();
    Category dogs = new Category(&#34;Dogs&#34;);
    Category cats = new Category(&#34;Cats&#34;);
    pm.makePersistent(new Item(&#34;D001&#34;, &#34;Wiener Dog&#34;, dogs));
    pm.makePersistent(new Item(&#34;D002&#34;, &#34;Snauzer&#34;, dogs));
    pm.makePersistent(new Item(&#34;C001&#34;, &#34;Persian&#34;, cats));
    // dogs and cats are persisted as they are reachable from the items
    pm.currentTransaction().commit();
}</programlisting>

      <para>The following debug output is generated by Versant Open Access
      when the transaction commits (if you are not using Postgres the SQL will
      be different). The output shows the generation of the primary keys and
      the inserts for the 2 new Categories and 3 new Items. The inserts are
      done in the correct order to avoid violating the foreign key constraint
      between item and category. Note that two SQL connections are used: one
      for key generation and one for the inserts.</para>

      <programlisting>jdbc.con.prepareStat  update jdo_keygen set last_used_id = last_used_id + ?
                      where table_name = &#39;category&#39;
jdbc.stat.execUpdate  [10]
jdbc.con.createStat
jdbc.stat.execQuery   select last_used_id from jdo_keygen
                      where table_name = &#39;category&#39;
jdbc.rs.next
jdbc.rs.close         [10]
jdbc.stat.close
jdbc.stat.close
jdbc.con.commit
jdbc.con.prepareStat  insert into category (category_id, name, jdo_version)
                      values (?, ?, ?)
jdbc.stat.addBatch    [1, Cats, 1]
jdbc.stat.addBatch    [2, Dogs, 1]
jdbc.stat.execBatch   2 param rows
jdbc.stat.close
jdbc.con.prepareStat  update jdo_keygen set last_used_id = last_used_id + ?
                      where table_name = &#39;item&#39;
jdbc.stat.execUpdate  [10]
jdbc.con.createStat
jdbc.stat.execQuery   select last_used_id from jdo_keygen
                      where table_name = &#39;item&#39;
jdbc.rs.next
jdbc.rs.close         [10]
jdbc.stat.close
jdbc.stat.close
jdbc.con.commit
jdbc.con.prepareStat  insert into item (item_id, category_id, code,
                      description, jdo_version) values (?, ?, ?, ?, ?)
jdbc.stat.addBatch    [1, 2, D002, Snauzer, 1]
jdbc.stat.addBatch    [2, 1, C001, Persian, 1]
jdbc.stat.addBatch    [3, 2, D001, Wiener Dog, 1]
jdbc.stat.execBatch   3 param rows
jdbc.stat.close
jdbc.con.commit</programlisting>

      <para>The item table after commit:</para>

      <informaltable>
        <tgroup cols="5">
          <thead>
            <row>
              <entry>item_id</entry>

              <entry>category_id</entry>

              <entry>code</entry>

              <entry>description</entry>

              <entry>jdo_version</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>1</entry>

              <entry>2</entry>

              <entry>D002</entry>

              <entry>Schnauzer</entry>

              <entry>1</entry>
            </row>

            <row>
              <entry>2</entry>

              <entry>1</entry>

              <entry>C001</entry>

              <entry>Persian</entry>

              <entry>1</entry>
            </row>

            <row>
              <entry>3</entry>

              <entry>2</entry>

              <entry>D001</entry>

              <entry>Wiener Dog</entry>

              <entry>1</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>The category table after commit:</para>

      <informaltable>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>category_id</entry>

              <entry>name</entry>

              <entry>jdo_version</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>1</entry>

              <entry>Cats</entry>

              <entry>1</entry>
            </row>

            <row>
              <entry>2</entry>

              <entry>Dogs</entry>

              <entry>1</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>

    <section id="tut1_displaying_product_catalog">
      <title>Displaying the product catalog</title>

      <para>This method illustrates the use of a simple JDO query to retrieve
      all the items in the catalog in description order.<itemizedlist><listitem><para>The
      <classname>javax.jdo.Query</classname> instance is created by calling
      <classname>pm.newQuery(Item.class)</classname>.</para></listitem><listitem><para>The
      query is created and run outside of a transaction using an optional JDO
      feature called non-transactional reads.</para></listitem><listitem><para>Only
      the order is specified for the query so we will get all Item instances
      in the database.</para></listitem><listitem><para>The execute method on
      Query returns an Object which must be cast to a Collection (this is for
      future API expansion).</para></listitem><listitem><para>The only method
      on this collection that may be called is iterator().</para></listitem><listitem><para>Actual
      Item instances are returned by the Iterator.</para></listitem><listitem><para>A
      finally block is used to close the Collection. This will free any
      resources associated with the result (e.g. JDBC ResultSet&#39;s).</para></listitem></itemizedlist></para>

      <programlisting>private void showCatalog() {
    Query q = pm.newQuery(Item.class);
    q.setOrdering(&#34;description ascending&#34;);
    Collection ans = null;
    try {
        ans = (Collection)q.execute();
        System.out.println(&#34;Catalog items in description order:&#34;);
        for (Iterator i = ans.iterator(); i.hasNext(); ) {
            Item item = (Item)i.next();
            System.out.println(item.getCode() + &#34;, &#34; + item.getDescription() +
                &#34;, &#34; + item.getCategory().getName());
        }
        System.out.println(&#34;---&#34;);
    } finally {
        if (ans != null) q.close(ans);
    }
}</programlisting>

      <para>The following debug output is generated by Versant Open Access
      when this method runs. There are no queries to lookup fields for the
      Category for each item as the categories are in the Versant Open Access
      cache.</para>

      <programlisting>jdbc.con.prepareStat  select item_id, category_id, code, description, jdo_version
                      from item order by description
jdbc.stat.execQuery
jdbc.rs.next
jdbc.rs.next          [2, 1, C001, Persian, 1]
jdbc.rs.next          [1, 2, D002, Snauzer, 1]
jdbc.rs.next          [3, 2, D001, Wiener Dog, 1]
jdbc.rs.next
jdbc.rs.close
jdbc.stat.close</programlisting>
    </section>

    <section xreflabel="" id="tut1_lookup_item">
      <title>Looking up an Item by code</title>

      <para>This method retrieves an Item by code. It illustrates the use of
      filter expressions and parameters in JDOQL queries. The parameter is
      declared using the <methodname>declareParameters</methodname> method on
      Query. This accepts a list of parameters using the same syntax as for a
      Java method declaration. The <methodname>setFilter</methodname> call
      sets the filter expression using syntax very similar to normal Java
      boolean expressions to specify which items to include in the result.
      Note the <literal>==</literal> operator is used instead of
      <methodname>equals()</methodname> to compare the strings.</para>

      <programlisting>private Item lookupItem(String code) {
    Query q = pm.newQuery(Item.class);
    q.declareParameters(&#34;String c&#34;);
    q.setFilter(&#34;code == c&#34;);
    Collection ans = null;
    try {
        ans = (Collection)q.execute(code);
        Iterator i = ans.iterator();
        if (i.hasNext()) return (Item)i.next();
        throw new IllegalArgumentException(&#34;No item with code: &#39;&#34; + code + &#34;&#39;&#34;);
    } finally {
        if (ans != null) q.close(ans);
    }
}</programlisting>

      <para>The following debug output is generated by Versant Open Access
      when this method is called with <literal>code=&#34;D001&#34;</literal>.
      Note that only the <varname>item_id</varname> column is read from the
      <classname>ResultSet</classname> as the item is in cache so there is no
      need to read the other columns.</para>

      <programlisting>jdbc.con.prepareStat  select item_id, category_id, code, description, jdo_version
                      from item where code = ?
jdbc.stat.execQuery   [D001]
jdbc.rs.next
jdbc.rs.next          [3]
jdbc.rs.close
jdbc.stat.close</programlisting>
    </section>

    <section id="tut1_creating_an_order">
      <title>Creating an Order</title>

      <para>This method creates an order with two lines. It uses the
      lookupItem method to get the Item instances. Persisting the order will
      also persist the order lines as they are reachable through the
      <varname>lines</varname> list on <classname>Order</classname>. The OID
      (Object ID) for the new Order is converted to a String returned. This
      String can be easily converted back into an OID and used to retrieve the
      Order.</para>

      <programlisting>private String createOrder() {
    pm.currentTransaction().begin();
    Order o = new Order(new Customer(&#34;DOE001&#34;, &#34;John Doe&#34;));
    o.addLine(new OrderLine(lookupItem(&#34;D001&#34;), 3));
    o.addLine(new OrderLine(lookupItem(&#34;C001&#34;), 1));
    pm.makePersistent(o);
    pm.currentTransaction().commit();
    return pm.getObjectId(o).toString();
}</programlisting>
    </section>

    <section id="tut1_amending_order">
      <title>Amending an Order</title>

      <para>This method retrieves the order created earlier by constructing an
      OID and calling getObjectById on the PM. This is the most efficient way
      to retrieve an object using JDO. The quantity of each line on the order
      is set to 1. These changes are automatically applied to the database
      when the transaction commits.</para>

      <programlisting>private void amendOrder(String orderNo) {
    pm.currentTransaction().begin();
    Object oid = pm.newObjectIdInstance(Order.class, orderNo);
    Order o = (Order)pm.getObjectById(oid, false);
    for (Iterator i = o.getLines().iterator(); i.hasNext(); ) {
        OrderLine ol = (OrderLine)i.next();
        ol.setQty(1);
    }
    pm.currentTransaction().commit();
}</programlisting>

      <para>The following debug output is generated by Versant Open Access
      when the transaction commits.</para>

      <programlisting>jdbc.con.prepareStat  update order_line set qty=?, jdo_version=?
                      where order_line_id = ? and jdo_version=?
jdbc.stat.addBatch [1, 2, 2, 1]
jdbc.stat.addBatch [1, 2, 1, 1]
jdbc.stat.execBatch 2 param rows
jdbc.stat.close
jdbc.con.commit</programlisting>
    </section>

    <section id="tut1_complex_query">
      <title>A More Complex Query</title>

      <para>Here is an example of a much more complex query. This uses a
      variable to place conditions on an element in a collection.</para>

      <programlisting>private void complexQuery() {
    Query q = pm.newQuery(Order.class);
    q.declareParameters(&#34;String c, int n, java.util.Date d&#34;);
    q.declareVariables(&#34;OrderLine v&#34;);
    q.setFilter(
        &#34;orderDate &#62; d &#38;&#38; lines.contains(v) &#38;&#38; v.item.code == c &#38;&#38; v.qty &#62; n&#34;);
    q.setOrdering(&#34;orderDate descending&#34;);
    Calendar weekAgo = new GregorianCalendar();
    weekAgo.add(Calendar.DAY_OF_YEAR, -7);
    Collection ans = null;
    try {
        ans = (Collection)q.execute(&#34;D001&#34;, new Integer(5), weekAgo.getTime());
        System.out.println(
            &#34;Orders for Item D001 with qty &#62; 5 placed in the last week:&#34;);
        for (Iterator i = ans.iterator(); i.hasNext(); ) {
            Order order = (Order)i.next();
            System.out.println(order);
        }
        System.out.println(&#34;---&#34;);
    } finally {
        if (ans != null) q.close(ans);
    }
}</programlisting>

      <para>Versant Open Access converts the query into the following Postgres
      SQL.</para>

      <programlisting>select a.orderNo, a.customer_id, a.order_date, a.orderNo, a.jdo_version
from ordr AS a
where a.order_date &#62; ?
  and exists (
      select 1
      from order_line AS b
           JOIN item AS c ON (b.item_id = c.item_id)
      where a.orderNo = b.orderNo
        and c.code = ?
        and b.qty &#62; ?)
order by a.order_date DESC</programlisting>

      <para>When run against Sybase 11.92 the following SQL is produced
      instead. JDO completely hides the differences between the SQL dialects.</para>

      <programlisting>select a.orderNo, a.customer_id, a.order_date, a.orderNo, a.jdo_version
from ordr a
where a.order_date &#62; ?
  and exists (
      select 1
      from order_line b, item c
      where a.orderNo = b.orderNo
        and b.item_id = c.item_id
        and c.code = ?
        and b.qty &#62; ?)
order by a.order_date DESC</programlisting>
    </section>

    <section id="tut1_jdoql_in_workbench">
      <title>Running Queries in the Workbench<indexterm><primary>JDOQL in
      Workbench</primary></indexterm></title>

      <para>The Versant Open Access Workbench provides an interactive JDOQL
      query window invoked using <command>Run | New JDOQL</command>. The
      results of a query (instances of your persistence-capable classes) are
      displayed as a tree for interactive navigation. The Workbench starts a
      Versant Open Access Engine to run your queries so the persistent classes
      must have been compiled and enhanced.</para>

      <figure>
        <title>Interactive JDOQL Queries in the Workbench</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/tut1_q1.png" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The tree in result window shows the persistent fields of each
      instance. Fields that have not been loaded are shown in gray. If an
      unloaded field is clicked it is loaded and the SQL is displayed on the
      console (and in the event log). If you change meta data you will need to
      recompile and enhance your classes and restart the Versant Open Access
      Engine by choosing <command>Run | Run Engine</command>.</para>

      <figure>
        <title>Exploring JDOQL Results</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/tut1_q3.png" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section id="tut1_remote_pm">
      <title>Three Tier Operation</title>

      <para>The tut1 demo can be run in 3-tier mode by starting a Versant Open
      Access server on one console and running the demo in remote mode from
      another console. Change to <filename>demos/tut1</filename> and run
      <command>ant -server</command> to start the tut1 Versant Open Access
      server. Open another console and run <command>ant run-remote</command>
      to run the demo against the server just started. <emphasis>Note that
      there is no need to change any of the application code!</emphasis></para>
    </section>

    <section id="tut1_using_management_console">
      <title>Using the Management Console</title>

      <para>The Versant Open Access Workbench has a Management Console that
      can connect to a remote Versant Open Access server configured to allow
      remote access. Any Versant Open Access server can be accessed even one
      deployed into an application server. Change to <filename>demos/tut1</filename>
      and run <command>ant -server</command> to start the tut1 Versant Open
      Access server. Start the Workbench and choose <command>Run | Management
      Console</command> open a Management Console window. Note that there is
      no need to open a project to manage to a remote Versant Open Access
      server. The Console will display information about the Versant Open
      Access server running in the Workbench by default. Click the Connect
      button open a dialog to connect to a remote Versant Open Access server.</para>

      <figure>
        <title>Connecting to the tut1 Server</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/connect_remote_server.png" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>Click the add button to add a new Versant Open Access server to
      the list. Enter tut1 in the server name field and click connect. You can
      now use the Management Console to control server settings, view the
      server event log, see who is connected to the server and so on.</para>

      <figure>
        <title>Management Console for the tut1 Server</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/management_console_tut1.png" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>
  </appendix>

  <appendix id="jdo_tutorial_session_bean">
    <title>JDO Session Bean Tutorial</title>

    <para>This chapter explains the tut1sb_jca session bean demo in
    <filename>&#60;OPENACCESS_HOME&#62;/demos/tut1sb_jca.</filename> This is a
    simple application that uses Versant Open Access from a session bean.
    Versant Open Access is deployed as a JCA adapter into the application
    server. The main class makes calls to the session bean to persist a simple
    product catalog, query the catalog and create an order. This tutorial is
    very similar to the 2 tier tut1 tutorial (see <xref linkend="jdo_tutorial" />)
    and concepts covered there are not repeated here (enhancement etc.).
    Currently Versant Open Access supports BEA WebLogic 7.0,8.1, JBoss 3.0,
    Borland 6.5 and IBM WebSphere 5.1. You should also read <xref
    linkend="ejb_applications" />.</para>

    <para><table><title>Files in demos/tut1sb_jca</title><tgroup cols="2"><thead><row><entry>File</entry><entry>Description</entry></row></thead><tbody><row><entry><filename>common.xml</filename></entry><entry>Ant
    1.6 build file.</entry></row><row><entry><filename>versant.properties</filename></entry><entry>Versant
    Open Access project file.</entry></row><row><entry><filename>versant.workbench</filename></entry><entry>Versant
    Open Access workbench file.</entry></row><row><entry><filename>common.properties</filename></entry><entry>Ant
    properties file for all the ant build files.</entry></row><row><entry><filename>borland65.xml</filename></entry><entry>Borland
    6.5 specific ant build file.</entry></row><row><entry><filename>jboss3.xml</filename></entry><entry>JBoss
    specific ant build file.</entry></row><row><entry><filename>weblogic81.xml</filename></entry><entry>Weblogic
    specific ant build file.</entry></row><row><entry><filename>websphere51.xml</filename></entry><entry>WebSphere
    5.1 specific ant build file.</entry></row><row><entry><filename>README.txt</filename></entry><entry>README
    file for demo.</entry></row><row><entry><filename>etc/client/application-client.xml</filename></entry><entry>J2EE
    application client descriptor for WebSphere 5.1.</entry></row><row><entry><filename>etc/client/ibm-application-client-bnd.xmi</filename></entry><entry>J2EE
    application client bindings for WebSphere 5.1.</entry></row><row><entry><filename>etc/client/MANIFEST.MF</filename></entry><entry>J2EE
    application client manifest for WebSphere 5.1.</entry></row><row><entry><filename>etc/ear/application.xml</filename></entry><entry>EAR
    deployment descriptor.</entry></row><row><entry><filename>etc/ear/websphere/application.xml</filename></entry><entry>EAR
    deployment descriptor for WebSphere 5.1.</entry></row><row><entry><filename>etc/ear/websphere/ibm-application-bnd.xmi</filename></entry><entry>EAR
    deployment binding for WebSphere 5.1.</entry></row><row><entry><filename>etc/ear/websphere/.modulemaps</filename></entry><entry>File
    for importing EAR into WASD 5.1</entry></row><row><entry><filename>etc/ear/borland/application.xml</filename></entry><entry>EAR
    deployment descriptor for Borland 6.5.</entry></row><row><entry><filename>etc/ear/borland/application-borland.xml</filename></entry><entry>EAR
    deployment binding for Borland 6.5.</entry></row><row><entry><filename>etc/ejb/websphere/MANIFEST.MF</filename></entry><entry>EJB
    Manifest file for WebSphere 5.1.</entry></row><row><entry><filename>etc/ejb/ejb-jar.xml</filename></entry><entry>EJB
    deployment descriptor.</entry></row><row><entry><filename>etc/ejb/ibm-ejb-jar-bnd.xmi</filename></entry><entry>WebSphere
    5.1 EJB deployment descriptor.</entry></row><row><entry><filename>etc/ejb/jboss.xml</filename></entry><entry>JBoss
    EJB deployment descriptor.</entry></row><row><entry><filename>etc/ejb/weblogic-ejb-jar.xml</filename></entry><entry>Weblogic
    EJB deployment descriptor.</entry></row><row><entry><filename>etc/ejb/ejb-borland.xml</filename></entry><entry>Borland
    5.1 EJB deployment descriptor.</entry></row><row><entry><filename>src/tut1.jdo</filename></entry><entry>JDO
    meta data for the model.</entry></row><row><entry><filename>src/tut1/Main.java</filename></entry><entry>Main
    class to invoke the session bean.</entry></row><row><entry><filename>src/tut1/Tut1.java</filename></entry><entry>Tut1
    session bean remote interface.</entry></row><row><entry><filename>src/tut1/Tut1Home.java</filename></entry><entry>Tut1
    session bean home interface.</entry></row><row><entry><filename>src/tut1/Tut1EJB.java</filename></entry><entry>Tut1
    session bean.</entry></row><row><entry><filename>src/tut1/model/Category.java</filename></entry><entry>An
    item category.</entry></row><row><entry><filename>src/tut1/model/Customer.java</filename></entry><entry>A
    customer.</entry></row><row><entry><filename>src/tut1/model/Item.java</filename></entry><entry>An
    item in the product catalog.</entry></row><row><entry><filename>src/tut1/model/Order.java</filename></entry><entry>An
    order for one or more items.</entry></row><row><entry><filename>src/tut1/model/OrderLine.java</filename></entry><entry>A
    line on an order (item and quantity).</entry></row></tbody></tgroup></table></para>

    <section id="tut1sb_config">
      <title>Configuring the tutorial</title>

      <para>Please refer to the Specific Application Server section for more
      details.</para>

      <section id="tut1sb_deploy_weblogic">
        <title>WebLogic 8.1</title>

        <para>Refer to <xref linkend="tut1_editing_meta_data_and_project" />for
        instructions on how to configure database settings. The demo is per
        configured to connect to a Postgres database called jdo_test on the
        local machine.</para>

        <para>You should also put the JDBC driver for your database on the
        system classpath of your application server. For WebLogic 7.0 you need
        to edit the startup script to include your driver on the classpath.</para>

        <para>In the <filename>&#60;OPENACCESS_HOME&#62;/demos/tut1sb_jca/common.properties</filename>
        file you must set the <command>wl81.home </command>property to the
        place where WebLogic is installed ie. <command>wl81.home=C:\bea\weblogic81</command>.</para>

        <para>Ant 6.0 or later is required to run this build file. The ant
        build file must be run with the -f option ( <command>ant -f
        weblogic81.xml &#60;target&#62;</command> ).</para>

        <para>The following ant targets are available:</para>

        <para><table><title>Ant targets for weblogic81.xml build file</title><tgroup
        cols="2"><thead><row><entry>Target</entry><entry>Description</entry></row></thead><tbody><row><entry>clean</entry><entry>Delete
        all generated files.</entry></row><row><entry>client</entry><entry>Create
        the Client jar file.</entry></row><row><entry>compile</entry><entry>Compile
        source.</entry></row><row><entry>create-db</entry><entry>Re-create
        database schema.</entry></row><row><entry>deploy</entry><entry>Deploy
        application to server.</entry></row><row><entry>deploy_jca</entry><entry>Deploy
        JCA to server.</entry></row><row><entry>ear</entry><entry>Create the
        Application ear file.</entry></row><row><entry>ejb</entry><entry>Create
        the EJB jar file.</entry></row><row><entry>init</entry><entry>Initialize
        environment.</entry></row><row><entry>run-test</entry><entry>Run
        client against server.</entry></row><row><entry>start-server</entry><entry>Start
        the application server.</entry></row><row><entry>stop-server</entry><entry>Stop
        the application server.</entry></row></tbody></tgroup></table></para>
      </section>

      <section id="tut1sb_deploy_jboss">
        <title>JBoss 3</title>

        <para>Refer to <xref linkend="tut1_editing_meta_data_and_project" />for
        instructions on how to configure database settings. The demo is per
        configured to connect to a Postgres database called jdo_test on the
        local machine.</para>

        <para>You should also put the JDBC driver for your database on the
        system classpath of your application server. For JBoss 3.0 put it in
        <filename>&#60;JBOSS_HOME&#62;/server/default/lib</filename> (assuming
        you are using the default server).</para>

        <para>In the <filename>&#60;OPENACCESS_HOME&#62;/demos/tut1sb_jca/common.properties</filename>
        file you must set the <command>jboss.home</command> property to the
        place where JBoss is installed ie. <command>jboss.home=C:\jboss-3.2.5</command>.</para>

        <para>Ant 6.0 or later is required to run this build file.The ant
        build file must be run with the -f option ( <command>ant -f jboss3.xml
        &#60;target&#62;</command> ).</para>

        <para>The following ant targets are available:</para>

        <para><table><title>Ant targets for jboss3.xml build file</title><tgroup
        cols="2"><thead><row><entry>Target</entry><entry>Description</entry></row></thead><tbody><row><entry>clean</entry><entry>Delete
        all generated files.</entry></row><row><entry>client</entry><entry>Create
        the Client jar file.</entry></row><row><entry>compile</entry><entry>Compile
        source.</entry></row><row><entry>create-db</entry><entry>Re-create
        database schema.</entry></row><row><entry>deploy</entry><entry>Deploy
        application to server.</entry></row><row><entry>deploy_jca</entry><entry>Deploy
        JCA to server.</entry></row><row><entry>ear</entry><entry>Create the
        Application ear file.</entry></row><row><entry>ejb</entry><entry>Create
        the EJB jar file.</entry></row><row><entry>init</entry><entry>Initialize
        environment.</entry></row><row><entry>run-test</entry><entry>Run
        client against server.</entry></row><row><entry>start-server</entry><entry>Start
        the application server.</entry></row><row><entry>stop-server</entry><entry>Stop
        the application server.</entry></row></tbody></tgroup></table></para>
      </section>

      <section id="tut1sb_deploy_borland">
        <title>Borland Application Server 6.5</title>

        <para>Refer to <xref linkend="tut1_editing_meta_data_and_project" />for
        instructions on how to configure database settings. The demo is per
        configured to connect to a Postgres database called jdo_test on the
        local machine.</para>

        <para>You must also put the JDBC driver for your database in
        <filename>&#60;OPENACCESS_HOME&#62;/lib</filename> directory, the ant
        build file will place it int the JCA adapter.</para>

        <para>In the <filename>&#60;OPENACCESS_HOME&#62;/demos/tut1sb_jca/common.properties</filename>
        file you must set the <command>bes.home</command> property to the
        place where Borland Enterprise Server is installed ie.
        <command>bes.home=C:\Borland\BDP</command>.</para>

        <para>Borland specific ant is required to run this demo, this can be
        found at <filename>&#60;BES_HOME&#62;/bin/ant</filename>.</para>

        <para>The ant build file must be run with the -f option (
        <command>&#60;BES_HOME&#62;/bin/ant -f borland65.xml &#60;target&#62;
        </command>).</para>

        <para>The following ant targets are available:</para>

        <para><table><title>Ant targets for borland65.xml build file</title><tgroup
        cols="2"><thead><row><entry>Target</entry><entry>Description</entry></row></thead><tbody><row><entry>clean</entry><entry>Remove
        all generated files.</entry></row><row><entry>client</entry><entry>Create
        the Client jar file.</entry></row><row><entry>compile</entry><entry>Compile
        source.</entry></row><row><entry>create-db</entry><entry>Re-create
        database schema.</entry></row><row><entry>deploy-ear</entry><entry>Deploy
        the ear file to the server.</entry></row><row><entry>ear</entry><entry>Create
        the Application ear file.</entry></row><row><entry>ejb</entry><entry>Create
        the EJB jar file.</entry></row><row><entry>init</entry><entry>Initialize
        environment.</entry></row><row><entry>jca</entry><entry>Create the JCA
        rar file.</entry></row><row><entry>run</entry><entry>Run the test
        client on the server.</entry></row><row><entry>start-server</entry><entry>Start
        the Borland application server.</entry></row><row><entry>start-server</entry><entry>Start
        the Borland application server.</entry></row><row><entry>undeploy-ear</entry><entry>Un-Deploy
        the Application ear from the server.</entry></row></tbody></tgroup></table></para>
      </section>

      <section id="tut1sb_deploy_websphere5">
        <title>WebSphere Application Studio Developer 5.1</title>

        <para>Refer to <xref linkend="tut1_editing_meta_data_and_project" />for
        instructions on how to configure database settings. The demo is per
        configured to connect to a Postgres database called jdo_test on the
        local machine.</para>

        <para>You must also put the JDBC driver for your database in
        <filename>&#60;OPENACCESS_HOME&#62;/lib</filename> directory, the ant
        build file will place it int the JCA adapter.</para>

        <para>In the <filename>&#60;OPENACCESS_HOME&#62;/demos/tut1sb_jca/common.properties</filename>
        file you must set the <command>websphere.studio.home</command>
        property to the place where WebSphere Studio Application Developer is
        installed ie. <command>websphere.studio.home=C:\IBM\WebSphereStudio\ApplicationDeveloper\v5.1.2</command>.</para>

        <para>The ant build file must be run with the -f option (
        <command>ant -f websphere51.xml &#60;target&#62; </command>).</para>

        <para>The following ant targets are available:</para>

        <para><table><title>Ant targets for websphere51.xml build file</title><tgroup
        cols="2"><thead><row><entry>Target</entry><entry>Description</entry></row></thead><tbody><row><entry>clean</entry><entry>Remove
        all generated files.</entry></row><row><entry>client</entry><entry>Create
        the Client jar file.</entry></row><row><entry>compile</entry><entry>Compile
        source.</entry></row><row><entry>create-db</entry><entry>Re-create
        database schema.</entry></row><row><entry>ear</entry><entry>Create the
        Application ear file.</entry></row><row><entry>ejb</entry><entry>Create
        the EJB jar file.</entry></row><row><entry>init</entry><entry>Initialize
        environment.</entry></row><row><entry>jca</entry><entry>Create the JCA
        rar file.</entry></row></tbody></tgroup></table></para>

        <para>First we must generate the database schema:</para>

        <orderedlist>
          <listitem>
            <para>On the command line move to the following directory
            <filename>&#60;OPENACCESS_HOME&#62;/demos/tut1sb-jca</filename></para>
          </listitem>

          <listitem>
            <para>Run the following command <command>ant -f websphere51.xml
            create-db</command></para>
          </listitem>
        </orderedlist>

        <para>The database schema has now been created, now we will generate a
        Application EAR file to be imported into WASD:</para>

        <orderedlist>
          <listitem>
            <para>On the command line move to the following directory
            <filename>&#60;OPENACCESS_HOME&#62;/demos/tut1sb-jca</filename></para>
          </listitem>

          <listitem>
            <para>Run the following command <command>ant -f websphere51.xml
            ear</command></para>
          </listitem>
        </orderedlist>

        <para>We have now created the following EAR file <filename>&#60;OPENACCESS_HOME&#62;/demos/tut1sb-jca/build/dist/tut1sb-jca.ear</filename>.</para>

        <para>To import the EAR file into WASD do the following steps:</para>

        <orderedlist>
          <listitem>
            <para>In WASD select the <command>J2EE</command> perspective.</para>
          </listitem>

          <listitem>
            <para>Right Click on <command>Enterprise Applications</command>
            and go to <command>Import | Import EAR...</command>.</para>
          </listitem>

          <listitem>
            <para>In the Enterprise Application Import pop up screen browse to
            <filename>&#60;OPENACCESS_HOME&#62;/demos/tut1sb-jca/build/dist/tut1sb-jca.ear</filename>
            EAR File, and select <command>Finish</command>.</para>
          </listitem>
        </orderedlist>

        <para>The EAR file is now imported, Now we have to configure WASD so
        that it will do the enhancement step, If the WASD plugin has not been
        installed, do so now (see <xref linkend="wasd_plugin" />).</para>

        <orderedlist>
          <listitem>
            <para>In WASD select the <command>Java</command> perspective<command>.
            </command></para>
          </listitem>

          <listitem>
            <para>In the Package Explorer Right Click tut1sb (This is where
            the jdo classes can be found), and select Versant OpenAccess | Add
            JDO Nature</para>
          </listitem>

          <listitem>
            <para>On the top menu bar select Project | Properties, and select
            Versant OpenAccess Properties.</para>
          </listitem>

          <listitem>
            <para>In the Project file name browse to
            ejbModule/versant.properties, and select OK .</para>
          </listitem>
        </orderedlist>

        <para>The class files will now be auto enhanced. Next we will
        configure the JCA adapter:</para>

        <orderedlist>
          <listitem>
            <para>In WASD select the <command>J2EE</command> perspective.</para>
          </listitem>

          <listitem>
            <para>Under <command>Servers</command>, double click the server
            that you want the Connector to run on. If there are no servers
            configured create a new server now, and then double click it.</para>
          </listitem>

          <listitem>
            <para>Select the <command>J2C</command> tab.</para>
          </listitem>

          <listitem>
            <para>Move down to the <command>Server Settings </command>section,
            and click <command>Add</command> at the <command>J2C Resource
            Adapters </command>.</para>
          </listitem>

          <listitem>
            <para>Select openaccess as the <command>Resource Adapter Name</command>.
            And click <command>OK </command>.</para>
          </listitem>

          <listitem>
            <para>Select openaccess in the <command>J2C Resource Adapters</command>
            view. And move to the <command>J2C Connection Factories</command>
            section.</para>
          </listitem>

          <listitem>
            <para>In the <command>J2C Connection Factories</command> section
            select <command>Add</command>.</para>
          </listitem>

          <listitem>
            <para>On the <command>Create Connection Factory</command> pop up
            screen, enter <command>versant</command> in the
            <command>Name</command> property, and <command>jdo/jdo_tut1sb_jca</command>
            as the <command>JNDI Name</command> (this will be the name that
            you will use to lookup OpenAccess). The rest of the settings can
            be configured as required.</para>
          </listitem>

          <listitem>
            <para>Move down to the <command>Resource Properties</command>
            section, and change the <command>ForceConnectionMatching</command>
            property to true.</para>
          </listitem>

          <listitem>
            <para>Save the server settings and close the tab.</para>
          </listitem>
        </orderedlist>

        <para>The JCA adapter is now configured. Next we must make the session
        bean ready for deployment:</para>

        <orderedlist>
          <listitem>
            <para>In WASD select the <command>J2EE</command> perspective.</para>
          </listitem>

          <listitem>
            <para>Move to the <command>EJB Modules</command>, and under it
            Right Click on the <command>tut1sb</command> module and select
            <command>Generate | Deployment and RMIC Code...</command></para>
          </listitem>

          <listitem>
            <para>On the <command>Generate Deployment and RMIC Code</command>
            pop up screen click <command>Select all</command> and
            <command>Finish</command>.</para>
          </listitem>
        </orderedlist>

        <para>The EAR project is now configured. To run the project do the
        following:</para>

        <orderedlist>
          <listitem>
            <para>In WASD select the <command>J2EE</command> perspective.</para>
          </listitem>

          <listitem>
            <para>Under the Enterprise Applications right click tut1sb-jca:
            VersantTut1 and select <command>Run on Server</command>.</para>
          </listitem>

          <listitem>
            <para>On the <command>Server selection</command> pop up screen
            select the server that you have installed the JCA adapter on and
            click <command>Finish</command>.</para>
          </listitem>
        </orderedlist>

        <para>You can use the <command>IBM Universal Test Client</command> to
        test the session bean (the JNDI name is Tut1).</para>
      </section>
    </section>
  </appendix>

  <appendix id="workbench_reference">
    <title>Workbench Reference</title>

    <para>This appendix is a reference to all the forms and dialogs in the
    Versant Open Access workbench. This information is displayed in tooltips.
    Pressing <command>shift-F1</command> will open this manual in your browser
    positioned to the last displayed tooltip help.</para>

    <section id="wbref_project_props">
      <title>Project Properties Dialog</title>

      <para>This dialog edits settings stored in the <filename>.properties</filename>
      project file that apply to all datastores.</para>

      <section id="wbref_general_tab">
        <title>General Tab</title>

        <figure>
          <title>Project Properties General Tab</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/project_properties_general.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <section id="wbref_general_tab_misc">
          <title>Miscellaneous</title>

          <formalpara id="hyperdrive_classes">
            <title>Hyperdrive classes<indexterm><primary>hyperdrive classes</primary></indexterm></title>

            <para>Hyperdrive classes are generated when the Versant Open
            Access server starts. In our tests they improve the overall server
            performance by at least 3 times. They can be disabled to improve
            server startup time for quicker build-run-test cycles during
            development.</para>
          </formalpara>

          <formalpara id="default_flush_threshold">
            <title>Default flush threshold<indexterm><primary>default flush
            threshold</primary></indexterm></title>

            <para>The default flush threshold value used for new
            PersistenceManagers. When a transaction accumulates this many
            dirty or new JDO instances changes are flushed to the database to
            allow unreferenced instances to be garbage collected.</para>
          </formalpara>
        </section>

        <section id="remote_access_options">
          <title>Remote Access</title>

          <para>These options control remote access to the Versant Open Access
          server. Remote access can be used for monitoring and for remote
          persistence managers. See <xref linkend="architecture" />and <xref
          linkend="remote_access" />for more information.</para>

          <formalpara id="server_name">
            <title>JDO server name<indexterm><primary>server name</primary></indexterm></title>

            <para>The name of the JDO engine or server. This must be unique on
            a machine and is used to name and lookup the server for remote
            access.</para>
          </formalpara>

          <formalpara id="rmi_registry_port">
            <title>RMI registry port<indexterm><primary>RMI registry port</primary></indexterm></title>

            <para>A Versant Open Access server with remote access enabled will
            lookup or create an RMI registry on this port and bind itself.</para>
          </formalpara>

          <formalpara id="allow_remote_access">
            <title>Remote access<indexterm><primary>remote access</primary></indexterm></title>

            <para>Tick this box to enable remote connections to the Versant
            Open Access server. If this is false then the server will not
            lookup or create a RMI registry and no remote access will be
            possible.</para>
          </formalpara>

          <formalpara id="allow_remote_pms">
            <title>Remote PMs<indexterm><primary>remote PMs</primary></indexterm></title>

            <para>Tick this box to enable remote clients to create persistence
            managers. Note that if &#34;Remote Access&#34; is false then this
            option has no effect.</para>
          </formalpara>

          <formalpara id="remote_username">
            <title>Remote username<indexterm><primary>remote username</primary></indexterm></title>

            <para>Remote applications attempting to connect to the Versant
            Open Access server must supply this username if not blank.</para>
          </formalpara>

          <formalpara id="remote_password">
            <title>Remote password<indexterm><primary>remote password</primary></indexterm></title>

            <para>Remote applications attempting to connect to the Versant
            Open Access server must supply this password if not blank.</para>
          </formalpara>
        </section>

        <section id="options_for_getPMF">
          <title>Options for JDOHelper.getPersistenceManagerFactory</title>

          <para>These options control the default properties of
          PersistenceManager&#39;s created from the PersistenceManagerFactory
          (PMF) returned by JDOHelper.getPersistenceManagerFactory. This is
          the standard vendor independent way to create a JDO PMF.</para>

          <formalpara id="optimistic">
            <title>Optimistic<indexterm><primary>optimistic</primary></indexterm></title>

            <para>Set the default transaction mode for PM&#39;s. With
            optimistic (true) transactions database locks are not held during
            a transaction. Versant Open Access supports several methods of
            detecting concurrent updates (see <xref
            linkend="md_jdbc_optimistic_locking" />) when the transaction
            commits. With pessimistic or datastore transactions (false) a JDBC
            connection is associated with the PM for the duration of the
            transaction and database locks are accumulated.</para>
          </formalpara>

          <formalpara id="retain_values">
            <title>Retain values<indexterm><primary>retain values</primary></indexterm></title>

            <para>Set the default retain values setting for PM&#39;s. If
            retain values is true then the PM will not evict instances from
            its local cache when the transaction commits. This is useful when
            combined with optimistic transactions.</para>
          </formalpara>

          <formalpara id="restore_values">
            <title>Restore values<indexterm><primary>restore values</primary></indexterm></title>

            <para>Set the default restore values setting for PM&#39;s. If
            restore values is true and a transaction is rolled back then
            instances are restored to the state they were in when they joined
            the transaction.</para>
          </formalpara>

          <formalpara id="ignore_cache">
            <title>Ignore cache<indexterm><primary>ignore cache</primary></indexterm></title>

            <para>Set the default ignore cache setting for PM&#39;s. If ignore
            cache is true then queries will only return instances that exist
            in the database. New instances and changes to existing instances
            will be ignored by queries. Query execution will be slightly
            faster.</para>
          </formalpara>

          <formalpara id="non_transactional_read">
            <title>Nontransactional read<indexterm><primary>nontransactional
            read</primary></indexterm></title>

            <para>Set the default nontransactional read setting for PM&#39;s.
            If nontransactional read is true then references may be navigated
            and queries executed outside of a JDO transaction.</para>
          </formalpara>

          <formalpara id="non_transactional_write">
            <title>Nontransactional write<indexterm><primary>nontransactional
            write</primary></indexterm></title>

            <para>Set the default nontransactional write setting for PM&#39;s.
            If nontransactional write is true then instances may be modified
            outside of a JDO transaction.</para>
          </formalpara>

          <formalpara id="multithreaded">
            <title>Multithreaded<indexterm><primary>multithreaded</primary></indexterm></title>

            <para>Set the default multithreaded setting for PM&#39;s. If
            multithreaded is true then a PM may be used from more than one
            thread at the same time. <emphasis>This optional feature is not
            currently supported and is included for completeness</emphasis>.</para>
          </formalpara>

          <formalpara id="datastore_tx_locking">
            <title>Datastore Tx Locking<indexterm><primary>datastore tx
            locking</primary></indexterm></title>

            <para>Set the default locking mode used in datastore
            (non-optimistic) transactions.</para>
          </formalpara>
        </section>

        <section id="datastores">
          <title>Datastores</title>

          <para>A datastore is required for each physical database you need to
          work with. If some of your model classes are mapped to an Oracle
          database and some are mapped to a Sybase database (or a different
          Oracle database) then you need to create two datastores. Datastore
          properties control how mapping is done for classes in the datastore.
          Each class may have a datastore set on it. Classes not explicitly
          assigned to a datastore default to the first datastore in the list.
          <emphasis>The multiple datastores feature has not been completed and
          will be enabled in the Enterprise edition of Versant Open Access.</emphasis></para>
        </section>
      </section>

      <section id="cache2">
        <title>Cache Tab</title>

        <para>Enable or disable server wide caching, choose the cache listener
        class and configure its properties on this tab. You can use Ant filter
        tokens as the values for properties. These are resolved against your
        project filter token file in the Workbench (see the Connection tab on
        the Datastore Properties dialog).</para>

        <formalpara id="cache_listener_class">
          <title>Cluster transport<indexterm><primary>cluster transport</primary></indexterm></title>

          <para>Choose the cluster transport plugin notified when objects are
          evicted from the server wide cache. There is no cluster transport by
          default. Any class implementing VersantClusterTransport can be used
          and should communicate the evictions to other nodes in the cluster.
          Cluster transport plugins are supplied for Tangosol Coherence and
          JavaGroups. <emphasis>This feature is only available in the
          Enterprise version of Versant Open Access.</emphasis></para>
        </formalpara>

        <formalpara id="cache_max_objects">
          <title>Cache max objects<indexterm><primary>cache max objects</primary></indexterm></title>

          <para>Set the maximum number of objects stored in the server wide
          cache. The least recently used objects are evicted when the cache is
          full.</para>
        </formalpara>

        <formalpara id="use_cache">
          <title>Enabled<indexterm><primary>cache enabled</primary></indexterm></title>

          <para>Enable or disable the shared cache. If the cache is enabled
          instances read by one PM are stored and available to other PM&#39;s.
          This greatly improves performance for most applications. Caching can
          also be controlled on a per class basis (see <xref
          linkend="md_cache_strategy" />). The cache should be disabled if
          your application has more than one Versant Open Access engine active
          at the same time (e.g. multiple instances of a 2-tier application)
          and you are not using a cluster aware cache listener.</para>
        </formalpara>
      </section>

      <section id="event_logging">
        <title>Event Logging Tab</title>

        <para>Configure event logging properties on this tab. Remember that
        logging events does impact performance. You can use Ant filter tokens
        as the values for properties. These are resolved against your project
        filter token file in the Workbench (see the Connection tab on the
        Datastore Properties dialog).</para>
      </section>

      <section id="pm_pooling">
        <title>PM Pooling Tab<indexterm><primary>persistence manager pooling</primary></indexterm></title>

        <para>Control how Versant Open Access pools persistence managers (PMs)
        on this tab. There are separate settings for the PM pools for remote
        persistence manager factories. Pooling persistence managers improves
        performance by reducing object creation and garbage collection. PMs
        that are closed are put into a pool and reused.</para>

        <para>The local PM pool used by the Versant Open Access server for
        local clients has no upper limit. If you application is leaking PMs it
        will eventually run out of memory. The remote PM pools have an upper
        limit. Because each remote PM uses network resources (sockets and so
        on) it is better to have errors on a leaky remote client then to run
        out of resources on the server. Both local and remote pools support a
        max idle setting to control the maximum number of idle PMs to keep in
        the pool. The pool will shrink if the number of idle PMs exceeds this
        value.</para>

        <formalpara id="pmpool_enabled">
          <title>PM Pool Enabled<indexterm><primary>pm pool enabled</primary></indexterm></title>

          <para>Enable or disable persistence manager pooling. This option is
          for debugging and should be left on.</para>
        </formalpara>

        <formalpara id="pmpool_max_idle">
          <title>PM Pool Max Idle<indexterm><primary>pm pool max idle</primary></indexterm></title>

          <para>If there are more then this many idle persistence managers in
          the pool it will shrink.</para>
        </formalpara>

        <formalpara id="remote_pmpool_enabled">
          <title>Remote PM Pool Enabled<indexterm><primary>remote pm pool
          enabled</primary></indexterm></title>

          <para>Enable or disable persistence manager pooling for remote PM
          factories. Disabling the pool will reduce the number of network
          connections used by remote clients.</para>
        </formalpara>

        <formalpara id="remote_pmpool_max_idle">
          <title>Remote PM Pool Max Idle<indexterm><primary>remote pm pool max
          idle</primary></indexterm></title>

          <para>If there are more then this many idle persistence managers in
          a remote pool it will shrink.</para>
        </formalpara>

        <formalpara id="remote_pmpool_max_active">
          <title>Remote PM Pool Max Active<indexterm><primary>remote pm pool
          max active</primary></indexterm></title>

          <para>This is an upper limit to the size of a remote PM pool. Once
          this is reached calls to PMF.getPersistenceManager will receive
          exceptions.</para>
        </formalpara>
      </section>
    </section>

    <section id="wbref_datastore_props">
      <title>Datastore Properties Dialog</title>

      <para>This dialog edit setting stored in the <filename>.properties</filename>
      project file for a datastore. These include database connection
      properties, connection pool settings, JDBC options, defaults for classes
      in the store, default key generator configuration, Java and JDBC type
      mappings and JDBC name generation.</para>

      <section id="wbref_connection">
        <title>Connection Tab<indexterm><primary>connection tab</primary></indexterm></title>

        <figure>
          <title>Datastore Properties Connection Tab</title>

          <screenshot>
            <graphic fileref="images/tut1_datastores.png" />
          </screenshot>
        </figure>

        <formalpara id="datastore_name">
          <title>Datastore name<indexterm><primary>datastore name</primary></indexterm></title>

          <para>The name for the datastore. This must be unique within a
          project.</para>
        </formalpara>

        <formalpara id="database_type">
          <title>Database type<indexterm><primary>database type</primary></indexterm></title>

          <para>The type of database server (postgres, oracle, sybase etc.).
          You can use the Choose button to select from a list of supported
          database types and JDBC driver classes.</para>
        </formalpara>

        <formalpara id="jdbc_driver_class">
          <title>JDBC driver class<indexterm><primary>JDBC driver class</primary></indexterm></title>

          <para>The name of the JDBC driver to use to connect to the database.
          The jar file(s) containing the driver must be on the project
          classpath or the classpath of the Workbench itself. You can use the
          Choose button to select from a list of supported database types and
          JDBC driver classes.</para>
        </formalpara>

        <formalpara id="connection_url">
          <title>URL<indexterm><primary>connection url</primary></indexterm></title>

          <para>The JDBC database URL to connect to. The Choose button will
          fill in a sample URL for the selected database type.</para>
        </formalpara>

        <formalpara id="connection_user">
          <title>User<indexterm><primary>connection user</primary></indexterm></title>

          <para>The username used to connect to the database.</para>
        </formalpara>

        <formalpara id="connection_password">
          <title>Password<indexterm><primary>connection password</primary></indexterm></title>

          <para>The password used to connect to the database.</para>
        </formalpara>

        <formalpara id="connection_properties">
          <title>Properties<indexterm><primary>connection properties</primary></indexterm></title>

          <para>Extra connection properties required by the JDBC driver.
          Properties usually required are filled in when the Choose button is
          used to select a database type. Use &#34;key=value&#34; format and
          put each property on a separate line.</para>
        </formalpara>

        <formalpara id="project_ant_token_file">
          <title>Project Ant token file<indexterm><primary>project Ant token
          file</primary></indexterm></title>

          <para>The name of the file used to resolve Ant filter tokens. This
          applies to the whole project not just the selected datastore. Ant
          filter tokens make it easy to modify your project file when
          deploying your application to different environments. The filter
          token file provides values for these tokens for use by the Workbench
          so it can connect to the database.</para>
        </formalpara>
      </section>

      <section id="wbref_pool_settings">
        <title>Pool Settings Tab<indexterm><primary>pool settings tab</primary></indexterm></title>

        <para>See <xref linkend="pool_settings_tab" /> for information on
        configuring connection pool settings.</para>
      </section>

      <section id="wbref_settings_tab">
        <title>Settings Tab</title>

        <para>This tab edits class defaults, JDBC options and properties for
        the default JDBC name generator for the datastore.</para>

        <section id="datastore_class_defaults">
          <title>Class Defaults</title>

          <para>These settings control the default values for meta data
          extensions for all classes in the datastore.</para>

          <formalpara id="datastore_optimistic_locking">
            <title>Optimistic locking mode<indexterm><primary>optimistic
            locking</primary></indexterm></title>

            <para>The default optimistic locking mode (see <xref
            linkend="md_jdbc_optimistic_locking" />).</para>
          </formalpara>

          <formalpara id="datastore_cache_strategy">
            <title>Cache strategy<indexterm><primary>cache strategy</primary></indexterm></title>

            <para>The default cache strategy for classes in this datastore
            (see <xref linkend="md_cache_strategy" />). This can be set to
            &#34;no&#34; to not cache instances, &#34;yes&#34; to cache
            instances and &#34;all&#34; to cache all instances the first time
            an instance loaded.</para>
          </formalpara>

          <formalpara id="datastore_do_not_create_table">
            <title>Do not create table<indexterm><primary>do not create table</primary></indexterm></title>

            <para>The default &#34;do not create table&#34; setting. Note that
            if you set this to true then Versant Open Access will only create
            tables for classes in this datastore that explicitly set it to
            false in the meta data. This is useful when working with legacy
            databases. See <xref linkend="md_jdbc_do_not_create_table" />.</para>
          </formalpara>

          <formalpara id="datastore_oids_in_dfg">
            <title>OIDs in default FG<indexterm><primary>OIDs in default fetch
            group</primary></indexterm></title>

            <para>The default &#34;OIDs in default fetch group&#34; setting
            (see <xref linkend="md_oids_in_default_fetch_group" />).</para>
          </formalpara>
        </section>

        <section id="datastore_jdbc_options">
          <title>JDBC Options</title>

          <para>These settings control JDBC options for the datastore.</para>

          <formalpara id="isolation_level">
            <title>Isolation Level<indexterm><primary>isolation level</primary></indexterm></title>

            <para>Set the JDBC transaction isolation level used. Note that
            this option is silently ignored on databases that do not support
            configurable isolation levels.</para>
          </formalpara>

          <formalpara id="disable_jdbc_batching">
            <title>Disable JDBC 2.0 statement batching<indexterm><primary>JDBC
            statement batching</primary></indexterm><indexterm><primary>disable
            JDBC 2.0 batching</primary></indexterm></title>

            <para>Disable JDBC 2.0 statement batching. Versant Open Access
            will use batch inserts and updates whenever possible as this
            feature makes it possible to insert or update multiple rows with a
            single database call. However JDBC drivers often give very poor
            error messages when a batch fails (e.g. &#34;batch update
            failed&#34; instead of &#34;unique constraint XXX violated&#34;).
            You might want to disable batching for a while to track down a
            problem.</para>
          </formalpara>

          <formalpara id="disable_ps_cache">
            <title>Disable PreparedStatement cache<indexterm><primary>PreparedStatement
            cache</primary></indexterm><indexterm><primary>disable
            PreparedStatement cache</primary></indexterm></title>

            <para>Disable PreparedStatement caching. Versant Open Access will
            cache JDBC PreparedStatements to improve performance. This feature
            may consume additional database resources for each connection so
            you may want to turn it off.</para>
          </formalpara>

          <formalpara id="validate_mapping_on_startup">
            <title>Validate mapping on startup<indexterm><primary>validate
            mapping on startup</primary></indexterm></title>

            <para>Check the mapping against the database schema when the
            server starts. If the mapping is invalid then the server will fail
            with an exception indicating what is wrong (e.g. missing tables
            and columns). If the mapping is not validated then the application
            will fail when the invalid class or classes are accessed.</para>
          </formalpara>
        </section>

        <section id="datastore_default_keygen">
          <title>Default key generator</title>

          <para>Configure the default key generator for classes and set its
          properties on this tab. See <xref linkend="md_jdbc_key_generator" />
          for more information.</para>

          <formalpara id="datastore_keygen_class">
            <title>Key generator<indexterm><primary>key generator</primary></indexterm></title>

            <para>Choose the class of the default key generator factory for
            classes in this datastore. This can be any class that implements
            <classname>com.versant.core.jdbc.JdbcKeyGeneratorFactory</classname>.
            The source for this interface and the default HIGHLOW key
            generator are included in the distribution in the
            <filename>src</filename> directory. The properties of the
            &#34;argBean&#34; returned by the factory are introspected and
            displayed on the grid.</para>
          </formalpara>
        </section>
      </section>

      <section id="datastore_namegen">
        <title>Name Generator Tab</title>

        <para>Configure the name generator set its properties on this tab.
        This is responsible for generating default names for tables, columns
        and other database schema objects.</para>

        <formalpara id="datastore_namegen_class">
          <title>Name generator<indexterm><primary>name generator</primary></indexterm></title>

          <para>Choose the class of the default name generator for the
          datastore. This can be any class that implements
          <classname>com.versant.core.jdbc.sql.JdbcNameGenerator</classname>.
          The source for this interface and the default name generator are
          included in the distribution in the <filename>src</filename>
          directory. This class is introspected to find its properties which
          can be edited on the grid.</para>
        </formalpara>
      </section>
    </section>

    <section id="wbref_class_props">
      <title>Class Properties Window</title>

      <para>You can view and edit class properties using this Window. You can
      leave it open and select different classes on the classes grid.</para>

      <formalpara id="cp_class_name">
        <title>Class name<indexterm><primary>class name</primary></indexterm></title>

        <para>Edit the name of the class in the meta data. You should only
        need to edit this field if you have changed the name of one of your
        classes. When you add classes to a datastore it is filled in
        automatically.</para>
      </formalpara>

      <formalpara id="cp_pc_superclass">
        <title>PC superclass<indexterm><primary>PC superclass</primary></indexterm></title>

        <para>Select the persistent capable superclass of this class. This is
        filled in automatically when classes in a hierarchy are added to a
        datastore. You will need to edit it yourself if you make changes to
        the hierarchy later. The persistence hierarchy in JDO does not have to
        correspond to the Java class hierarchy so Versant Open Access cannot
        always use the Java superclass.</para>
      </formalpara>

      <formalpara id="cp_datastore">
        <title>Datastore<indexterm><primary>datastore</primary></indexterm></title>

        <para>Choose the datastore that this class belongs to (see <xref
        linkend="datastores" />). <emphasis>The multiple datastores feature
        has not been released yet</emphasis>.</para>
      </formalpara>

      <formalpara id="cp_identity_type">
        <title>Identity type<indexterm><primary>identity type</primary></indexterm></title>

        <para>Select the identity type for the class. With datastore identity
        Versant Open Access manages the primary key of the class itself and it
        is not visible as a field in the class. With application identity you
        must define primary key fields in the class and supply an
        objectid-class. See <xref linkend="object_identity" />.</para>
      </formalpara>

      <formalpara id="cp_objectid_class">
        <title>Object ID class<indexterm><primary>object ID class</primary></indexterm></title>

        <para>Specify the name of the objectid-class. This only required If
        you are using application identity. See <xref
        linkend="object_identity" />.</para>
      </formalpara>

      <formalpara id="cp_key_generator">
        <title>Key generator<indexterm><primary>key generator</primary></indexterm></title>

        <para>Define the primary key generator for a class. This can be set at
        class and datastore level. The key generator set at datastore level
        becomes the default for all datastore identity classes in that
        package. Note that you can use this to set a key generator for
        application identity classes (see <xref
        linkend="md_jdbc_key_generator" />).</para>
      </formalpara>

      <formalpara id="cp_opt_locking_field">
        <title>Opt. locking field<indexterm><primary>optimistic locking field</primary></indexterm></title>

        <para>The version and timestamp modes require an extra column for
        locking. Versant Open Access will automatically add a suitable column
        to the table or you can specify an existing field in your class. See
        <xref linkend="md_jdbc_optimistic_locking" />.</para>
      </formalpara>

      <formalpara id="cp_class_id">
        <title>Class ID<indexterm><primary>class ID</primary></indexterm></title>

        <para>Set the JDBC class ID for a class. Versant Open Access supports
        inheritance by using a class ID column in the base class table to
        specify the type of each row. The default class ID value for each
        class is a 31 bit hash generated from the fully qualified class name.
        You can specify any positive 32 bit integer (unique within the
        hierarchy). See <xref linkend="md_jdbc_class_id" />.</para>
      </formalpara>

      <formalpara id="cp_join_when_referenced">
        <title>Join when referenced<indexterm><primary>join when referenced</primary></indexterm></title>

        <para>Set the default join behaviour for references to this class. If
        this is set to &#34;inner&#34; or &#34;outer&#34; then references to
        this class from other classes will be read using a join instead of a
        separate query when navigated. See <xref linkend="md_jdbc_use_join" />.</para>
      </formalpara>
    </section>

    <section id="wbref_field_props">
      <title>Field Properties Window</title>

      <para>You can view and edit field properties using this Window. You can
      leave it open and select different fields on the fields grid.</para>

      <formalpara id="fp_field_name">
        <title>Field name<indexterm><primary>field name</primary></indexterm></title>

        <para>Edit the name of the field in the meta data. You should only
        need to edit this if you have changed the name of one of your fields
        in Java code.</para>
      </formalpara>

      <formalpara id="fp_primary_key">
        <title>Primary key<indexterm><primary>primary key</primary></indexterm></title>

        <para>Set this to true for the primary key fields of your class if you
        are using application identity. See <xref linkend="object_identity" />.</para>
      </formalpara>

      <formalpara id="fp_default_fetch_group">
        <title>Default fetch group<indexterm><primary>default fetch group</primary></indexterm></title>

        <para>Set this to true to put the field into the default fetch group
        (DFG). All the fields in the DFG are filled together when an instance
        is fetched from the database. Strings, ints, Dates etc. are all in the
        DFG by default. References in the DFG are fetched using an outer join
        (see <xref linkend="md_jdbc_use_join" />).</para>
      </formalpara>

      <formalpara id="fp_embedded">
        <title>Embedded<indexterm><primary>embedded</primary></indexterm></title>

        <para>This option is currently ignored by Versant Open Access. A
        future release will use this to store arbitrary data types using
        serialization.</para>
      </formalpara>

      <formalpara id="fp_column_name">
        <title>Column name<indexterm><primary>column name</primary></indexterm></title>

        <para>Edit the name of the database column for the field. The default
        name is generated by the name generator for the datastore (see <xref
        linkend="datastore_namegen" />).</para>
      </formalpara>

      <formalpara id="fp_jdbc_type">
        <title>JDBC type<indexterm><primary>JDBC type</primary></indexterm></title>

        <para>Select the JDBC type for the field. This controls how Versant
        Open Access uses JDBC (e.g. using getString to read VARCHAR columns).
        The JDBC type is mapped to a database specific SQL type using the JDBC
        type mappings for the datastore (see <xref linkend="field_mapping" />
        and <xref linkend="md_jdbc_column" />).</para>
      </formalpara>

      <formalpara id="fp_sql_type">
        <title>SQL type<indexterm><primary>SQL type</primary></indexterm></title>

        <para>Edit the SQL type used for the field when creating the database
        schema (see <xref linkend="field_mapping" /> and <xref
        linkend="md_jdbc_column" />).</para>
      </formalpara>

      <formalpara id="fp_sql_length">
        <title>Length<indexterm><primary>length</primary></indexterm></title>

        <para>Edit the SQL length or precision used for the field when
        creating the database schema (see <xref linkend="field_mapping" /> and
        <xref linkend="md_jdbc_column" />).</para>
      </formalpara>

      <formalpara id="fp_sql_scale">
        <title>Scale<indexterm><primary>scale</primary></indexterm></title>

        <para>Edit the SQL scale (digits to right of decimal point) used for
        the field when creating the database schema (see <xref
        linkend="field_mapping" /> and <xref linkend="md_jdbc_column" />).</para>
      </formalpara>

      <formalpara id="fp_converter">
        <title>Converter<indexterm><primary>converter</primary></indexterm></title>

        <para>Edit the JdbcConverter used to convert between JDBC and Java
        objects (see <xref linkend="field_mapping" /> and <xref
        linkend="md_jdbc_column" />).</para>
      </formalpara>

      <formalpara id="fp_persistence_modifier">
        <title>Persistence modifier<indexterm><primary>field name</primary></indexterm></title>

        <para>Use this to decide if the field should be persisted or not.
        Persistent &#34;none&#34; fields are ignored by JDO (i.e. not stored).
        Fields that are &#34;persistent&#34; are managed by JDO and stored.
        Fields that are &#34;transactional&#34; respect transaction boundaries
        but are not stored.</para>
      </formalpara>

      <formalpara id="fp_category">
        <title>Category<indexterm><primary>category</primary></indexterm></title>

        <para>Fields are assigned categories by Versant Open Access based on
        how they need to be persisted and on the type of field. This is read
        only but will change if you change the persistence modifier for the
        field.</para>
      </formalpara>

      <formalpara id="fp_link_table_name">
        <title>Link table name<indexterm><primary>link table name</primary></indexterm></title>

        <para>Set the name of the link table used to hold the collection. Note
        that collections may be mapped using a link table or a foreign key
        (see <xref linkend="md_jdbc_link_table" /> and <xref
        linkend="md_inverse" />).</para>
      </formalpara>

      <formalpara id="fp_inverse">
        <title>Link foreign key<indexterm><primary>link foreign key</primary></indexterm></title>

        <para>Set the name of the field used to complete a collection mapped
        using a foreign key. Note that collections may be mapped using a link
        table or a foreign key (see <xref linkend="md_jdbc_link_table" /> and
        <xref linkend="md_inverse" />).</para>
      </formalpara>

      <formalpara id="fp_inverse_index">
        <title>Foreign key index<indexterm><primary>foreign key index</primary></indexterm></title>

        <para>Set the name of the index created for the foreign key used to
        complete the collection. If the name is &#34;{no}&#34; then no index
        is created. If not set the index name is provided by the name
        generator (see <xref linkend="md_jdbc_index" />).</para>
      </formalpara>

      <formalpara id="fp_element_type">
        <title>Element type<indexterm><primary>element type</primary></indexterm></title>

        <para>Specify the type of objects stored in a collection or the type
        of values stored in a map. Versant Open Access needs this information
        to generate the database schema.</para>
      </formalpara>

      <formalpara id="fp_autoset">
        <title>Autoset<indexterm><primary>autoset</primary></indexterm></title>

        <para>Configure a field to be automatically set by Versant Open Access
        when new instances and/or changes are committed. This may only be used
        on java.util.Date, byte, short and int fields. See <xref
        linkend="md_autoset" />.</para>
      </formalpara>

      <formalpara id="fp_dependent">
        <title>Dependent<indexterm><primary>dependent</primary></indexterm></title>

        <para>Set a reference to a persistent class or the persistent values
        in a collection, array or map to be considered dependent. Dependent
        objects are deleted when the instance referring to them is deleted.
        Dependent values removed from a collection, array or map are also
        deleted. See <xref linkend="md_dependent" />.</para>
      </formalpara>

      <formalpara id="fp_fetch_group">
        <title>Fetch group<indexterm><primary>fetch group</primary></indexterm></title>

        <para>Set the fetch group for this field. All the fields in that group
        will be fetched when the field is fetched. This overrides the default
        fetch group attribute. See <xref linkend="md_fetch_group" />.</para>
      </formalpara>

      <formalpara id="fp_constraint">
        <title>Constraint<indexterm><primary>constraint</primary></indexterm></title>

        <para>Set the name of the referential integrity constraint for the
        field or disable the constraint. If the constraint is &#34;{no}&#34;
        then no constraint is generated. Note that many databases do not
        support constraints for columns that allow nulls. See <xref
        linkend="md_jdbc_constraint" />.</para>
      </formalpara>

      <formalpara id="fp_use_join">
        <title>Use join<indexterm><primary>use join</primary></indexterm></title>

        <para>Set the type of join used to fetch the referenced instance (no,
        outer or inner). This can be used to solve the N+1 database calls
        problem. Be careful with using inner joins as rows may be lost from
        queries. See <xref linkend="md_jdbc_use_join" />.</para>
      </formalpara>

      <formalpara id="fp_key_type">
        <title>Key type<indexterm><primary>key type</primary></indexterm></title>

        <para>Specify the type of keys used in a map. Versant Open Access
        needs this information to generate the database schema.</para>
      </formalpara>

      <formalpara id="fp_keys_dependent">
        <title>Keys dependent<indexterm><primary>keys dependent</primary></indexterm></title>

        <para>Set the persistent keys in a map to be considered dependent.
        Dependent objects are deleted when the instance referring to them is
        deleted. Dependent keys removed from a map are also deleted. See <xref
        linkend="md_keys_dependent" />.</para>
      </formalpara>

      <formalpara id="fp_null_value">
        <title>Null value<indexterm><primary>null value</primary></indexterm></title>

        <para>Control the treatment of null values. If this is set to
        &#34;default&#34; then the field is mapped to a column that allows
        nulls. If this is set to &#34;exception&#34; then the field is mapped
        to a column that does not allow nulls.</para>
      </formalpara>

      <formalpara id="fp_ordered">
        <title>Ordered<indexterm><primary>ordered</primary></indexterm></title>

        <para>Configure a collection as ordered or not. By default Versant
        Open Access preserves the order of elements in List&#39;s by adding a
        sequence column to the table used to store the elements. See <xref
        linkend="md_ordered" />.</para>
      </formalpara>

      <formalpara id="fp_ordering">
        <title>Ordering<indexterm><primary>ordering</primary></indexterm></title>

        <para>Define an ordering for an otherwise unordered collection using a
        JDOQL ordering expression on the element type. See <xref
        linkend="md_ordering" />.</para>
      </formalpara>

      <formalpara id="fp_nulls">
        <title>Nulls<indexterm><primary>nulls</primary></indexterm></title>

        <para>Set the nulls allowed option for the column in the generated
        schema. Normally it is better to use the standard JDO null-value
        attribute to control this (see <xref linkend="fp_null_value" />).</para>
      </formalpara>

      <para></para>
    </section>
  </appendix>

  <appendix id="upgrading_from_jdogenie">
    <title>Upgrading from JDO Genie</title>

    <para>This appendix describes the steps necesary to upgrade an application
    using JDO Genie to Versant Open Access:</para>

    <orderedlist>
      <listitem>
        <para>The main jar files have been renamed: jdogenie.jar is now
        openaccess.jar. Likewise jdogenie-tools.jar is now
        openaccess-tools.jar.</para>

        <para>Fix: Update your build scripts and IDE project files to use the
        new jars.</para>
      </listitem>

      <listitem>
        <para>The jdogenie.tasks resource defining the Ant tasks is now called
        versant.tasks. The old file is included for now but will be dropped in
        future.</para>

        <para>Fix: Change the taskdef in your Ant scripts to use versant.tasks
        instead.</para>
      </listitem>

      <listitem>
        <para>The public JDOGenieXXX interfaces and classes have changed to
        VersantXXX and are in packages under com.versant.core.jdo.</para>

        <para>Fix: Replace references to the following classes and interfaces
        in your code (meta data files and .jdogenie project files are fixed by
        the Workbench):</para>
      </listitem>

      <listitem>
        <para>The methods in VersantPersistenceManager (old
        JDOGeniePersistenceManager) named jdoGenieXXX have been renamed to
        versantXXX.</para>

        <para>Fix: Edit your source code to use the new names using the table
        after this list of points.</para>
      </listitem>

      <listitem>
        <para>Bidirectional relationships (one-to-many and many-to-many) are
        now unmanaged by default.</para>

        <para>Fix: Change the defaults in <command>File | Project Properties |
        Datastore / General</command> settings.</para>
      </listitem>

      <listitem>
        <para>The vendor attribute on extensions in the .jdo meta data has
        changed from &#34;jdogenie&#34; to &#34;versant&#34;. The .jdogenie
        project file now has a .properties extension by default and the names
        of the properties have changed. The Versant Open Access runtime and
        Ant tasks still accept the old property names but the Workbench does
        not.</para>

        <para>Fix: Open your .jdogenie project file in the Workbench. You will
        be prompted to convert it to a new format .properties file. The .jdo
        meta data for your project will also be converted.</para>
      </listitem>

      <listitem>
        <para>Versant Open Access uses a JCA adapter for application server
        integration instead of the MBean used by JDO Genie. The mbean is still
        included in the distribution but the package name has changed from to
        za.co.hemtech.jdo.mbean to com.versant.core.jdo.mbean. The mbean is no
        longer supported.</para>

        <para>Fix: Change to the JCA adapter (see <xref
        linkend="ejb_applications" />). You could keep using the mbean if you
        update your configuration files but this is not supported.</para>
      </listitem>

      <listitem>
        <para>The jdo-create-db Ant task now creates a script called
        <filename>versant.sql</filename> in the output directory instead of a
        file named after the datastore (typically <filename>main.sql</filename>).</para>

        <para>Fix: No need to do anything unless your build process depends on
        the old name. If so use the out attribute to specify the old name when
        invoking the task.</para>
      </listitem>
    </orderedlist>

    <informaltable>
      <tgroup cols="2">
        <thead>
          <row>
            <entry>Old za.co.hemtech.jdo class</entry>

            <entry>New com.versant.core class</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>client.VersantPersistenceManager</entry>

            <entry>jdo.VersantPersistenceManager</entry>
          </row>

          <row>
            <entry>client.VersantPersistenceManagerFactory</entry>

            <entry>jdo.VersantPersistenceManagerFactory</entry>
          </row>

          <row>
            <entry>client.JDOGenieQuery</entry>

            <entry>jdo.VersantQuery</entry>
          </row>

          <row>
            <entry>client.JDOGenieHelper</entry>

            <entry>jdo.VersantHelper</entry>
          </row>

          <row>
            <entry>client.JDOGenieBackgroundTask</entry>

            <entry>jdo.VersantBackgroundTask</entry>
          </row>

          <row>
            <entry>client.JDOGenieOid</entry>

            <entry>jdo.VersantOid</entry>
          </row>

          <row>
            <entry>exception.JDOGenieObjectNotFoundException</entry>

            <entry>javax.jdo.JDOObjectNotFoundException</entry>
          </row>

          <row>
            <entry>common.JDOGenieConcurrentUpdateException</entry>

            <entry>javax.jdo.JDOOptimisticVerificationException</entry>
          </row>

          <row>
            <entry>common.JDOGenieConnectionPoolFullException</entry>

            <entry>common.VersantConnectionPoolFullException</entry>
          </row>

          <row>
            <entry>common.JDOGenieNullElementException</entry>

            <entry>common.VersantNullElementException</entry>
          </row>

          <row>
            <entry>server.JDOGenieAuthenticationException</entry>

            <entry>server.VersantAuthenticationException</entry>
          </row>

          <row>
            <entry>server.JDOGenieServerSideException</entry>

            <entry>server.VersantServerSideException</entry>
          </row>

          <row>
            <entry>server.cluster.JDOGenieClusterTransport</entry>

            <entry>server.cluster.VersantClusterTransport</entry>
          </row>

          <row>
            <entry>server.cluster.JDOGenieClusterMsgHandler</entry>

            <entry>server.cluster.VersantClusterMsgHandler</entry>
          </row>

          <row>
            <entry>server.jdbc.*</entry>

            <entry>jdbc.*</entry>
          </row>

          <row>
            <entry>server.jdbc.sql.*</entry>

            <entry>jdbc.sql.*</entry>
          </row>

          <row>
            <entry>server.jdbc.sql.conv.*</entry>

            <entry>jdbc.sql.conv.*</entry>
          </row>

          <row>
            <entry>server.perf.*</entry>

            <entry>server.perf.*</entry>
          </row>

          <row>
            <entry>client.metric.*</entry>

            <entry>server.metric.*</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
  </appendix>

  <index></index>
</book>